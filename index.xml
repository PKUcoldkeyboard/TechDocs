<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CS技术文档</title>
    <link>https://cuterwrite.top/TechDocs/</link>
    <description>Recent content on CS技术文档</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 30 Jan 2024 02:21:15 +0000</lastBuildDate><atom:link href="https://cuterwrite.top/TechDocs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>前言</title>
      <link>https://cuterwrite.top/TechDocs/docs/overview/</link>
      <pubDate>Fri, 15 Sep 2023 00:00:00 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/overview/</guid>
      <description>这是一个计算机的技术资料库。</description>
    </item>
    
    <item>
      <title>计算机相关技术资料整理 </title>
      <link>https://cuterwrite.top/TechDocs/docs/practical-programing-book/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/practical-programing-book/</guid>
      <description>这里收录比较实用的计算机相关技术书籍，可以在短期之内入门的简单实用教程、一些技术网站以及一些写的比较好的博文，欢迎Fork，你也可以通过Pull Request参与编辑。
程序员必读书籍 目录 link 语言相关类
Android AWK SED C/C++ CSS/HTML Dart Erlang Fortran Go Groovy Haskell iOS Java JavaScript LaTeX LISP Lua Perl PHP Prolog Python R Ruby Scala Scheme Shell Swift WebAssembly 语言无关类
操作系统 版本控制 分布式系统 编辑器 NoSQL MySQL PostgreSQL 项目相关 设计模式 Web 大数据 编程艺术 函数式编程 运维监控 WEB服务器 语言无关类 link操作系统 link 开源世界旅行手册 鸟哥的Linux私房菜 Linux 系统高级编程 Zephyr OS 中文文档(v1.6.0) The Linux Command Line (中英文版) Linux 设备驱动 (第三版) 深入分析Linux内核源码 UNIX TOOLBOX Docker中文指南 Docker —— 从入门到实践 Docker入门实战 Docker Cheat Sheet FreeRADIUS新手入门 Mac 开发配置手册 FreeBSD 使用手册 Linux 命令行(中文版) Linux 构建指南 Linux工具快速教程 Linux Documentation (中文版) 嵌入式 Linux 知识库 (eLinux.</description>
    </item>
    
    <item>
      <title>Redis 指南</title>
      <link>https://cuterwrite.top/TechDocs/docs/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF/readme/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF/readme/</guid>
      <description>关于此书 link许可证 link《The Little Redis Book》是经由Attribution-NonCommercial 3.0 Unported license许可的，你不需要为此书付钱。
你可以自由地对此书进行复制，分发，修改或者展示等操作。当然，你必须知道且认可这本书的作者是Karl Seguin，译者是赖立维，而且不应该将此书用于商业用途。
关于这个许可证的详细描述在这里：
http://creativecommons.org/licenses/by-nc/3.0/legalcode
关于作者 link作者Karl Seguin是一名在多项技术领域浸淫多年的开发者。他是开源软件计划的活跃贡献者，同时也是一名技术作者以及业余演讲者。他写过若干关于Radis的文章以及一些工具。在他的一个面向业余游戏开发者的免费服务里，Redis为其中的评级和统计功能提供了支持：mogade.com。
Karl之前还写了《The Little MongoDB Book》，这是一本免费且受好评，关于MongoDB的书。
他的博客是http://openmymind.net，你也可以关注他的Twitter帐号，via @karlseguin。
关于译者 link译者 赖立维 是一名长在天朝的普通程序员，对许多技术都有浓厚的兴趣，是开源软件的支持者，Emacs的轻度使用者。
虽然译者已经很认真地对待这次翻译，但是限于水平有限，肯定会有不少错漏，如果发现该书的翻译有什么需要修改，可以通过他的邮箱与他联系。他的邮箱是jasonlai256@gmail.com。
致谢 link必须特别感谢Perry Neal一直以来的指导，我的眼界、触觉以及激情都来源于你。你为我提供了无价的帮助，感谢你。
最新版本 link此书的最新有效资源在： http://github.com/karlseguin/the-little-redis-book
中文版是英文版的一个分支，最新的中文版本在： https://github.com/JasonLai256/the-little-redis-book
\clearpage
简介 link最近几年来，关于持久化和数据查询的相关技术，其需求已经增长到了让人惊讶的程度。可以断言，关系型数据库再也不是放之四海皆准。换一句话说，围绕数据的解决方案不可能再只有唯一一种。
对于我来说，在众多新出现的解决方案和工具里，最让人兴奋的，无疑是Redis。为什么？首先是因为其让人不可思议的容易学习，只需要简短的几个小时学习时间，就能对Redis有个大概的认识。还有，Redis在处理一组特定的问题集的同时能保持相当的通用性。更准确地说就是，Redis不会尝试去解决关于数据的所有事情。在你足够了解Redis后，事情就会变得越来越清晰，什么是可行的，什么是不应该由Redis来处理的。作为一名开发人员，如此的经验当是相当的美妙。
当你能仅使用Redis去构建一个完整系统时，我想大多数人将会发现，Redis能使得他们的许多数据方案变得更为通用，不论是一个传统的关系型数据库，一个面向文档的系统，或是其它更多的东西。这是一种用来实现某些特定特性的解决方法。就类似于一个索引引擎，你不会在Lucene上构建整个程序，但当你需要足够好的搜索，为什么不使用它呢？这对你和你的用户都有好处。当然，关于Redis和索引引擎之间相似性的讨论到此为止。
本书的目的是向读者传授掌握Redis所需要的基本知识。我们将会注重于学习Redis的5种数据结构，并研究各种数据建模方法。我们还会接触到一些主要的管理细节和调试技巧。
入门 link每个人的学习方式都不一样，有的人喜欢亲自实践学习，有的喜欢观看教学视频，还有的喜欢通过阅读来学习。对于Redis，没有什么比亲自实践学习来得效果更好的了。Redis的安装非常简单。而且通过随之安装的一个简单的命令解析程序，就能处理我们想做的一切事情。让我们先花几分钟的时间把Redis安装到我们的机器上。
Windows平台 linkRedis并没有官方支持Windows平台，但还是可供选择。你不会想在这里配置实际的生产环境，不过在我过往的开发经历里并没有感到有什么限制。
首先进入https://github.com/dmajkic/redis/downloads，然后下载最新的版本（应该会在列表的最上方）。
获取zip文件，然后根据你的系统架构，打开64bit或32bit文件夹。
*nix和MacOSX平台 link对于*nix和MacOSX平台的用户，从源文件来安装是你的最佳选择。通过最新的版本号来选择，有效地址于http://redis.io/download。在编写此书的时候，最新的版本是2.4.6，我们可以运行下面的命令来安装该版本：
wget http://redis.googlecode.com/files/redis-2.4.6.tar.gz tar xzf redis-2.4.6.tar.gz cd redis-2.4.6 make （当然，Redis同样可以通过套件管理程序来安装。例如，使用Homebrew的MaxOSX用户可以只键入brew install redis即可。）
如果你是通过源文件来安装，二进制可执行文件会被放置在src目录里。通过运行cd src可跳转到src目录。
运行和连接Redis link如果一切都工作正常，那Redis的二进制文件应该已经可以曼妙地跳跃于你的指尖之下。Redis只有少量的可执行文件，我们将着重于Redis的服务器和命令行界面（一个类DOS的客户端）。首先，让我们来运行服务器。在Windows平台，双击redis-server，在*nix/MacOSX平台则运行./redis-server.
如果你仔细看了启动信息，你会看到一个警告，指没能找到redis.conf文件。Redis将会采用内置的默认设置，这对于我们将要做的已经足够了。
然后，通过双击redis-cli（Windows平台）或者运行./redis-cli（*nix/MacOSX平台），启动Redis的控制台。控制台将会通过默认的端口（6379）来连接本地运行的服务器。
可以在命令行界面键入info命令来查看一切是不是都运行正常。你会很乐意看到这么一大组关键字-值（key-value）对的显示，这为我们查看服务器的状态提供了大量有效信息。
如果在上面的启动步骤里遇到什么问题，我建议你到Redis的官方支持组里获取帮助。
驱动Redis link很快你就会发现，Redis的API就如一组定义明确的函数那般容易理解。Redis具有让人难以置信的简单性，其操作过程也同样如此。这意味着，无论你是使用命令行程序，或是使用你喜欢的语言来驱动，整体的感觉都不会相差多少。因此，相对于命令行程序，如果你更愿意通过一种编程语言去驱动Redis，你不会感觉到有任何适应的问题。如果真想如此，可以到Redis的客户端推荐页面下载适合的Redis载体。</description>
    </item>
    
    <item>
      <title>目录</title>
      <link>https://cuterwrite.top/TechDocs/docs/c-guide/summary/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/c-guide/summary/</guid>
      <description> 笨办法学C 中文版 前言 导言：C的笛卡尔之梦 练习0：准备 练习1：启用编译器 练习2：用Make来代替Python 练习3：格式化输出 练习4：Valgrind 介绍 练习5：一个C程序的结构 练习6：变量类型 练习7：更多变量和一些算术 练习8：大小和数组 练习9：数组和字符串 练习10：字符串数组和循环 练习11：While循环和布尔表达式 练习12：If，Else If，Else 练习13：Switch语句 练习14：编写并使用函数 练习15：指针，可怕的指针 练习16：结构体和指向它们的指针 练习17：堆和栈的内存分配 练习18：函数指针 练习19：一个简单的对象系统 练习20：Zed的强大的调试宏 练习21：高级数据类型和控制结构 练习22：栈、作用域和全局 练习23：认识达夫设备 练习24：输入输出和文件 练习25：变参函数 练习26：编写第一个真正的程序 练习27：创造性和防御性编程 练习28：Makefile 进阶 练习29：库和链接 练习30：自动化测试 练习31：代码调试 练习32：双向链表 练习33：链表算法 练习34：动态数组 练习35：排序和搜索 练习36：更安全的字符串 练习37：哈希表 练习38：哈希算法 练习39：字符串算法 练习40：二叉搜索树 练习41：将 Cachegrind 和 Callgrind 用于性能调优 练习42：栈和队列 练习43：一个简单的统计引擎 练习44：环形缓冲区 练习45：一个简单的TCP/IP客户端 练习46：三叉搜索树 练习47：一个快速的URL路由 后记：“解构 K&amp;amp;R C” 已死 捐赠名单 </description>
    </item>
    
    <item>
      <title>笨办法学C 中文版</title>
      <link>https://cuterwrite.top/TechDocs/docs/c-guide/readme/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/c-guide/readme/</guid>
      <description>来源：Learn C The Hard Way
作者：Zed A. Shaw
译者：飞龙
自豪地采用谷歌翻译
一句 MMP 送给在座的各位程序正义垃圾。
在线阅读 PDF格式 EPUB格式 MOBI格式 Github 赞助我 link 协议 link此版本遵循CC BY-NC-SA 4.0协议，原版无此约束。</description>
    </item>
    
    <item>
      <title>前言</title>
      <link>https://cuterwrite.top/TechDocs/docs/c-guide/preface/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/c-guide/preface/</guid>
      <description>原文：Preface
译者：飞龙
这是本书创作中的转储版本，所用的措辞可能不是很好，也可能缺失了一些章节，但是你可以看到我编写这本书的过程，以及我的做事风格。
你也可以随时发送邮件到help@learncodethehardway.org来向我寻求帮助，我通常会在1~2天之内答复。
这个列表是一个讨论列表，并不只允许发布公告，它用于讨论本书和询问问题。
最后，不要忘了我之前写过笨办法学Python，如果你还不会编程，你应该先读完它。LCTHW并不面向初学者，而是面向至少读完LPTHW或者已经懂得一门其它编程语言的人。
常见问题 link这门课程需要多少时间？
你应该花一些时间直到你掌握它，并且每天都要坚持编写代码。一些人花了大约三个月，其它人花了六个月，还有一些人只用了一个星期。
我需要准备什么样的电脑？
你需要OSX或者Linux来完成这本书。</description>
    </item>
    
    <item>
      <title>导言：C的笛卡尔之梦</title>
      <link>https://cuterwrite.top/TechDocs/docs/c-guide/introduction/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/c-guide/introduction/</guid>
      <description>原文：Introduction: The Cartesian Dream Of C
译者：飞龙
‍
直到现在，凡是我当作最真实、最可靠而接受的东西，都是从感官或通过感官得来的。不过，我有时觉得这些感官是骗人的，并且为了小心谨慎起见，对于一经骗过我们的东西就决不完全加以信任。
勒内·笛卡尔，《第一哲学沉思录》
如果有一段引述用来描述C语言编程的话，那就是它了。对于大多数程序员，C是极其可怕而且邪恶的。他就像是恶魔、撒旦，或者一个使用指针的花言巧语和对机器的直接访问来破坏你生产力的骗子洛基。于是，一旦这位计算界的路西法将你缠住，他就会使用邪恶的“段错误”来毁掉你的世界，并且揭露出与你交易中的骗局而嘲笑你。
然而，C并不应由于这些事实而受到责备。你的电脑和控制它的操作系统才是真正的骗子，而不是朋友。它们通过密谋来向你隐藏它们的真实执行逻辑，使你永远都不真正知道背后发生了什么。C编程语言的失败之处只是向你提供接触背后真正工作原理的途径，并且告诉了你一些难以接受的事实。C会向你展示痛苦的真像（红色药丸），它将幕布拉开来向你展示一些神奇的原理。C即是真理。
既然C如此危险，为什么还要使用它？因为C给了你力量来穿越抽象的假象，并且将你从愚昧中解放出来。
你会学到什么 link这本书的目的是让你足够熟悉C语言，并能够使用它编写自己的软件，或者修改其他人的代码。这本书的最后，我们会从一本叫做“K&amp;amp;R C”的名著中选取实际的代码，并且用你学过的知识来做代码审查。你需要学习下面这些东西来达到这一阶段：
C的基本语法和编写习惯。 编译，make文件和链接。 寻找和预防bug。 防御性编程实践。 使C的代码崩溃。 编写基本的Unix系统软件。 截至最后一章，你将会有足够的工具来解决基本的系统软件、库和其它小项目。
如何阅读本书 link这本书为那些已经掌握至少一门编程语言的人而设计。如果你还没有接触过编程，我推荐你先学习笨办法学Python，这本书适用于真正的新手并且适合作为第一本编程书。一旦你学会了Python，你可以返回来开始学习这本书。
对于那些已经学会编程的人，这本书的开头可能有些奇怪。它不像其它书一样，那些书中你会阅读一段段的文字然后编写一些代码。相反，这本书中我会让你立即开始编程，之后我会解释你做了什么。这样更有效果，因为你已经经历过的事情解释起来更加容易。
由于采用了这样的结构，下面是本书中你必须遵守的规则：
手动输入所有代码。不要复制粘贴！ 正确地输入所有代码，也包括注释。 运行代码并保证产生相同的输出。 如果出现了bug则修正它。 做附加题时，如果你做不出某道题，马上跳过。 在寻求帮助之前首先试着自己弄懂。 如果你遵守了这些规则，完成了本书的每一件事，并且还不会编程C代码的话，你至少尝试过了。它并不适用于每个人，但是尝试的过程会让你成为一个更好的程序员。
核心能力 link我假设你之前使用为“弱者”设计的语言。这些“易用的”语言之一是Python或者Ruby，它们带给了你草率的思维和半吊子的黑魔法。或者，你可能使用类似Lisp的语言，它假设计算机是纯函数式的奇幻大陆，带有一些为婴儿准备的充气墙。再或者你可能学过Prolog，于是你认为整个世界都是一个数据库，你可以从中寻找线索。甚至更糟糕的是，我假设你一直都在用IDE，所以你的大脑布满了内存漏洞，并且你每打三个字符都要按CTRL+空格来打出函数的整个名字。
无论你的背景如何，你都可能不擅长下面四个技能：
阅读和编写
如果你使用IDE这会尤其正确。但是总体上我发现程序员做了很多“略读”，并且在理解上存在问题。它们会略读需要详细理解的代码，并且觉得他们已经理解了但事实上没有。其它语言提供了可以让他们避免实际编写任何代码的工具，所以面对一种类似C的语言时，他们就玩完了。你需要知道每个人都有这个问题，并且你可以通过强迫自己慢下来并且仔细对待阅读和编写代码来改正它。一开始你可能感到痛苦和无聊，但是这样的次数多了它也就变得容易了。
专注细节
每个人都不擅长这方面，它也是劣质软件的罪魁祸首。其它语言让你不会集中注意力，但是C要求你集中全部注意力，因为它直接在机器上运行，并且机器比较挑剔。C中没有“相似的类型”或者“足够接近”，所以你需要注意，再三检查你的代码，并假设你写的任何代码都是错的，直到你能证明它是对的。
定位差异
其它语言程序员的一个关键问题就是他们的大脑被训练来指出那个语言的差异，而不是C。当你对比你的代码和我练习中的代码时，你的眼睛会跳过你认为不重要或者不熟悉的字符。我会给你一些策略来强制你观察你的错误，但是要记住如果你的代码并不完全像书中的代码，它就是错的。
规划和调试
我喜欢其它较简单的语言，因为我可以想怎么写就怎么写。我将已有的想法输入进解释器，然后可以立即看到结果。你可以把你的想法试验出来，但是要注意，如果你仍然打算“试验代码使其能够工作”，它就行不通了。C对于你来说稍困难，因为你需要规划好首先创建什么。的确，你也可以进行试验，但是比起其他语言，你必须在C中更早地严肃对待代码。我会教给你在编程之前规划程序核心部分的方法，这对于使你成为更好的程序员十分有帮助。即使一个很小的规划，都会使接下来的事情变得顺利。
学习C语言会使你变成更好的程序员，因为会强制你更早、更频繁地解决这些问题。你不会再草率地编写半吊子的代码，代码也会能够正常工作。C的优势是，它是一个简单的语言，你可以自己来弄清楚，这使得它成为用于学习机器，以及提升程序员核心技能的最佳语言。
C比其它语言都要难，而这是由于C并不对你隐藏细节，它们在其它语言中都试图并且未能被掩盖。
协议 link原书在完稿之后可以自由分发，并且能在亚马逊上购买。该中译版本遵循CC BY-NC-SA 4.0协议，你可以在保留署名和出处的前提下以非商业目的自由转载。</description>
    </item>
    
    <item>
      <title>练习0：准备</title>
      <link>https://cuterwrite.top/TechDocs/docs/c-guide/ex0/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/c-guide/ex0/</guid>
      <description>原文：Exercise 0: The Setup
译者：飞龙
在这一章中，你将为C语言编程配置好你的系统。一个好消息是对于所有使用Linux或者Mac的人，你的系统是为C语言编程而设计的。C语言的创造者也对Unix操作系统的创造做出了贡献，并且Linux和OSX都是基于Unix的。事实上，安装工作会非常简单。
对于Windows上的用户，我有一个坏消息：在Windows上学习C非常痛苦。你可以在Windows上编写C代码，这并不是问题。问题是所有的库、函数和工具都和其它的C语言环境有些差异。C来自于Unix，并且和Unix平台配合得比较好。恐怕这是一个你并不能接受的事实。
然而你并不需要为此恐慌。我并不是说要完全避免Windows。然而我说的是，如果你打算以最短的时间来学习C，你需要接触Unix并适应它。这同时也对你有帮助，因为懂得一些Unix的知识，也会让你懂得一些C编程的习惯，以及扩充你的技能。
这也意味着每个人都需要使用命令行。嗯，就是这样。你将会进入命令行并且键入一些命令。不要为此感到害怕，因为我会告诉你要键入什么，以及结果应该是什么样子，所以你实际上会学到很多东西，同时扩充自己的技能。
Linux link在多数Linux系统上你都需要安装一些包。对于基于Debian的系统，例如Ubuntu你需要使用下列命令来安装一些东西：
$ sudo apt-get install build-essential 上面是命令行提示符的一个示例。你需要接触到能输入它的地方，找到你的“终端”程序并且运行它。接着，你会看到一个类似于$的Shell提示符，并且你可以在里面键入命令。不要键入$，而是它后面的东西。
下面是在基于RPM的Linux系统，例如Fedora中执行相同安装工作的方法：
$ su -c &amp;#34;yum groupinstall development-tools&amp;#34; 一旦你运行了它，它会正常工作，你应该能够做本书的第一个练习。如果不能请告诉我。
Mac OSX link在 Mac OSX上，安装工作会更简单。首先，你需要从苹果官网下载最新的XCode，或者找到你的安装DVD并从中安装。需要下载的文件很大，要花费很长时间，所以我推荐你从DVD安装。同时，上网搜索“安装xcode”来指导你来安装它。
一旦你安装完XCode，可能需要重启你的电脑。你可以找到你的终端程序并且将它放到快捷启动栏中。在本书中你会经常用到终端，所以最好将它放到顺手的区域。
Windows link对于Windows用户，你需要在虚拟机中安装并运行一个基本的Ubuntu Linux系统，来做本书的练习，并且避免任何Windows中安装的问题。
译者注：如果你的Windows版本是Win10 14316及之后的版本，可以开启Ubuntu子系统来获取Linux环境。
文本编辑器 link对于程序员来说，文本编辑器的选择有些困难。对于初学者我推荐他们使用Gedit，因为它很简单，并且可以用于编写代码。然而，它在特定的国际化环境中并不能正常工作。如果你已经是老司机的话，你可以选用你最喜欢的编辑器。
出于这种考虑，我打算让你尝试一些你所在平台上的标准的用于编程的文本编辑器，并且长期使用其中你最喜欢的一个。如果你已经用了Gedit并且很喜欢他，那么就一致用下去。如果你打算尝试一些不同的编辑器，则赶快尝试并选择一个。
最重要的事情是，不要纠结于寻找最完美的编辑器。文本编辑器几乎都很奇怪，你只需要选择一个并熟悉它，如果你发现喜欢别的编辑器可以切换到它。不要在挑选它和把它变得更好上面花很多时间。
这是亦可以尝试的一些编辑器：
Linux和OSX上的Gedit。 OSX上的TextWrangler。 可以在终端中运行并几乎在任何地方工作的Nano。 Emacs和Emacs OSX。需要学习一些东西。 Vim和Mac Vim。 每个人都可能选择一款不同的编辑器，这些只是一部分人所选择的开源编辑器。在找到你最喜欢的那个之前，尝试其中的一些，甚至是一些商业编辑器。
警告：不要使用IDE linkIDE，或者“集成开发工具”，会使你变笨。如果你想要成为一个好的程序员，它会是最糟糕的工具，因为它隐藏了背后的细节，你的工作是弄清楚背后发生了什么。如果你试着完成一些事情，并且所在平台根据特定的IDE而设计，它们非常有用，但是对于学习C编程（以及许多其它语言），它们没有意义。
注
如果你玩过吉他，你应该知道TAB是什么。但是对于其它人，让我对其做个解释。在音乐中有一种乐谱叫做“五线谱”。它是通用、非常古老的乐谱，以一种通用的方法来记下其它人应该在乐器上弹奏的音符。如果你弹过钢琴，这种乐谱非常易于使用，因为它几乎就是为钢琴和交响乐发明的。
然而吉他是一种奇怪的乐器，它并不能很好地适用这种乐谱。所以吉他手通常使用一种叫做TAB（tablature）的乐谱。它所做的不是告诉你该弹奏哪个音符，而是在当时应该拨哪根弦。你完全可以在不知道所弹奏的单个音符的情况下学习整首乐曲，许多人也都是这么做的，但是如果你想知道你弹的是什么，TAB是毫无意义的。
传统的乐谱可能比TAB更难一些，但是会告诉你如何演奏音乐，而不是如果玩吉他。通过传统的乐谱我可以在钢琴上，或者在贝斯上弹奏相同的曲子。我也可以将它放到电脑中，为它设计全部的曲谱。但是通过TAB我只能在吉他上弹奏。
IDE就像是TAB，你可以用它非常快速地编程，但是你只能够用一种语言在一个平台上编程。这就是公司喜欢将它卖给你的原因。它们知道你比较懒，并且由于它只适用于它们自己的平台，他们就将你锁定在了那个平台上。
打破这一循环的办法就是不用IDE学习编程。一个普通的文本编辑器，或者一个程序员使用的文本编辑器，例如Vim或者Emacs，能让你更熟悉代码。这有一点点困难，但是终结果是你将会熟悉任何代码，在任何计算机上，以任何语言，并且懂得背后的原理。</description>
    </item>
    
    <item>
      <title>练习1：启用编译器</title>
      <link>https://cuterwrite.top/TechDocs/docs/c-guide/ex1/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/c-guide/ex1/</guid>
      <description>原文：Exercise 1: Dust Off That Compiler
译者：飞龙
这是你用C写的第一个简单的程序：
int main(int argc, char *argv[]) { puts(&amp;#34;Hello world.&amp;#34;); return 0; } 把它写进 ex1.c 并输入：
$ make ex1 cc ex1.c -o ex1 你的编译器可能会使用一个有些不同的命令，但是最后应该会产生一个名为ex1的文件，并且你可以运行它。
你会看到什么 link现在你可以运行程序并看到输出。
$ ./ex1 Hello world. 如果没有，则需要返回去修复它。
如何使它崩溃 link在这本书中我会添加一个小节，关于如何使程序崩溃。我会让你对程序做一些奇怪的事情，以奇怪的方式运行，或者修改代码，以便让你看到崩溃和编译器错误。
对于这个程序，打开所有编译警告重新构建它：
$ rm ex1 $ CFLAGS=&amp;#34;-Wall&amp;#34; make ex1 cc -Wall ex1.c -o ex1 ex1.c: In function &amp;#39;main&amp;#39;: ex1.c:3: warning: implicit declaration of function &amp;#39;puts&amp;#39; $ ./ex1 Hello world. $ 现在你会得到一个警告，说puts函数是隐式声明的。C语言的编译器很智能，它能够理解你想要什么。但是如果可以的话，你应该去除所有编译器警告。把下面一行添加到ex1.c文件的最上面，之后重新编译来去除它：</description>
    </item>
    
    <item>
      <title>练习2：用Make来代替Python</title>
      <link>https://cuterwrite.top/TechDocs/docs/c-guide/ex2/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/c-guide/ex2/</guid>
      <description>原文：Exercise 2: Make Is Your Python Now
译者：飞龙
在Python中，你仅仅需要输入python，就可以运行你想要运行的代码。Python的解释器会运行它们，并且在运行中导入它所需的库和其它东西。C是完全不同的东西，你需要事先编译你的源文件，并且手动将它们整合为一个可以自己运行的二进制文件。手动来做这些事情很痛苦，在上一个练习中只需要运行make就能完成。
这个练习是GNU make 的速成课，由于你在学C语言，所以你就必须掌握它。Make 将贯穿剩下的课程，等效于Python（命令）。它会构建源码，执行测试，设置一些选项以及为你做所有Python通常会做的事情。
有所不同的是，我会向你展示一些更智能化的Makefile魔法，你不需要指出你的C程序的每一个愚蠢的细节来构建它。我不会在练习中那样做，但是你需要先用一段时间的“低级 make”，我才能向你演示“大师级的make”。
使用 Make link使用make的第一阶段就是用它已知的方式来构建程序。Make预置了一些知识，来从其它文件构建多种文件。上一个练习中，你已经使用像下面的命令来这样做了：
$ make ex1 $ CFLAGS=&amp;#34;-Wall&amp;#34; make ex1 第一个命令中你告诉make，“我想创建名为ex1的文件”。于是Make执行下面的动作：
文件ex1存在吗？ 没有。好的，有没有其他文件以ex1开头？ 有，叫做ex1.c。我知道如何构建.c文件吗？ 是的，我会运行命令cc ex1.c -o ex1来构建它。 我将使用cc从ex1.c文件来为你构建ex1。 上面列出的第二条命令是一种向make命令传递“修改器”的途径。如果你不熟悉Unix shell如何工作，你可以创建这些“环境变量”，它们会在程序运行时生效。有时你会用一条类似于export CFLAGS=&amp;quot;-Wall&amp;quot;的命令来执行相同的事情，取决于你所用的shell。然而你可以仅仅把它们放到你想执行的命令前面，于是环境变量只会在程序运行时有效。
在这个例子中我执行了CFLAGS=&amp;quot;-Wall&amp;quot; make ex1，所以它会给make通常使用的cc命令添加-Wall选项。这行命令告诉cc编译器要报告所有的警告（然而实际上不可能报告所有警告）。
实际上你可以深入探索使用make的上述方法，但是先让我们来看看Makefile，以便让你对make了解得更多一点。首先，创建文件并写入以下内容：
CFLAGS=-Wall -g clean: rm -f ex1 将文件在你的当前文件夹上保存为Makefile。Make会自动假设当前文件夹中有一个叫做Makefile的文件，并且会执行它。此外，一定要注意：确保你只输入了 TAB 字符，而不是空格和 TAB 的混合。
译者注：上述代码中第四行rm前面是一个 TAB ，而不是多个等量的空格。
Makefile向你展示了make的一些新功能。首先我们在文件中设置CFLAGS，所以之后就不用再设置了。并且，我们添加了-g标识来获取调试信息。接着我们写了一个叫做clean的部分，它告诉make如何清理我们的小项目。
确保它和你的ex1.c文件在相同的目录中，之后运行以下命令：
$ make clean $ make ex1 你会看到什么 link如果代码能正常工作，你应该看到这些：
$ make clean rm -f ex1 $ make ex1 cc -Wall -g ex1.</description>
    </item>
    
    <item>
      <title>练习3：格式化输出</title>
      <link>https://cuterwrite.top/TechDocs/docs/c-guide/ex3/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/c-guide/ex3/</guid>
      <description>原文：Exercise 3: Formatted Printing
译者：飞龙
不要删除Makefile，因为它可以帮你指出错误，以及当我们需要自动化处理一些事情时，可以向它添加新的东西。
许多编程语言都使用了C风格的格式化输出，所以让我们尝试一下：
#include &amp;lt;stdio.h&amp;gt; int main() { int age = 10; int height = 72; printf(&amp;#34;I am %d years old.\n&amp;#34;, age); printf(&amp;#34;I am %d inches tall.\n&amp;#34;, height); return 0; } 写完之后，执行通常的make ex3命令来构建并运行它。一定要确保你处理了所有的警告。
这个练习的代码量很小，但是信息量很大，所以让我们逐行分析一下：
首先你包含了另一个头文件叫做stdio.h。这告诉了编译器你要使用“标准的输入/输出函数”。它们之一就是printf。 然后你使用了一个叫age的变量并且将它设置为10。 接着你使用了一个叫height的变量并且设置为72。 再然后你使用printf函数来打印这个星球上最高的十岁的人的年龄和高度。 在printf中你会注意到你传入了一个字符串，这就是格式字符串，和其它语言中一样。 在格式字符串之后，你传入了一些变量，它们应该被printf“替换”进格式字符串中。 这些语句的结果就是你用printf处理了一些变量，并且它会构造出一个新的字符串，之后将它打印在终端上。
你会看到什么 link当你做完上面的整个步骤，你应该看到这些东西：
$ make ex3 cc -Wall -g ex3.c -o ex3 $ ./ex3 I am 10 years old. I am 72 inches tall. $ 不久之后我会停下来让你运行make，并且告诉你构建过程是什么样子的。所以请确保你正确得到了这些信息并且能正常执行。</description>
    </item>
    
    <item>
      <title>练习4：Valgrind 介绍</title>
      <link>https://cuterwrite.top/TechDocs/docs/c-guide/ex4/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/c-guide/ex4/</guid>
      <description>原文：Exercise 4: Introducing Valgrind
译者：飞龙
现在是介绍另一个工具的时间了，在你学习C的过程中，你会时时刻刻用到它，它就是 Valgrind。我现在就向你介绍 Valgrind，是因为从现在开始你将会在“如何使它崩溃”一节中用到它。Valgrind是一个运行你的程序的程序，并且随后会报告所有你犯下的可怕错误。它是一款相当棒的自由软件，我在编写C代码时一直使用它。
回忆一下在上一章中，我让你移除printf的一个参数，来使你的代码崩溃。它打印出了一些奇怪的结果，但我并没有告诉你为什么它会这样打印。这个练习中我们要使用Valgrind来搞清楚为什么。
注
这本书的前几章讲解了一小段代码，同时掺杂了一些必要的工具，它们在本书的剩余章节会用到。这样做的原因是，阅读这本书的大多数人都不熟悉编译语言，也必然不熟悉自动化的辅助工具。通过先让你懂得如何使用make和Valgrind，我可以在后面使用它们更快地教你C语言，以及帮助你尽早找出所有的bug。
这一章之后我就不再介绍更多的工具了，每章的内容大部分是代码，以及少量的语法。然而，我也会提及少量工具，我们可以用它来真正了解发生了什么，以及更好地了解常见的错误和问题。
安装 Valgrind link你可以用OS上的包管理器来安装Valgrind，但是我想让你学习如何从源码安装程序。这涉及到下面几个步骤：
下载源码的归档文件来获得源码 解压归档文件，将文件提取到你的电脑上 运行./configure来建立构建所需的配置 运行make来构建源码，就像之前所做的那样 运行sudo make install来将它安装到你的电脑 下面是执行以上步骤的脚本，我想让你复制它：
curl -O http://valgrind.org/downloads/valgrind-3.6.1.tar.bz2 md5sum valgrind-3.6.1.tar.bz2 tar -xjvf valgrind-3.6.1.tar.bz2 cd valgrind-3.6.1 ./configure make sudo make install 按照这份脚本，但是如果 Valgrind 有新的版本请更新它。如果它不能正常执行，也请试着深入研究原因。
使用 Valgrind link使用 Valgrind 十分简单，只要执行valgrind theprogram，它就会运行你的程序，随后打印出你的程序运行时出现的所有错误。在这个练习中，我们会崩溃在一个错误输出上，然后会修复它。
首先，这里有一个ex3.c的故意出错的版本，叫做ex4.c。出于练习目的，将它再次输入到文件中：
#include &amp;lt;stdio.h&amp;gt; /* Warning: This program is wrong on purpose. */ int main() { int age = 10; int height; printf(&amp;#34;I am %d years old.</description>
    </item>
    
    <item>
      <title>练习5：一个C程序的结构</title>
      <link>https://cuterwrite.top/TechDocs/docs/c-guide/ex5/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/c-guide/ex5/</guid>
      <description>原文：Exercise 5: The Structure Of A C Program
译者：飞龙
你已经知道了如何使用printf，也有了可以随意使用的一些工具，现在让我们逐行分析一个简单的C程序，以便你了解它是如何组织的。在这个程序里你会编写一些不是很熟悉的东西，我会轻松地把它们拆开。之后在后面的几章我们将会处理这些概念。
#include &amp;lt;stdio.h&amp;gt; /* This is a comment. */ int main(int argc, char *argv[]) { int distance = 100; // this is also a comment printf(&amp;#34;You are %d miles away.\n&amp;#34;, distance); return 0; } 手动输入这段代码并运行它，之后确保在Valgrind下不出现任何错误。你可能不会这样做，但你得习惯它。
你会看到什么 link这真是一段无聊的输出，但是这个练习的目的是让你分析代码：
$ make ex5 cc -Wall -g ex5.c -o ex5 $ ./ex5 You are 100 miles away. $ 分解代码 link当你输出这段代码时，可能你只弄清楚了这段代码中的一小部分C语言特性。让我们快速地逐行分解它，之后我们可以做一些练习来更好地了解每一部分：
ex5.c:1
这是一个include，它是将一个文件的内容导入到这个文件的方式。C具有使用.h扩展名作为头文件的惯例。头文件中拥有一些函数的列表，这些都是你想在程序中使用的函数。
ex5.c:3
这是多行注释，你可以在/*和*/之间放置任意多行。</description>
    </item>
    
    <item>
      <title>练习6：变量类型</title>
      <link>https://cuterwrite.top/TechDocs/docs/c-guide/ex6/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/c-guide/ex6/</guid>
      <description>原文：Exercise 6: Types Of Variables
译者：飞龙
你应该掌握了一个简单的C程序的结构，所以让我们执行下一步简单的操作，声明不同类型的变量。
include &amp;lt;stdio.h&amp;gt; int main(int argc, char *argv[]) { int distance = 100; float power = 2.345f; double super_power = 56789.4532; char initial = &amp;#39;A&amp;#39;; char first_name[] = &amp;#34;Zed&amp;#34;; char last_name[] = &amp;#34;Shaw&amp;#34;; printf(&amp;#34;You are %d miles away.\n&amp;#34;, distance); printf(&amp;#34;You have %f levels of power.\n&amp;#34;, power); printf(&amp;#34;You have %f awesome super powers.\n&amp;#34;, super_power); printf(&amp;#34;I have an initial %c.\n&amp;#34;, initial); printf(&amp;#34;I have a first name %s.</description>
    </item>
    
    <item>
      <title>练习7：更多变量和一些算术</title>
      <link>https://cuterwrite.top/TechDocs/docs/c-guide/ex7/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/c-guide/ex7/</guid>
      <description>原文：Exercise 7: More Variables, Some Math
译者：飞龙
你可以通过声明int，float，char和double类型的变量，来对它们做更多的事情，让我们来熟悉它们吧。接下来我们会在各种数学表达式中使用它们，所以我会向你介绍C的基本算术操作。
int main(int argc, char *argv[]) { int bugs = 100; double bug_rate = 1.2; printf(&amp;#34;You have %d bugs at the imaginary rate of %f.\n&amp;#34;, bugs, bug_rate); long universe_of_defects = 1L * 1024L * 1024L * 1024L; printf(&amp;#34;The entire universe has %ld bugs.\n&amp;#34;, universe_of_defects); double expected_bugs = bugs * bug_rate; printf(&amp;#34;You are expected to have %f bugs.\n&amp;#34;, expected_bugs); double part_of_universe = expected_bugs / universe_of_defects; printf(&amp;#34;That is only a %e portion of the universe.</description>
    </item>
    
    <item>
      <title>练习8：大小和数组</title>
      <link>https://cuterwrite.top/TechDocs/docs/c-guide/ex8/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/c-guide/ex8/</guid>
      <description>原文：Exercise 8: Sizes And Arrays
译者：飞龙
在上一个练习中你做了一些算术运算，并且使用了&#39;\0&#39;（空）字符。这对于其它语言来说非常奇怪，因为它们把“字符串”和“字节数组”看做不同的东西。但是C中的字符串就是字节数组，并且只有不同的打印函数才知道它们的不同。
在我真正解释其重要性之前，我先要介绍一些概念：sizeof和数组。下面是我们将要讨论的一段代码：
#include &amp;lt;stdio.h&amp;gt; int main(int argc, char *argv[]) { int areas[] = {10, 12, 13, 14, 20}; char name[] = &amp;#34;Zed&amp;#34;; char full_name[] = { &amp;#39;Z&amp;#39;, &amp;#39;e&amp;#39;, &amp;#39;d&amp;#39;, &amp;#39; &amp;#39;, &amp;#39;A&amp;#39;, &amp;#39;.&amp;#39;, &amp;#39; &amp;#39;, &amp;#39;S&amp;#39;, &amp;#39;h&amp;#39;, &amp;#39;a&amp;#39;, &amp;#39;w&amp;#39;, &amp;#39;\0&amp;#39; }; // WARNING: On some systems you may have to change the // %ld in this code to a %u since it will use unsigned ints printf(&amp;#34;The size of an int: %ld\n&amp;#34;, sizeof(int)); printf(&amp;#34;The size of areas (int[]): %ld\n&amp;#34;, sizeof(areas)); printf(&amp;#34;The number of ints in areas: %ld\n&amp;#34;, sizeof(areas) / sizeof(int)); printf(&amp;#34;The first area is %d, the 2nd %d.</description>
    </item>
    
    <item>
      <title>练习9：数组和字符串</title>
      <link>https://cuterwrite.top/TechDocs/docs/c-guide/ex9/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/c-guide/ex9/</guid>
      <description>原文：Exercise 9: Arrays And Strings
译者：飞龙
上一个练习中，我们学习了如何创建基本的数组，以及数组如何映射为字符串。这个练习中我们会更加全面地展示数组和字符串的相似之处，并且深入了解更多内存布局的知识。
这个练习向你展示了C只是简单地将字符串储存为字符数组，并且在结尾加上&#39;\0&#39;（空字符）。你可能在上个练习中得到了暗示，因为我们手动这样做了。下面我会通过将它与数字数组比较，用另一种方法更清楚地实现它。
#include &amp;lt;stdio.h&amp;gt; int main(int argc, char *argv[]) { int numbers[4] = {0}; char name[4] = {&amp;#39;a&amp;#39;}; // first, print them out raw printf(&amp;#34;numbers: %d %d %d %d\n&amp;#34;, numbers[0], numbers[1], numbers[2], numbers[3]); printf(&amp;#34;name each: %c %c %c %c\n&amp;#34;, name[0], name[1], name[2], name[3]); printf(&amp;#34;name: %s\n&amp;#34;, name); // setup the numbers numbers[0] = 1; numbers[1] = 2; numbers[2] = 3; numbers[3] = 4; // setup the name name[0] = &amp;#39;Z&amp;#39;; name[1] = &amp;#39;e&amp;#39;; name[2] = &amp;#39;d&amp;#39;; name[3] = &amp;#39;\0&amp;#39;; // then print them out initialized printf(&amp;#34;numbers: %d %d %d %d\n&amp;#34;, numbers[0], numbers[1], numbers[2], numbers[3]); printf(&amp;#34;name each: %c %c %c %c\n&amp;#34;, name[0], name[1], name[2], name[3]); // print the name like a string printf(&amp;#34;name: %s\n&amp;#34;, name); // another way to use name char *another = &amp;#34;Zed&amp;#34;; printf(&amp;#34;another: %s\n&amp;#34;, another); printf(&amp;#34;another each: %c %c %c %c\n&amp;#34;, another[0], another[1], another[2], another[3]); return 0; } 在这段代码中，我们创建了一些数组，并对数组元素赋值。在numbers中我们设置了一些数字，然而在names中我们实际上手动构造了一个字符串。</description>
    </item>
    
    <item>
      <title>练习10：字符串数组和循环</title>
      <link>https://cuterwrite.top/TechDocs/docs/c-guide/ex10/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/c-guide/ex10/</guid>
      <description>原文：Exercise 10: Arrays Of Strings, Looping
译者：飞龙
你现在可以创建不同类型的数组，并且也知道了“字符串”和“字节数组”是相同的东西。接下来，我们要更进一步，创建一个包含字符串的数组。我也会介绍第一个循环结构，for循环来帮我们打印出这一新的数据结构。
这一章的有趣之处就是你的程序中已经有一个现成的字符串数组，main函数参数中的char *argv[]。下面这段代码打印出了所有你传入的命令行参数：
#include &amp;lt;stdio.h&amp;gt; int main(int argc, char *argv[]) { int i = 0; // go through each string in argv // why am I skipping argv[0]? for(i = 1; i &amp;lt; argc; i&amp;#43;&amp;#43;) { printf(&amp;#34;arg %d: %s\n&amp;#34;, i, argv[i]); } // let&amp;#39;s make our own array of strings char *states[] = { &amp;#34;California&amp;#34;, &amp;#34;Oregon&amp;#34;, &amp;#34;Washington&amp;#34;, &amp;#34;Texas&amp;#34; }; int num_states = 4; for(i = 0; i &amp;lt; num_states; i&amp;#43;&amp;#43;) { printf(&amp;#34;state %d: %s\n&amp;#34;, i, states[i]); } return 0; } for循环的格式是这样的：</description>
    </item>
    
    <item>
      <title>练习11：While循环和布尔表达式</title>
      <link>https://cuterwrite.top/TechDocs/docs/c-guide/ex11/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/c-guide/ex11/</guid>
      <description>原文：Exercise 11: While-Loop And Boolean Expressions
译者：飞龙
你已经初步了解C语言如何处理循环，但是你可能不是很清楚布尔表达式i &amp;lt; argc是什么。在学习while循环之前，让我先来对布尔表达式做一些解释。
在C语言中，实际上没有真正的“布尔”类型，而是用一个整数来代替，0代表false，其它值代表true。上一个练习中表达式i &amp;lt; argc实际上值为1或者0，并不像Python是显式的Ture或者False。这是C语言更接近计算机工作方式的另一个例子，因为计算机只把值当成数字。
现在用while循环来实现和上一个练习相同的函数。这会让你使用两种循环，来观察两种循环是什么关系。
#include &amp;lt;stdio.h&amp;gt; int main(int argc, char *argv[]) { // go through each string in argv int i = 0; while(i &amp;lt; argc) { printf(&amp;#34;arg %d: %s\n&amp;#34;, i, argv[i]); i&amp;#43;&amp;#43;; } // let&amp;#39;s make our own array of strings char *states[] = { &amp;#34;California&amp;#34;, &amp;#34;Oregon&amp;#34;, &amp;#34;Washington&amp;#34;, &amp;#34;Texas&amp;#34; }; int num_states = 4; i = 0; // watch for this while(i &amp;lt; num_states) { printf(&amp;#34;state %d: %s\n&amp;#34;, i, states[i]); i&amp;#43;&amp;#43;; } return 0; } 你可以看到while循环的语法更加简单：</description>
    </item>
    
    <item>
      <title>练习12：If，Else If，Else</title>
      <link>https://cuterwrite.top/TechDocs/docs/c-guide/ex12/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/c-guide/ex12/</guid>
      <description>原文：Exercise 12: If, Else-If, Else
译者：飞龙
if语句是每个编程语言中共有的特性，包括C语言。下面是一段代码，使用了if语句来确保只传入了一个或两个命令行参数：
#include &amp;lt;stdio.h&amp;gt; int main(int argc, char *argv[]) { int i = 0; if(argc == 1) { printf(&amp;#34;You only have one argument. You suck.\n&amp;#34;); } else if(argc &amp;gt; 1 &amp;amp;&amp;amp; argc &amp;lt; 4) { printf(&amp;#34;Here&amp;#39;s your arguments:\n&amp;#34;); for(i = 0; i &amp;lt; argc; i&amp;#43;&amp;#43;) { printf(&amp;#34;%s &amp;#34;, argv[i]); } printf(&amp;#34;\n&amp;#34;); } else { printf(&amp;#34;You have too many arguments. You suck.\n&amp;#34;); } return 0; } if语句的格式为：</description>
    </item>
    
    <item>
      <title>练习13：Switch语句</title>
      <link>https://cuterwrite.top/TechDocs/docs/c-guide/ex13/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/c-guide/ex13/</guid>
      <description>原文：Exercise 13: Switch Statement
译者：飞龙
在其它类似Ruby的语言中，switch语句可以处理任意类型的表达式。一些语言比如Python没有switch语句，因为带有布尔表达式的if语句可以做相同的事情。对于这些语言，switch语句比if语句更加灵活，然而内部的机制是一样的。
C中的switch语句与它们不同，实际上是一个“跳转表”。你只能够放置结果为整数的表达式，而不是一些随机的布尔表达式，这些整数用于计算从swicth顶部到匹配部分的跳转。下面有一段代码，我要分解它来让你理解“跳转表”的概念：
#include &amp;lt;stdio.h&amp;gt; int main(int argc, char *argv[]) { if(argc != 2) { printf(&amp;#34;ERROR: You need one argument.\n&amp;#34;); // this is how you abort a program return 1; } int i = 0; for(i = 0; argv[1][i] != &amp;#39;\0&amp;#39;; i&amp;#43;&amp;#43;) { char letter = argv[1][i]; switch(letter) { case &amp;#39;a&amp;#39;: case &amp;#39;A&amp;#39;: printf(&amp;#34;%d: &amp;#39;A&amp;#39;\n&amp;#34;, i); break; case &amp;#39;e&amp;#39;: case &amp;#39;E&amp;#39;: printf(&amp;#34;%d: &amp;#39;E&amp;#39;\n&amp;#34;, i); break; case &amp;#39;i&amp;#39;: case &amp;#39;I&amp;#39;: printf(&amp;#34;%d: &amp;#39;I&amp;#39;\n&amp;#34;, i); break; case &amp;#39;o&amp;#39;: case &amp;#39;O&amp;#39;: printf(&amp;#34;%d: &amp;#39;O&amp;#39;\n&amp;#34;, i); break; case &amp;#39;u&amp;#39;: case &amp;#39;U&amp;#39;: printf(&amp;#34;%d: &amp;#39;U&amp;#39;\n&amp;#34;, i); break; case &amp;#39;y&amp;#39;: case &amp;#39;Y&amp;#39;: if(i &amp;gt; 2) { // it&amp;#39;s only sometimes Y printf(&amp;#34;%d: &amp;#39;Y&amp;#39;\n&amp;#34;, i); } break; default: printf(&amp;#34;%d: %c is not a vowel\n&amp;#34;, i, letter); } } return 0; } 在这个程序中我们接受了单一的命令行参数，并且用一种极其复杂的方式打印出所有原因，来向你演示switch语句。下面是swicth语句的工作原理：</description>
    </item>
    
    <item>
      <title>练习14：编写并使用函数</title>
      <link>https://cuterwrite.top/TechDocs/docs/c-guide/ex14/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/c-guide/ex14/</guid>
      <description>原文：Exercise 14: Writing And Using Functions
译者：飞龙
到现在为止，你只使用了作为stdio.h头文件一部分的函数。在这个练习中你将要编写并使用自己的函数。
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;ctype.h&amp;gt; // forward declarations int can_print_it(char ch); void print_letters(char arg[]); void print_arguments(int argc, char *argv[]) { int i = 0; for(i = 0; i &amp;lt; argc; i&amp;#43;&amp;#43;) { print_letters(argv[i]); } } void print_letters(char arg[]) { int i = 0; for(i = 0; arg[i] != &amp;#39;\0&amp;#39;; i&amp;#43;&amp;#43;) { char ch = arg[i]; if(can_print_it(ch)) { printf(&amp;#34;&amp;#39;%c&amp;#39; == %d &amp;#34;, ch, ch); } } printf(&amp;#34;\n&amp;#34;); } int can_print_it(char ch) { return isalpha(ch) || isblank(ch); } int main(int argc, char *argv[]) { print_arguments(argc, argv); return 0; } 在这个例子中你创建了函数来打印任何属于“字母”和“空白”的字符。下面是一个分解：</description>
    </item>
    
    <item>
      <title>练习15：指针，可怕的指针</title>
      <link>https://cuterwrite.top/TechDocs/docs/c-guide/ex15/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/c-guide/ex15/</guid>
      <description>原文：Exercise 15: Pointers Dreaded Pointers
译者：飞龙
指针是C中的一个著名的谜之特性，我会试着通过教授你一些用于处理它们的词汇，使之去神秘化。指针实际上并不复杂，只不过它们经常以一些奇怪的方式被滥用，这样使它们变得难以使用。如果你避免这些愚蠢的方法来使用指针，你会发现它们难以置信的简单。
要想以一种我们可以谈论的方式来讲解指针，我会编写一个无意义的程序，它以三种方式打印了一组人的年龄：
#include &amp;lt;stdio.h&amp;gt; int main(int argc, char *argv[]) { // create two arrays we care about int ages[] = {23, 43, 12, 89, 2}; char *names[] = { &amp;#34;Alan&amp;#34;, &amp;#34;Frank&amp;#34;, &amp;#34;Mary&amp;#34;, &amp;#34;John&amp;#34;, &amp;#34;Lisa&amp;#34; }; // safely get the size of ages int count = sizeof(ages) / sizeof(int); int i = 0; // first way using indexing for(i = 0; i &amp;lt; count; i&amp;#43;&amp;#43;) { printf(&amp;#34;%s has %d years alive.</description>
    </item>
    
    <item>
      <title>练习16：结构体和指向它们的指针</title>
      <link>https://cuterwrite.top/TechDocs/docs/c-guide/ex16/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/c-guide/ex16/</guid>
      <description>原文：Exercise 16: Structs And Pointers To Them
译者：飞龙
在这个练习中你将会学到如何创建struct，将一个指针指向它们，以及使用它们来理解内存的内部结构。我也会借助上一节课中的指针知识，并且让你使用malloc从原始内存中构造这些结构体。
像往常一样，下面是我们将要讨论的程序，你应该把它打下来并且使它正常工作：
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;assert.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;string.h&amp;gt; struct Person { char *name; int age; int height; int weight; }; struct Person *Person_create(char *name, int age, int height, int weight) { struct Person *who = malloc(sizeof(struct Person)); assert(who != NULL); who-&amp;gt;name = strdup(name); who-&amp;gt;age = age; who-&amp;gt;height = height; who-&amp;gt;weight = weight; return who; } void Person_destroy(struct Person *who) { assert(who !</description>
    </item>
    
    <item>
      <title>练习17：堆和栈的内存分配</title>
      <link>https://cuterwrite.top/TechDocs/docs/c-guide/ex17/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/c-guide/ex17/</guid>
      <description>原文：Exercise 17: Heap And Stack Memory Allocation
译者：飞龙
在这个练习中，你会在难度上做一个大的跳跃，并且创建出用于管理数据库的完整的小型系统。这个数据库并不实用也存储不了太多东西，然而它展示了大多数到目前为止你学到的东西。它也以更加正规的方法介绍了内存分配，以及带领你熟悉文件处理。我们使用了一些文件IO函数，但是我并不想过多解释它们，你可以先试着自己理解。
像通常一样，输入下面整个程序，并且使之正常工作，之后我们会进行讨论：
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;assert.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;errno.h&amp;gt; #include &amp;lt;string.h&amp;gt; #define MAX_DATA 512 #define MAX_ROWS 100 struct Address { int id; int set; char name[MAX_DATA]; char email[MAX_DATA]; }; struct Database { struct Address rows[MAX_ROWS]; }; struct Connection { FILE *file; struct Database *db; }; void die(const char *message) { if(errno) { perror(message); } else { printf(&amp;#34;ERROR: %s\n&amp;#34;, message); } exit(1); } void Address_print(struct Address *addr) { printf(&amp;#34;%d %s %s\n&amp;#34;, addr-&amp;gt;id, addr-&amp;gt;name, addr-&amp;gt;email); } void Database_load(struct Connection *conn) { int rc = fread(conn-&amp;gt;db, sizeof(struct Database), 1, conn-&amp;gt;file); if(rc !</description>
    </item>
    
    <item>
      <title>练习18：函数指针</title>
      <link>https://cuterwrite.top/TechDocs/docs/c-guide/ex18/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/c-guide/ex18/</guid>
      <description>原文：Exercise 18: Pointers To Functions
译者：飞龙
函数在C中实际上只是指向程序中某一个代码存在位置的指针。就像你创建过的结构体指针、字符串和数组那样，你也可以创建指向函数的指针。函数指针的主要用途是向其他函数传递“回调”，或者模拟类和对象。在这个练习中我们会创建一些回调，并且下一节我们会制作一个简单的对象系统。
函数指针的格式类似这样：
int (*POINTER_NAME)(int a, int b) 记住如何编写它的一个方法是：
编写一个普通的函数声明：int callme(int a, int b) 将函数用指针语法包装：int (*callme)(int a, int b) 将名称改成指针名称：int (*compare_cb)(int a, int b) 这个方法的关键是，当你完成这些之后，指针的变量名称为compare_cb，而你可以将它用作函数。这类似于指向数组的指针可以表示所指向的数组。指向函数的指针也可以用作表示所指向的函数，只不过是不同的名字。
int (*tester)(int a, int b) = sorted_order; printf(&amp;#34;TEST: %d is same as %d\n&amp;#34;, tester(2, 3), sorted_order(2, 3)); 即使是对于返回指针的函数指针，上述方法依然有效：
编写：char *make_coolness(int awesome_levels) 包装：char *(*make_coolness)(int awesome_levels) 重命名：char *(*coolness_cb)(int awesome_levels) 需要解决的下一个问题是使用函数指针向其它函数提供参数比较困难，比如当你打算向其它函数传递回调函数的时候。解决方法是使用typedef，它是C的一个关键字，可以给其它更复杂的类型起个新的名字。你需要记住的事情是，将typedef添加到相同的指针语法之前，然后你就可以将那个名字用作类型了。我使用下面的代码来演示这一特性：
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;errno.h&amp;gt; #include &amp;lt;string.h&amp;gt; /** Our old friend die from ex17.</description>
    </item>
    
    <item>
      <title>练习19：一个简单的对象系统</title>
      <link>https://cuterwrite.top/TechDocs/docs/c-guide/ex19/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/c-guide/ex19/</guid>
      <description>原文：Exercise 19: A Simple Object System
译者：飞龙
我在学习面向对象编程之前学了C，所以它有助于我在C中构建面向对象系统，来理解OOP的基本含义。你可能在学习C之前就学了OOP语言，所以这章也可能会起到一种衔接作用。这个联系中，你将会构建一个简单的对象系统，但是也会了解更多关于C预处理器的事情。
这个练习会构建一个简单的游戏，在游戏中你会在一个小型的城堡中杀死弥诺陶洛斯，并没有任何神奇之处，只是四个房间和一个坏家伙。这个练习同时是一个多文件的项目，并且比起之前的一些程序看起来更像一个真正的C程序。我在这里介绍C预处理器的原因，是你需要它来在你自己的程序中创建多个文件。
C预处理器如何工作 linkC预处理器是个模板处理系统，它主要的用途是让C代码的编程更加容易，但是它通过一个语法感知的模板机制来实现。以前人们主要使用C预处理器来储存常量，以及创建“宏”来简化复杂的代码。在现代C语言中你会实际上使用它作为代码生成器来创建模板化的代码片段。
C预处理器的工作原理是，如果你给它一个文件，比如.c文件，它会处理以#（井号）字符开头的各种文本。当它遇到一个这样的文本时，它会对输入文件中的文本做特定的替换。C预处理器的主要优点是他可以包含其他文件，并且基于该文件的内容对它的宏列表进行扩展。
一个快速查看预处理器所做事情的方法，是对上个练习中的代码执行下列命令：
cpp ex18.c | less 这会产生大量输出，但是如果你滚动它，会看到你使用#include包含的其他文件的内容。在原始的代码中向下滚动，你可以看到cpp如何基于头文件中不同的#define宏来转换代码。
C编译器与cpp的集成十分紧密，这个例子只是向你展示它是如何在背后工作的。在现代C语言中，cpp系统也集成到C的函数中，你或许可以将它当做C语言的一部分。
在剩余的章节中，我们会使用更多预处理器的语法，并且像往常一样解释它们。
原型对象系统 link我们所创建的OOP系统是一个简单的“原型”风格的对象系统，很像JavaScript。你将以设置为字段的原型来开始，而不是类，接着将他们用作创建其它对象实例的基础。这个“没有类”的设计比起传统的基于类的对象系统更加易于实现和使用。
Object头文件 link我打算将数据类型和函数声明放在一个单独的头文件中，叫做object.h。这个是一个标准的C技巧，可以让你集成二进制库，但其它程序员任然需要编译。在这个文件中，我使用了多个高级的C预处理器技巧，我接下来准备简略地描述它们，并且你会在后续的步骤中看到。
#ifndef _object_h #define _object_h typedef enum { NORTH, SOUTH, EAST, WEST } Direction; typedef struct { char *description; int (*init)(void *self); void (*describe)(void *self); void (*destroy)(void *self); void *(*move)(void *self, Direction direction); int (*attack)(void *self, int damage); } Object; int Object_init(void *self); void Object_destroy(void *self); void Object_describe(void *self); void *Object_move(void *self, Direction direction); int Object_attack(void *self, int damage); void *Object_new(size_t size, Object proto, char *description); #define NEW(T, N) Object_new(sizeof(T), T##Proto, N) #define _(N) proto.</description>
    </item>
    
    <item>
      <title>练习20：Zed的强大的调试宏</title>
      <link>https://cuterwrite.top/TechDocs/docs/c-guide/ex20/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/c-guide/ex20/</guid>
      <description>原文：Exercise 20: Zed&amp;rsquo;s Awesome Debug Macros
译者：飞龙
在C中有一个永恒的问题，它伴随了你很长时间，然而在这个练习我打算使用一系列我开发的宏来解决它。到现在为止你都不知道它们的强大之处，所以你必须使用它们，总有一天你会来找我说，“Zed，这些调试宏真是太伟大了，我应该把我的第一个孩子的出生归功于你，因为你治好了我十年的心脏病，并且打消了我数次想要自杀的念头。真是要谢谢你这样一个好人，这里有一百万美元，和Leo Fender设计的Snakehead Telecaster电吉他的原型。”
是的，它们的确很强大。
C的错误处理问题 link几乎每个编程语言中，错误处理都非常难。有些语言尽可能试图避免错误这个概念，而另一些语言发明了复杂了控制结构，比如异常来传递错误状态。当然的错误大多是因为程序员假定错误不会发生，并且这一乐观的思想影响了他们所用和所创造的语言。
C通过返回错误码或设置全局的errno值来解决这些问题，并且你需要检查这些值。这种机制可以检查现存的复杂代码中，你执行的东西是否发生错误。当你编写更多的C代码时，你应该按照下列模式：
调用函数。 如果返回值出现错误（每次都必须检查）。 清理创建的所有资源。 打印出所有可能有帮助的错误信息。 这意味着对于每一个函数调用（是的，每个函数）你都可能需要多编写3~4行代码来确保它正常功能。这些还不包括清理你到目前创建的所有垃圾。如果你有10个不同的结构体，3个方式。和一个数据库链接，当你发现错误时你应该写额外的14行。
之前这并不是个问题，因为发生错误时，C程序会像你以前做的那样直接退出。你不需要清理任何东西，因为OS会为你自动去做。然而现在很多C程序需要持续运行数周、数月或者数年，并且需要优雅地处理来自于多种资源的错误。你并不能仅仅让你的服务器在首次运行就退出，你也不能让你写的库使使用它的程序退出。这非常糟糕。
其它语言通过异常来解决这个问题，但是这些问题也会在C中出现（其它语言也一样）。在C中你只能够返回一个值，但是异常是基于栈的返回系统，可以返回任意值。C语言中，尝试在栈上模拟异常非常困难，并且其它库也不会兼容。
调试宏 link我使用的解决方案是，使用一系列“调试宏”，它们在C中实现了基本的调试和错误处理系统。这个系统非常易于理解，兼容于每个库，并且使C代码更加健壮和简洁。
它通过实现一系列转换来处理错误，任何时候发生了错误，你的函数都会跳到执行清理和返回错误代码的“error:”区域。你可以使用check宏来检查错误代码，打印错误信息，然后跳到清理区域。你也可以使用一系列日志函数来打印出有用的调试信息。
我现在会向你展示你目前所见过的，最强大且卓越的代码的全部内容。
#ifndef __dbg_h__ #define __dbg_h__ #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;errno.h&amp;gt; #include &amp;lt;string.h&amp;gt; #ifdef NDEBUG #define debug(M, ...) #else #define debug(M, ...) fprintf(stderr, &amp;#34;DEBUG %s:%d: &amp;#34; M &amp;#34;\n&amp;#34;, __FILE__, __LINE__, ##__VA_ARGS__) #endif #define clean_errno() (errno == 0 ? &amp;#34;None&amp;#34; : strerror(errno)) #define log_err(M, ...) fprintf(stderr, &amp;#34;[ERROR] (%s:%d: errno: %s) &amp;#34; M &amp;#34;\n&amp;#34;, __FILE__, __LINE__, clean_errno(), ##__VA_ARGS__) #define log_warn(M, .</description>
    </item>
    
    <item>
      <title>练习21：高级数据类型和控制结构</title>
      <link>https://cuterwrite.top/TechDocs/docs/c-guide/ex21/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/c-guide/ex21/</guid>
      <description>原文：Exercise 21: Advanced Data Types And Flow Control
译者：飞龙
这个练习是C语言中所有可用的数据类型和控制结构的摘要。它也可以作为一份参考在补完你的知识，并且不含有任何代码。我会通过创建教学卡片的方式，让你记住一些信息，所以你会在脑子里记住所有重要的概念。
这个练习非常有用，你应该花至少一周的时间来巩固内容并且补全这里所没有的元素。你应学出每个元素是什么意思，以及编写程序来验证你得出的结论。
可用的数据类型 linkint
储存普通的整数，默认为32位大小。
译者注：int在32或64位环境下为32位，但它不应该被看作平台无关的。如果需要用到平台无关的定长整数，请使用int(n)_t。
double
储存稍大的浮点数。
float
储存稍小的浮点数。
char
储存单字节字符。
void
表示“无类型”，用于声明不返回任何东西的函数，或者所指类型不明的指针，例如void *thing。
enum
枚举类型，类似于整数，也可转换为整数，但是通过符号化的名称访问或设置。当switch语句中没有覆盖到所有枚举的元素时，一些编译器会发出警告。
类型修饰符 linkunsigned
修改类型，使它不包含任何负数，同时上界变高。
signed
可以储存正数和负数，但是上界会变为（大约）一半，下界变为和上界（大约）等长。
译者注：符号修饰符只对char和*** int有效。*** int默认为signed，而char根据具体实现，可以默认为signed，也可以为unsigned。
long
对该类型使用较大的空间，使它能存下更大的数，通常使当前大小加倍。
short
对该类型使用较小的空间，使它储存能力变小，但是占据空间也变成一半。
类型限定符 linkconst
表示变量在初始化后不能改变。
volatile
表示会做最坏的打算，编译器不会对它做任何优化。通常仅在对变量做一些奇怪的事情时，才会用到它。
register
强制让编译器将这个变量保存在寄存器中，并且也可以无视它。目前的编译器更善于处理在哪里存放变量，所以应该只在确定这样会提升性能时使用它。
类型转换 linkC使用了一种“阶梯形类型提升”的机制，它会观察运算符两边的变量，并且在运算之前将较小边的变量转换为较大边。这个过程按照如下顺序：
long double double float long long long int (short, char) 译者注：short和char会在运算之前转换成int。同种类型的unsigned和signed运算，signed保持字节不变转换成unsigned。
类型大小 linkstdint.h为定长的整数类型定义了一些typedef，同时也有一些用于这些类型的宏。这比老的limits.h更加易于使用，因为它是不变的。这些类型如下：
int8_t
8位符号整数。
uint8_t
8位无符号整数。
int16_t
16位符号整数。
uint16_t
16位无符号整数。
int32_t</description>
    </item>
    
    <item>
      <title>练习22：栈、作用域和全局</title>
      <link>https://cuterwrite.top/TechDocs/docs/c-guide/ex22/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/c-guide/ex22/</guid>
      <description>原文：Exercise 22: The Stack, Scope, And Globals
译者：飞龙
许多人在开始编程时，对“作用域”这个概念都不是很清楚。起初它来源于系统栈的使用方式（在之前提到过一些），以及它用于临时变量储存的方式。这个练习中，我们会通过学习栈数据结构如何工作来了解作用域，然后再来看看现代C语言处理作用域的方式。
这个练习的真正目的是了解一些比较麻烦的东西在C中如何存储。当一个人没有掌握作用域的概念时，它几乎也不能理解变量在哪里被创建，存在以及销毁。一旦你知道了这些，作用域的概念会变得易于理解。
这个练习需要如下三个文件：
ex22.h
用于创建一些外部变量和一些函数的头文件。
ex22.c
它并不像通常一样，是包含main的源文件，而是含有一些ex22.h中声明的函数和变量，并且会变成ex22.o。
ex22_main.c
main函数实际所在的文件，它会包含另外两个文件，并演示了它们包含的东西以及其它作用域概念。
ex22.h 和 ex22.c link你的第一步是创建你自己的ex22.h头文件，其中定义了所需的函数和“导出”变量。
#ifndef _ex22_h #define _ex22_h // makes THE_SIZE in ex22.c available to other .c files extern int THE_SIZE; // gets and sets an internal static variable in ex22.c int get_age(); void set_age(int age); // updates a static variable that&amp;#39;s inside update_ratio double update_ratio(double ratio); void print_size(); #endif 最重要的事情是extern int THE_SIZE的用法，我将会在你创建完ex22.</description>
    </item>
    
    <item>
      <title>练习23：认识达夫设备</title>
      <link>https://cuterwrite.top/TechDocs/docs/c-guide/ex23/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/c-guide/ex23/</guid>
      <description>原文：Exercise 23: Meet Duff&amp;rsquo;s Device
译者：飞龙
这个练习是一个脑筋急转弯，我会向你介绍最著名的C语言黑魔法之一，叫做“达夫设备”，以“发明者”汤姆·达夫的名字命名。这一强大（或邪恶？）的代码中，几乎你学过的任何东西都被包装在一个小的结构中。弄清它的工作机制也是一个好玩的谜题。
注
C的一部分乐趣来源于这种神奇的黑魔法，但这也是使C难以使用的地方。你最好能够了解这些技巧，因为他会带给你关于C语言和你计算机的深入理解。但是，你应该永远都不要使用它们，并总是追求简单易读的代码。
达夫设备由汤姆·达夫“发现”（或创造），它是一个C编译器的小技巧，本来不应该能够正常工作。我并不想告诉你做了什么，因为这是一个谜题，等着你来思考并尝试解决。你需要运行这段代码，之后尝试弄清它做了什么，以及为什么可以这样做。
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;#34;dbg.h&amp;#34; int normal_copy(char *from, char *to, int count) { int i = 0; for(i = 0; i &amp;lt; count; i&amp;#43;&amp;#43;) { to[i] = from[i]; } return i; } int duffs_device(char *from, char *to, int count) { { int n = (count &amp;#43; 7) / 8; switch(count % 8) { case 0: do { *to&amp;#43;&amp;#43; = *from&amp;#43;&amp;#43;; case 7: *to&amp;#43;&amp;#43; = *from&amp;#43;&amp;#43;; case 6: *to&amp;#43;&amp;#43; = *from&amp;#43;&amp;#43;; case 5: *to&amp;#43;&amp;#43; = *from&amp;#43;&amp;#43;; case 4: *to&amp;#43;&amp;#43; = *from&amp;#43;&amp;#43;; case 3: *to&amp;#43;&amp;#43; = *from&amp;#43;&amp;#43;; case 2: *to&amp;#43;&amp;#43; = *from&amp;#43;&amp;#43;; case 1: *to&amp;#43;&amp;#43; = *from&amp;#43;&amp;#43;; } while(--n &amp;gt; 0); } } return count; } int zeds_device(char *from, char *to, int count) { { int n = (count &amp;#43; 7) / 8; switch(count % 8) { case 0: again: *to&amp;#43;&amp;#43; = *from&amp;#43;&amp;#43;; case 7: *to&amp;#43;&amp;#43; = *from&amp;#43;&amp;#43;; case 6: *to&amp;#43;&amp;#43; = *from&amp;#43;&amp;#43;; case 5: *to&amp;#43;&amp;#43; = *from&amp;#43;&amp;#43;; case 4: *to&amp;#43;&amp;#43; = *from&amp;#43;&amp;#43;; case 3: *to&amp;#43;&amp;#43; = *from&amp;#43;&amp;#43;; case 2: *to&amp;#43;&amp;#43; = *from&amp;#43;&amp;#43;; case 1: *to&amp;#43;&amp;#43; = *from&amp;#43;&amp;#43;; if(--n &amp;gt; 0) goto again; } } return count; } int valid_copy(char *data, int count, char expects) { int i = 0; for(i = 0; i &amp;lt; count; i&amp;#43;&amp;#43;) { if(data[i] !</description>
    </item>
    
    <item>
      <title>练习24：输入输出和文件</title>
      <link>https://cuterwrite.top/TechDocs/docs/c-guide/ex24/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/c-guide/ex24/</guid>
      <description>原文：Exercise 24: Input, Output, Files
译者：飞龙
你已经学会了使用printf来打印变量，这非常不错，但是还需要学习更多。这个练习中你会用到fscanf和fgets在结构体中构建关于一个人的信息。在这个关于读取输入的简介之后，你会得到C语言IO函数的完整列表。其中一些你已经见过并且使用过了，所以这个练习也是一个记忆练习。
#include &amp;lt;stdio.h&amp;gt; #include &amp;#34;dbg.h&amp;#34; #define MAX_DATA 100 typedef enum EyeColor { BLUE_EYES, GREEN_EYES, BROWN_EYES, BLACK_EYES, OTHER_EYES } EyeColor; const char *EYE_COLOR_NAMES[] = { &amp;#34;Blue&amp;#34;, &amp;#34;Green&amp;#34;, &amp;#34;Brown&amp;#34;, &amp;#34;Black&amp;#34;, &amp;#34;Other&amp;#34; }; typedef struct Person { int age; char first_name[MAX_DATA]; char last_name[MAX_DATA]; EyeColor eyes; float income; } Person; int main(int argc, char *argv[]) { Person you = {.age = 0}; int i = 0; char *in = NULL; printf(&amp;#34;What&amp;#39;s your First Name?</description>
    </item>
    
    <item>
      <title>练习25：变参函数</title>
      <link>https://cuterwrite.top/TechDocs/docs/c-guide/ex25/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/c-guide/ex25/</guid>
      <description>原文：Exercise 25: Variable Argument Functions
译者：飞龙
在C语言中，你可以通过创建“变参函数”来创建你自己的printf或者scanf版本。这些函数使用stdarg.h头，它们可以让你为你的库创建更加便利的接口。它们对于创建特定类型的“构建”函数、格式化函数和任何用到可变参数的函数都非常实用。
理解“变参函数”对于C语言编程并不必要，我在编程生涯中也只有大约20次用到它。但是，理解变参函数如何工作有助于你对它的调试，并且让你更加了解计算机。
/** WARNING: This code is fresh and potentially isn&amp;#39;t correct yet. */ #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdarg.h&amp;gt; #include &amp;#34;dbg.h&amp;#34; #define MAX_DATA 100 int read_string(char **out_string, int max_buffer) { *out_string = calloc(1, max_buffer &amp;#43; 1); check_mem(*out_string); char *result = fgets(*out_string, max_buffer, stdin); check(result != NULL, &amp;#34;Input error.&amp;#34;); return 0; error: if(*out_string) free(*out_string); *out_string = NULL; return -1; } int read_int(int *out_int) { char *input = NULL; int rc = read_string(&amp;amp;input, MAX_DATA); check(rc == 0, &amp;#34;Failed to read number.</description>
    </item>
    
    <item>
      <title>练习26：编写第一个真正的程序</title>
      <link>https://cuterwrite.top/TechDocs/docs/c-guide/ex26/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/c-guide/ex26/</guid>
      <description>原文：Exercise 26: Write A First Real Program
译者：飞龙
这本书你已经完成一半了，所以你需要做一个期中检测。期中检测中你需要重新构建一个我特地为本书编写的软件，叫做devpkg。随后你需要以一些方式扩展它，并且通过编写一些单元测试来改进代码。
注
我在一些你需要完成的练习之前编写了这个练习。如果你现在尝试这个练习，记住软件可能会含有一些bug，你可能由于我的错误会产生一些问题，也可能不知道需要什么来完成它。如果这样的话，通过help@learncodethehardway.org来告诉我，之后等待我写完其它练习。
什么是devpkg？ linkdevpkg是一个简单的C程序，可以用于安装其它软件。我特地为本书编写了它，作为一种方式来教你真正的软件是如何构建的，以及如何复用他人的库。它使用了一个叫做Apache可移植运行时（APR）的库，其中含有许多工作跨平台的便利的C函数，包括Windows。此外，它只是从互联网（或本地文件）抓取代码，并且执行通常的./configure ; make ; make install命令，每个程序员都用到过。
这个练习中，你的目标是从源码构建devpkg，完成我提供的每个挑战，并且使用源码来理解devpkg做了什么和为什么这样做。
我们打算创建什么 link我们打算创建一个具有三个命令的工具：
devpkg -S
在电脑上安装新的软件。
devpkg -I
从URL安装软件。
devpkg -L
列出安装的所有软件。
devpkg -F
为手动构建抓取源代码。
devpkg -B
构建所抓取的源码代码并且安装它，即使它已经安装了。
我们想让devpkg能够接受几乎任何URL，判断项目的类型，下载，安装，以及注册已经安装的软件。我们也希望它能够处理一个简单的依赖列表，以便它能够安装项目所需的所有软件。
设计 link为了完成这一目标，devpkg具有非常简单的设计：
使用外部命令
大多数工作都是通过类似于curl、git和tar的外部命令完成的。这样减少了devpkg所需的代码量。
简单的文件数据库
你可以轻易使它变得很复杂，但是一开始你需要完成一个简单的文件数据库，位于/usr/local/.devpkg/db，来跟踪已安装的软件。
/usr/local
同样你可以使它更高级，但是对于初学者来说，假设项目始终位于/usr/local中，它是大多数Unix软件的标准安装目录。
configure; make; make install
假设大多数软件可以通过configure; make; make install来安装，也许configure是可选的。如果软件不能通过这种方式安装，要么提供某种方式来修改命令，要么devpkg就可以无视它。
用户可以root
我们假设用于可以使用sudo来提升至root权限，除非他们直到最后才想root。
这会使我们的程序像当初设想的一样简单，并且对于它的功能来说已经足够了。之后你可以进一步修改它。
Apache 可移植运行时 link你需要做的另外一件事情就是使用Apache可移植运行时（APR）来未完成这个练习获得一个可移植的工具集。APR并不是必要的，你也可以不用它，但是你需要写的代码就会非常多。我现在强制你使用APR，使你能够熟悉链接和使用其他的库。最后，APR也能在Windows上工作，所以你可以把它迁移到许多其它平台上。
你应该获取apr-1.4.5和apr-util-1.3的库，以及浏览在apr.apache.org主站上的文档。
下面是一个ShellScript，用于安装所需的所有库。你应该手动将它写到一个文件中，之后运行它直到APR安装好并且没有任何错误。
set -e cd /tmp curl -L -O http://archive.apache.org/dist/apr/apr-1.4.6.tar.gz tar -xzvf apr-1.</description>
    </item>
    
    <item>
      <title>练习27：创造性和防御性编程</title>
      <link>https://cuterwrite.top/TechDocs/docs/c-guide/ex27/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/c-guide/ex27/</guid>
      <description>原文：Exercise 27: Creative And Defensive Programming
译者：飞龙
你已经学到了大多数C语言的基础，并且准备好开始成为一个更严谨的程序员了。这里就是从初学者走向专家的地方，不仅仅对于C，更对于核心的计算机科学概念。我将会教给你一些核心的数据结构和算法，它们是每个程序员都要懂的，还有一些我在真实程序中所使用的一些非常有趣的东西。
在我开始之前，我需要教给你一些基本的技巧和观念，它们能帮助你编写更好的软件。练习27到31会教给你高级的概念和特性，而不是谈论编程，但是这些之后你将会应用它们来编写核心库或有用的数据结构。
编写更好的C代码（实际上是所有语言）的第一步是，学习一种新的观念叫做“防御性编程”。防御性编程假设你可能会制造出很多错误，之后尝试在每一步尽可能预防它们。这个练习中我打算教给你如何以防御性的思维来思考编程。
创造性编程思维 link在这个简单的练习中要告诉你如何做到创造性是不可能的，但是我会告诉你一些涉及到任务风险和开放思维的创造力。恐惧会快速地扼杀创造力，所以我采用，并且许多程序员也采用的这种思维方式使我不会惧怕风险，并且看上去像个傻瓜。
我不会犯错误。 人们所想的并不重要。 我脑子里面诞生的想法才是最好的。 我只是暂时接受了这种思维，并且在应用中用了一些小技巧。为了这样做我会提出一些想法，寻找创造性的解决方案，开一些奇奇怪怪的脑洞，并且不会害怕发明一些古怪的东西。在这种思维方式下，我通常会编写出第一个版本的糟糕代码，用于将想法描述出来。
然而，当我完成我的创造性原型时，我会将它扔掉，并且将它变得严谨和可考。其它人在这里常犯的一个错误就是将创造性思维引入它们的实现阶段。这样会产生一种非常不同的破坏性思维，它是创造性思维的阴暗面：
编写完美的软件是可行的。 我的大脑告诉我了真相，它不会发现任何错误，所以我写了完美的软件。 我的代码就是我自己，批判它的人也在批判我。 这些都是错误的。你经常会碰到一些程序员，它们对自己创造的软件具有强烈的荣誉感。这很正常，但是这种荣誉感会成为客观上改进作品的阻力。由于这种荣誉感和它们对作品的依恋，它们会一直相信它们编写的东西是完美的。只要它们忽视其它人的对这些代码的观点，它们就可以保护它们的玻璃心，并且永远不会改进。
同时具有创造性思维和编写可靠软件的技巧是，采用防御性编程的思维。
防御性编程思维 link在你做出创造性原型，并且对你的想法感觉良好之后，就应该切换到防御性思维了。防御性思维的程序员大致上会否定你的代码，并且相信下面这些事情：
软件中存在错误。 你并不是你的软件，但你需要为错误负责。 你永远不可能消除所有错误，只能降低它们的可能性。 这种思维方式让你诚实地对待你的代码，并且为改进批判地分析它。注意上面并没有说你充满了错误，只是说你的代码充满错误。这是一个需要理解的关键，因为它给了你编写下一个实现的客观力量。
就像创造性思维，防御性编程思维也有阴暗面。防御性程序员是一个惧怕任何事情的偏执狂，这种恐惧使他们远离可能的错误或避免犯错误。当你尝试做到严格一致或正确时这很好，但是它是创造力和专注的杀手。
八个防御性编程策略 link一旦你接受了这一思维，你可以重新编写你的原型，并且遵循下面的八个策略，它们被我用于尽可能把代码变得可靠。当我编写代码的“实际”版本，我会严格按照下面的策略，并且尝试消除尽可能多的错误，以一些会破坏我软件的人的方式思考。
永远不要信任输入
永远不要提供的输入，并总是校验它。
避免错误
如果错误可能发生，不管可能性多低都要避免它。
过早暴露错误
过早暴露错误，并且评估发生了什么、在哪里发生以及如何修复。
记录假设
清楚地记录所有先决条件，后置条件以及不变量。
防止过多的文档
不要在实现阶段就编写文档，它们可以在代码完成时编写。
使一切自动化
使一切自动化，尤其是测试。
简单化和清晰化
永远简化你的代码，在没有牺牲安全性的同时变得最小和最整洁。
质疑权威
不要盲目遵循或拒绝规则。
这些并不是全部，仅仅是一些核心的东西，我认为程序员应该在编程可靠的代码时专注于它们。要注意我并没有真正说明如何具体做到这些，我接下来会更细致地讲解每一条，并且会布置一些覆盖它们的练习。
应用这八条策略 link这些观点都是一些流行心理学的陈词滥调，但是你如何把它们应用到实际编程中呢？我现在打算向你展示这本书中的一些代码所做的事情，这些代码用具体的例子展示每一条策略。这八条策略并不止于这些例子，你应该使用它们作为指导，使你的代码更可靠。
永远不要信任输入 link让我们来看一个坏设计和“更好”的设计的例子。我并不想称之为好设计，因为它可以做得更好。看一看这两个函数，它们都复制字符串，main函数用于测试哪个更好。
undef NDEBUG #include &amp;#34;dbg.h&amp;#34; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;assert.h&amp;gt; /* * Naive copy that assumes all inputs are always valid * taken from K&amp;amp;R C and cleaned up a bit.</description>
    </item>
    
    <item>
      <title>练习28：Makefile 进阶</title>
      <link>https://cuterwrite.top/TechDocs/docs/c-guide/ex28/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/c-guide/ex28/</guid>
      <description>原文：Exercise 28: Intermediate Makefiles
译者：飞龙
在下面的三个练习中你会创建一个项目的目录框架，用于构建之后的C程序。这个目录框架会在这本书中剩余的章节中使用，并且这个练习中我会涉及到Makefile便于你理解它。
这个结构的目的是，在不凭借配置工具的情况下，使构建中等规模的程序变得容易。如果完成了它，你会学到很多GNU make和一些小型shell脚本方面的东西。
基本的项目结构 link首先要做的事情是创建一个C的目录框架，并且放置一些多续项目都拥有的，基本的文件和目录。这是我的目录：
$ mkdir c-skeleton $ cd c-skeleton/ $ touch LICENSE README.md Makefile $ mkdir bin src tests $ cp dbg.h src/ # this is from Ex20 $ ls -l total 8 -rw-r--r-- 1 zedshaw staff 0 Mar 31 16:38 LICENSE -rw-r--r-- 1 zedshaw staff 1168 Apr 1 17:00 Makefile -rw-r--r-- 1 zedshaw staff 0 Mar 31 16:38 README.md drwxr-xr-x 2 zedshaw staff 68 Mar 31 16:38 bin drwxr-xr-x 2 zedshaw staff 68 Apr 1 10:07 build drwxr-xr-x 3 zedshaw staff 102 Apr 3 16:28 src drwxr-xr-x 2 zedshaw staff 68 Mar 31 16:38 tests $ ls -l src total 8 -rw-r--r-- 1 zedshaw staff 982 Apr 3 16:28 dbg.</description>
    </item>
    
    <item>
      <title>练习29：库和链接</title>
      <link>https://cuterwrite.top/TechDocs/docs/c-guide/ex29/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/c-guide/ex29/</guid>
      <description>原文：Exercise 29: Libraries And Linking
译者：飞龙
C语言编程的核心能力之一就是链接OS所提供的库。链接是一种为你的程序添加额外特性的方法，这些特性由其它人在系统中创建并打包。你已经使用了一些自动包含的标准库，但是我打算对库的不同类型和它们的作用做个解释。
首先，库在每个语言中都没有良好的设计。我不知道为什么，但是似乎语言的设计者都将链接视为不是特别重要的东西。它们通常令人混乱，难以使用，不能正确进行版本控制，并以不同的方式链接到各种地方。
C没有什么不同，但是C中的库和链接是Unix操作系统的组件，并且可执行的格式在很多年前就设计好了。学习C如何链接库有助于理解OS如何工作，以及它如何运行你的程序。
C中的库有两种基本类型：
静态
你可以使用ar和ranlib来构建它，就像上个练习中的libYOUR_LIBRARY.a那样（Windows下后缀为.lib）。这种库可以当做一系列.o对象文件和函数的容器，以及当你构建程序时，可以当做是一个大型的.o文件。
动态
它们通常以.so（Linux）或.dll（Windows）结尾。在OSX中，差不多有一百万种后缀，取决于版本和编写它的人。严格来讲，OSX中的.dylib，.bundle和framework这三个之间没什么不同。这些文件都被构建好并且放置到指定的地方。当你运行程序时，OS会动态加载这些文件并且“凭空”链接到你的程序中。
我倾向于对小型或中型项目使用静态的库，因为它们易于使用，并且工作在在更多操作系统上。我也喜欢将所有代码放入静态库中，之后链接它来执行单元测试，或者链接到所需的程序中。
动态库适用于大型系统，它的空间十分有限，或者其中大量程序都使用相同的功能。这种情况下不应该为每个程序的共同特性静态链接所有代码，而是应该将它放到动态库中，这样它仅仅会为所有程序加载一份。
在上一个练习中，我讲解了如何构建静态库（.a），我会在本书的剩余部分用到它。这个练习中我打算向你展示如何构建一个简单的.so库，并且如何使用Unix系统的dlopen动态加载它。我会手动执行它，以便你可以理解每件实际发生的事情。之后，附加题这部分会使用c项目框架来创建它。
动态加载动态库 link我创建了两个源文件来完成它。一个用于构建libex29.so库，另一个是个叫做ex29的程序，它可以加载这个库并运行其中的程序：
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;ctype.h&amp;gt; #include &amp;#34;dbg.h&amp;#34; int print_a_message(const char *msg) { printf(&amp;#34;A STRING: %s\n&amp;#34;, msg); return 0; } int uppercase(const char *msg) { int i = 0; // BUG: \0 termination problems for(i = 0; msg[i] != &amp;#39;\0&amp;#39;; i&amp;#43;&amp;#43;) { printf(&amp;#34;%c&amp;#34;, toupper(msg[i])); } printf(&amp;#34;\n&amp;#34;); return 0; } int lowercase(const char *msg) { int i = 0; // BUG: \0 termination problems for(i = 0; msg[i] !</description>
    </item>
    
    <item>
      <title>练习30：自动化测试</title>
      <link>https://cuterwrite.top/TechDocs/docs/c-guide/ex30/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/c-guide/ex30/</guid>
      <description>原文：Exercise 30: Automated Testing
译者：飞龙
自动化测试经常用于例如Python和Ruby的其它语言，但是很少用于C。一部分原因是自动化加载和测试C的代码片段具有较高的难度。这一章中，我们会创建一个非常小型的测试“框架”，并且使用你的框架目录构建测试用例的示例。
我接下来打算使用，并且你会包含进框架目录的框架，叫做“minunit”，它以Jera Design所编写的一小段代码作为开始，之后我扩展了它，就像这样：
#undef NDEBUG #ifndef _minunit_h #define _minunit_h #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;dbg.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; #define mu_suite_start() char *message = NULL #define mu_assert(test, message) if (!(test)) { log_err(message); return message; } #define mu_run_test(test) debug(&amp;#34;\n-----%s&amp;#34;, &amp;#34; &amp;#34; #test); \ message = test(); tests_run&amp;#43;&amp;#43;; if (message) return message; #define RUN_TESTS(name) int main(int argc, char *argv[]) {\ argc = 1; \ debug(&amp;#34;----- RUNNING: %s&amp;#34;, argv[0]);\ printf(&amp;#34;----\nRUNNING: %s\n&amp;#34;, argv[0]);\ char *result = name();\ if (result !</description>
    </item>
    
    <item>
      <title>练习31：代码调试</title>
      <link>https://cuterwrite.top/TechDocs/docs/c-guide/ex31/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/c-guide/ex31/</guid>
      <description>原文：Exercise 31: Debugging Code
译者：飞龙
我已经教给你一些关于我的强大的调试宏的技巧，并且你已经开始用它们了。当我调试代码时，我使用debug()宏，分析发生了什么以及跟踪问题。在这个练习中我打算教给你一些使用gdb的技巧，用于监视一个不会退出的简单程序。你会学到如何使用gdb附加到运行中的进程，并挂起它来观察发生了什么。在此之后我会给你一些用于gdb的小提示和小技巧。
调试输出、GDB或Valgrind link我主要按照一种“科学方法”的方式来调试，我会提出可能的所有原因，之后排除它们或证明它们导致了缺陷。许多程序员拥有的问题是它们对解决bug的恐慌和急躁使他们觉得这种方法会“拖慢”他们。它们并没有注意到，它们已经失败了，并且在收集无用的信息。我发现日志（调试输出）会强迫我科学地解决bug，并且在更多情况下易于收集信息。
此外，使用调试输出来作为我的首要调试工具的理由如下：
你可以使用变量的调试输出，来看到程序执行的整个轨迹，它让你跟踪变量是如何产生错误的。使用gdb的话，你必须为每个变量放置查看和调试语句，并且难以获得执行的实际轨迹。 调试输出存在于代码中，当你需要它们是你可以重新编译使它们回来。使用gdb的话，你每次调试都需要重新配置相同的信息。 当服务器工作不正常时，它的调试日志功能易于打开，并且在它运行中可以监视日志来查看哪里不对。系统管理员知道如何处理日志，他们不知道如何使用gdb。 打印信息更加容易。调试器通常由于它奇特的UI和前后矛盾显得难用且古怪。debug(&amp;quot;Yo, dis right? %d&amp;quot;, my_stuff);就没有那么麻烦。 编写调试输出来发现缺陷，强迫你实际分析代码，并且使用科学方法。你可以认为它是，“我假设这里的代码是错误的”，你可以运行它来验证你的假设，如果这里没有错误那么你可以移动到其它地方。这看起来需要更长时间，但是实际上更快，因为你经历了“鉴别诊断”的过程，并排除所有可能的原因，直到你找到它。 调试输入更适于和单元测试一起运行。你可以实际上总是编译调试语句，单元测试时可以随时查看日志。如果你用gdb，你需要在gdb中重复运行单元测试，并跟踪他来查看发生了什么。 使用Valgrind可以得到和调试输出等价的内存相关的错误，所以你并不需要使用类似gdb的东西来寻找缺陷。 尽管所有原因显示我更倾向于debug而不是gdb，我还是在少数情况下回用到gdb，并且我认为你应该选择有助于你完成工作的工具。有时，你只能够连接到一个崩溃的程序并且四处转悠。或者，你得到了一个会崩溃的服务器，你只能够获得一些核心文件来一探究竟。这些货少数其它情况中，gdb是很好的办法。你最好准备尽可能多的工具来解决问题。
接下来我会通过对比gdb、调试输出和Valgrind来详细分析，像这样：
Valgrind用于捕获所有内存错误。如果Valgrind中含有错误或Valgrind会严重拖慢程序，我会使用gdb。 调试输出用于诊断或修复有关逻辑或使用上的缺陷。在你使用Valgrind之前，这些共计90%的缺陷。 使用gdb解决剩下的“谜之bug”，或如要收集信息的紧急情况。如果Valgrind不起作用，并且我不能打印出所需信息，我就会使用gdb开始四处搜索。这里我仅仅使用gdb来收集信息。一旦我弄清发生了什么，我会回来编程单元测试来引发缺陷，之后编程打印语句来查找原因。 调试策略 link这一过程适用于你打算使用任何调试技巧，无论是Valgrind、调试输出，或者使用调试器。我打算以使用gdb的形式来描述他，因为似乎人们在使用调试器是会跳过它。但是应当对每个bug使用它，直到你只需要在非常困难的bug上用到。
创建一个小型文本文件叫做notes.txt，并且将它用作记录想法、bug和问题的“实验记录”。 在你使用gdb之前，写下你打算修复的bug，以及可能的产生原因。 对于每个原因，写下你所认为的，问题来源的函数或文件，或者仅仅写下你不知道。 现在启动gdb并且使用file:function挑选最可能的因素，之后在那里设置断点。 使用gdb运行程序，并且确认它是否是真正原因。查明它的最好方式就是看看你是否可以使用set命令，简单修复问题或者重现错误。 如果它不是真正原因，则在notes.txt中标记它不是，以及理由。移到下一个可能的原因，并且使最易于调试的，之后记录你收集到的信息。 这里你并没有注意到，它是最基本的科学方法。你写下一些假设，之后调试来证明或证伪它们。这让你洞察到更多可能的因素，最终使你找到他。这个过程有助于你避免重复步入同一个可能的因素，即使你发现它们并不可能。
你也可以使用调试输出来执行这个过程。唯一的不同就是你实际在源码中编写假设来推测问题所在，而不是notes.txt中。某种程度上，调试输出强制你科学地解决bug，因为你需要将假写为打印语句。
使用 GDB link我将在这个练习中调试下面这个程序，它只有一个不会正常终止的while循环。我在里面放置了一个usleep调用，使它循环起来更加有趣。
#include &amp;lt;unistd.h&amp;gt; int main(int argc, char *argv[]) { int i = 0; while(i &amp;lt; 100) { usleep(3000); } return 0; } 像往常一样编译，并且在gdb下启动它，例如：gdb ./ex31。
一旦它运行之后，我打算让你使用这些gdb命令和它交互，并且观察它们的作用以及如何使用它们。
help COMMAND
获得COMMAND的简单帮助。
break file.c:(line|function)
在你希望暂停之星的地方设置断点。你可以提供行号或者函数名称，来在文件中的那个地方暂停。
run ARGS</description>
    </item>
    
    <item>
      <title>练习32：双向链表</title>
      <link>https://cuterwrite.top/TechDocs/docs/c-guide/ex32/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/c-guide/ex32/</guid>
      <description>原文：Exercise 32: Double Linked Lists
译者：飞龙
这本书的目的是教给你计算机实际上如何工作，这也包括多种数据结构和算法函数。计算机自己其实并没有太大用处。为了让它们做一些有用的事情，你需要构建数据，之后在这些结构上组织处理。其它编程语言带有实现所有这些结构的库，或者带有直接的语法来创建它们。C需要你手动实现所有数据结构，这使它成为最“完美”的语言，让你知道它们的工作原理。
我的目标是交给你这些数据结构，以及相关算法的知识，来帮助你完成下面这三件事：
理解Python、Ruby或JavaScript的data = {&amp;quot;name&amp;quot;: &amp;quot;Zed&amp;quot;}到底做了什么。 使用数据结构来解决问题，使你成为更好的C程序员。 学习数据结构和算法的核心部分，让你知道在特定条件下哪个最好。 数据结构是什么。 link“数据结构”这个名称自己就能够解释。它是具有特性模型的数据组织方法。这一模型可能设计用于以新的方法处理数据，也可能只是用于将它们更高效地储存在磁盘上。这本书中我会遵循一些简单的模式来构建可用的数据结构：
定义一个结构的主要“外部结构”。 定义一个结构的内容，通常是带有链接的节点。 创建函数操作它们的函数。 C中还有其它样式的数据结构，但是这个模式效果很好，并且对于你创建的大部分数据结构都适用。
构建库 link对于这本书的剩余部分，当你完成这本书之后，你将会创建一个可用的库。这个库会包含下列元素：
为每个数据结构编写的头文件.h。 为算法编写的实现文件.c。 用于测试它们确保有效的单元测试。 从头文件自动生成的文档。 你已经实现了c-skeleton（项目框架目录），使用它来创建一个liblcthw项目：
$ cp -r c-skeleton liblcthw $ cd liblcthw/ $ ls LICENSE Makefile README.md bin build src tests $ vim Makefile $ ls src/ dbg.h libex29.c libex29.o $ mkdir src/lcthw $ mv src/dbg.h src/lcthw $ vim tests/minunit.h $ rm src/libex29.* tests/libex29* $ make clean rm -rf build tests/libex29_tests rm -f tests/tests.</description>
    </item>
    
    <item>
      <title>练习33：链表算法</title>
      <link>https://cuterwrite.top/TechDocs/docs/c-guide/ex33/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/c-guide/ex33/</guid>
      <description>原文：Exercise 33: Linked List Algorithms
译者：飞龙
我将想你介绍涉及到排序的两个算法，你可以用它们操作链表。我首先要警告你，如果你打算对数据排序，不要使用链表，它们对于排序十分麻烦，并且有更好的数据结构作为替代。我向你介绍这两种算法只是因为它们难以在链表上完成，并且让你思考如何高效操作它们。
为了编写这本书，我打算将算法放在两个不同的文件中，list_algos.h和list_algos.c，之后在list_algos_test.c中编写测试。现在你要按照我的结构，因为它足以把事情做好，但是如果你使用其它的库要记住这并不是通用的结构。
这个练习中我打算给你一些额外的挑战，并且希望你不要作弊。我打算先给你单元测试，并且让你打下来。之后让你基于它们在维基百科中的描述，尝试实现这个两个算法，之后看看你的代码是否和我的类似。
冒泡排序和归并排序 link互联网的强大之处，就是我可以仅仅给你冒泡排序和归并排序的链接，来让你学习它们。是的，这省了我很多字。现在我要告诉你如何使用它们的伪代码来实现它们。你可以像这样来实现算法：
阅读描述，并且观察任何可视化的图表。 使用方框和线条在纸上画出算法，或者使用一些带有数字的卡片（比如扑克牌），尝试手动执行算法。这会向你形象地展示算法的执行过程。 在list_algos.c文案总创建函数的主干，并且创建list_algos.h文件，之后创建测试代码。 编写第一个测试并且编译所有东西。 回到维基百科页面，复制粘贴伪代码到你创建的函数中（不是C代码）。 将伪代码翻译成良好的C代码，就像我教你的那样，使用你的单元测试来保证它有效。 为边界情况补充一些测试，例如空链表，排序号的链表，以及其它。 对下一个算法重复这些过程并测试。 我只是告诉你理解大多数算法的秘密，直到你碰到一些更加麻烦的算法。这里你只是按照维基百科来实现冒泡排序和归并排序，它们是一个好的起始。
单元测试 link下面是你应该通过的单元测试：
#include &amp;#34;minunit.h&amp;#34; #include &amp;lt;lcthw/list_algos.h&amp;gt; #include &amp;lt;assert.h&amp;gt; #include &amp;lt;string.h&amp;gt; char *values[] = {&amp;#34;XXXX&amp;#34;, &amp;#34;1234&amp;#34;, &amp;#34;abcd&amp;#34;, &amp;#34;xjvef&amp;#34;, &amp;#34;NDSS&amp;#34;}; #define NUM_VALUES 5 List *create_words() { int i = 0; List *words = List_create(); for(i = 0; i &amp;lt; NUM_VALUES; i&amp;#43;&amp;#43;) { List_push(words, values[i]); } return words; } int is_sorted(List *words) { LIST_FOREACH(words, first, next, cur) { if(cur-&amp;gt;next &amp;amp;&amp;amp; strcmp(cur-&amp;gt;value, cur-&amp;gt;next-&amp;gt;value) &amp;gt; 0) { debug(&amp;#34;%s %s&amp;#34;, (char *)cur-&amp;gt;value, (char *)cur-&amp;gt;next-&amp;gt;value); return 0; } } return 1; } char *test_bubble_sort() { List *words = create_words(); // should work on a list that needs sorting int rc = List_bubble_sort(words, (List_compare)strcmp); mu_assert(rc == 0, &amp;#34;Bubble sort failed.</description>
    </item>
    
    <item>
      <title>练习34：动态数组</title>
      <link>https://cuterwrite.top/TechDocs/docs/c-guide/ex34/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/c-guide/ex34/</guid>
      <description>原文：Exercise 34: Dynamic Array
译者：飞龙
动态数组是自增长的数组，它与链表有很多相同的特性。它通常占据更少的空间，跑得更快，还有一些其它的优势属性。这个练习会涉及到它的一些缺点，比如从开头移除元素会很慢，并给出解决方案（只从末尾移除）。
动态数组简单地实现为void **指针的数组，它是预分配内存的，并且指向数据。在链表中你创建了完整的结构体来储存void *value指针，但是动态数组中你只需要一个储存它们的单个数组。也就是说，你并不需要创建任何其它的指针储存上一个或下一个元素。它们可以直接索引。
我会给你头文件作为起始，你需要为实现打下它们：
#ifndef _DArray_h #define _DArray_h #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;assert.h&amp;gt; #include &amp;lt;lcthw/dbg.h&amp;gt; typedef struct DArray { int end; int max; size_t element_size; size_t expand_rate; void **contents; } DArray; DArray *DArray_create(size_t element_size, size_t initial_max); void DArray_destroy(DArray *array); void DArray_clear(DArray *array); int DArray_expand(DArray *array); int DArray_contract(DArray *array); int DArray_push(DArray *array, void *el); void *DArray_pop(DArray *array); void DArray_clear_destroy(DArray *array); #define DArray_last(A) ((A)-&amp;gt;contents[(A)-&amp;gt;end - 1]) #define DArray_first(A) ((A)-&amp;gt;contents[0]) #define DArray_end(A) ((A)-&amp;gt;end) #define DArray_count(A) DArray_end(A) #define DArray_max(A) ((A)-&amp;gt;max) #define DEFAULT_EXPAND_RATE 300 static inline void DArray_set(DArray *array, int i, void *el) { check(i &amp;lt; array-&amp;gt;max, &amp;#34;darray attempt to set past max&amp;#34;); if(i &amp;gt; array-&amp;gt;end) array-&amp;gt;end = i; array-&amp;gt;contents[i] = el; error: return; } static inline void *DArray_get(DArray *array, int i) { check(i &amp;lt; array-&amp;gt;max, &amp;#34;darray attempt to get past max&amp;#34;); return array-&amp;gt;contents[i]; error: return NULL; } static inline void *DArray_remove(DArray *array, int i) { void *el = array-&amp;gt;contents[i]; array-&amp;gt;contents[i] = NULL; return el; } static inline void *DArray_new(DArray *array) { check(array-&amp;gt;element_size &amp;gt; 0, &amp;#34;Can&amp;#39;t use DArray_new on 0 size darrays.</description>
    </item>
    
    <item>
      <title>练习35：排序和搜索</title>
      <link>https://cuterwrite.top/TechDocs/docs/c-guide/ex35/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/c-guide/ex35/</guid>
      <description>原文：Exercise 35: Sorting And Searching
译者：飞龙
这个练习中我打算涉及到四个排序算法和一个搜索算法。排序算法是快速排序、堆排序、归并排序和基数排序。之后在你完成基数排序之后，我打算想你展示二分搜索。
然而，我是一个懒人，大多数C标准库都实现了堆排序、快速排序和归并排序算法，你可以直接使用它们：
#include &amp;lt;lcthw/darray_algos.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; int DArray_qsort(DArray *array, DArray_compare cmp) { qsort(array-&amp;gt;contents, DArray_count(array), sizeof(void *), cmp); return 0; } int DArray_heapsort(DArray *array, DArray_compare cmp) { return heapsort(array-&amp;gt;contents, DArray_count(array), sizeof(void *), cmp); } int DArray_mergesort(DArray *array, DArray_compare cmp) { return mergesort(array-&amp;gt;contents, DArray_count(array), sizeof(void *), cmp); } 这就是darray_algos.c文件的整个实现，它在大多数现代Unix系统上都能运行。它们的每一个都使用DArray_compare对contents中储存的无类型指针进行排序。我也要向你展示这个头文件：
#ifndef darray_algos_h #define darray_algos_h #include &amp;lt;lcthw/darray.h&amp;gt; typedef int (*DArray_compare)(const void *a, const void *b); int DArray_qsort(DArray *array, DArray_compare cmp); int DArray_heapsort(DArray *array, DArray_compare cmp); int DArray_mergesort(DArray *array, DArray_compare cmp); #endif 大小几乎一样，你也应该能预料到。接下来你可以了解单元测试中这三个函数如何使用：</description>
    </item>
    
    <item>
      <title>练习36：更安全的字符串</title>
      <link>https://cuterwrite.top/TechDocs/docs/c-guide/ex36/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/c-guide/ex36/</guid>
      <description>原文：Exercise 36: Safer Strings
译者：飞龙
我已经在练习26中，构建devpkg的时候介绍了Better String库。这个练习让你从现在开始熟悉bstring库，并且明白C风格字符串为什么十分糟糕。之后你需要修改liblcthw的代码来使用bstring。
为什么C风格字符串十分糟糕 link当人们谈论C的问题时，“字符串”的概念永远是首要缺陷之一。你已经用过它们，并且我也谈论过它们的种种缺陷，但是对为什么C字符串拥有缺陷，以及为什么一直是这样没有明确的解释。我会试着现在做出解释，部分原因是C风格字符串经过数十年的使用，有足够的证据表明它们是个非常糟糕的东西。
对于给定的任何C风格字符串，都不可能验证它是否有效。
以&#39;\0&#39;结尾的C字符串是有效的。 任何处理无效C字符串的循环都是无限的（或者造成缓冲区溢出）。 C字符串没有确定的长度，所以检查它们的唯一方法就是遍历它来观察循环是否正确终止。 所以，不通过有限的循环就不可能验证C字符串。 这个逻辑非常简单。你不能编写一个循环来验证C字符串是否有效，因为无效的字符串导致循环永远不会停止。就是这样，唯一的解决方案就是包含大小。一旦你知道了大小，你可以避免无限循环问题。如果你观察练习27中我向你展示的两个函数：
译者注：检验C风格字符串是否有效等价于“停机问题”，这是一个非常著名的不可解问题。
void copy(char to[], char from[]) { int i = 0; // while loop will not end if from isn&amp;#39;t &amp;#39;\0&amp;#39; terminated while((to[i] = from[i]) != &amp;#39;\0&amp;#39;) { &amp;#43;&amp;#43;i; } } int safercopy(int from_len, char *from, int to_len, char *to) { int i = 0; int max = from_len &amp;gt; to_len - 1 ? to_len - 1 : from_len; // to_len must have at least 1 byte if(from_len &amp;lt; 0 || to_len &amp;lt;= 0) return -1; for(i = 0; i &amp;lt; max; i&amp;#43;&amp;#43;) { to[i] = from[i]; } to[to_len - 1] = &amp;#39;\0&amp;#39;; return i; } 想象你想要向copy函数添加检查来确保from字符串有效。你该怎么做呢？你编写了一个循环来检查字符串是否已&#39;\0&#39;结尾。哦，等一下，如果字符串不以&#39;\0&#39;结尾，那它怎么让循环停下？不可能停下，所以无解。</description>
    </item>
    
    <item>
      <title>练习37：哈希表</title>
      <link>https://cuterwrite.top/TechDocs/docs/c-guide/ex37/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/c-guide/ex37/</guid>
      <description>原文：Exercise 37: Hashmaps
译者：飞龙
哈希表（HashMap、HashTable以及Dictionary）广泛用于许多动态编程语言来储存键值对的数据。哈希表通过在键上执行“哈希”运算产生整数，之后使用它来寻找相应的桶来获取或储存值。它是非常快速的使用数据结构，因为它适用于任何数据并且易于实现。
下面是哈希表（也叫作字典）的一个使用示例：
fruit_weights = {&amp;#39;Apples&amp;#39;: 10, &amp;#39;Oranges&amp;#39;: 100, &amp;#39;Grapes&amp;#39;: 1.0} for key, value in fruit_weights.items(): print key, &amp;#34;=&amp;#34;, value 几乎所有现代语言都具备这种特性，所以许多人写完代码都不知道它实际上如何工作。通过在C中创建Hashmap数据结构，我会向你展示它的工作原理。我会从头文件开始，来谈论整个数据结构。
#ifndef _lcthw_Hashmap_h #define _lcthw_Hashmap_h #include &amp;lt;stdint.h&amp;gt; #include &amp;lt;lcthw/darray.h&amp;gt; #define DEFAULT_NUMBER_OF_BUCKETS 100 typedef int (*Hashmap_compare)(void *a, void *b); typedef uint32_t (*Hashmap_hash)(void *key); typedef struct Hashmap { DArray *buckets; Hashmap_compare compare; Hashmap_hash hash; } Hashmap; typedef struct HashmapNode { void *key; void *data; uint32_t hash; } HashmapNode; typedef int (*Hashmap_traverse_cb)(HashmapNode *node); Hashmap *Hashmap_create(Hashmap_compare compare, Hashmap_hash); void Hashmap_destroy(Hashmap *map); int Hashmap_set(Hashmap *map, void *key, void *data); void *Hashmap_get(Hashmap *map, void *key); int Hashmap_traverse(Hashmap *map, Hashmap_traverse_cb traverse_cb); void *Hashmap_delete(Hashmap *map, void *key); #endif 这个结构就是Hashmap，含有许多HashmapNode节点。观察Hashmap你会看到它类似这样：</description>
    </item>
    
    <item>
      <title>练习38：哈希算法</title>
      <link>https://cuterwrite.top/TechDocs/docs/c-guide/ex38/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/c-guide/ex38/</guid>
      <description>原文：Exercise 38: Hashmap Algorithms
译者：飞龙
你需要在这个练习中实现下面这三个哈希函数：
FNV-1a
以创造者Glenn Fowler、Phong Vo 和 Landon Curt Noll的名字命名。这个算法产生合理的数值并且相当快。
Adler-32
以Mark Adler命名。一个比较糟糕的算法，但是由来已久并且适于学习。
DJB Hash
由Dan J. Bernstein (DJB)发明的哈希算法，但是难以找到这个算法的讨论。它非常快，但是结果不是很好。
你应该看到我使用了Jenkins hash作为Hashmap数据结构的默认哈希函数，所以这个练习的重点会放在这三个新的函数上。它们的代码通常来说不多，并且没有任何优化。像往常一样我会放慢速度来让你理解。
头文件非常简单，所以我以它开始：
#ifndef hashmap_algos_h #define hashmap_algos_h #include &amp;lt;stdint.h&amp;gt; uint32_t Hashmap_fnv1a_hash(void *data); uint32_t Hashmap_adler32_hash(void *data); uint32_t Hashmap_djb_hash(void *data); #endif 我只是声明了三个函数，我会在hashmap_algos.c文件中实现它们：
#include &amp;lt;lcthw/hashmap_algos.h&amp;gt; #include &amp;lt;lcthw/bstrlib.h&amp;gt; // settings taken from // http://www.isthe.com/chongo/tech/comp/fnv/index.html#FNV-param const uint32_t FNV_PRIME = 16777619; const uint32_t FNV_OFFSET_BASIS = 2166136261; uint32_t Hashmap_fnv1a_hash(void *data) { bstring s = (bstring)data; uint32_t hash = FNV_OFFSET_BASIS; int i = 0; for(i = 0; i &amp;lt; blength(s); i&amp;#43;&amp;#43;) { hash ^= bchare(s, i, 0); hash *= FNV_PRIME; } return hash; } const int MOD_ADLER = 65521; uint32_t Hashmap_adler32_hash(void *data) { bstring s = (bstring)data; uint32_t a = 1, b = 0; int i = 0; for (i = 0; i &amp;lt; blength(s); i&amp;#43;&amp;#43;) { a = (a &amp;#43; bchare(s, i, 0)) % MOD_ADLER; b = (b &amp;#43; a) % MOD_ADLER; } return (b &amp;lt;&amp;lt; 16) | a; } uint32_t Hashmap_djb_hash(void *data) { bstring s = (bstring)data; uint32_t hash = 5381; int i = 0; for(i = 0; i &amp;lt; blength(s); i&amp;#43;&amp;#43;) { hash = ((hash &amp;lt;&amp;lt; 5) &amp;#43; hash) &amp;#43; bchare(s, i, 0); /* hash * 33 &amp;#43; c */ } return hash; } 这个文件中有三个哈希函数。你应该注意到我默认使用bstring作为键，并且使用了bchare函数从字符串获取字符，然而如果字符超出了字符串的长度会返回0。</description>
    </item>
    
    <item>
      <title>练习39：字符串算法</title>
      <link>https://cuterwrite.top/TechDocs/docs/c-guide/ex39/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/c-guide/ex39/</guid>
      <description>原文：Exercise 39: String Algorithms
译者：飞龙
这个练习中，我会向你展示可能是最快的字符串搜索算法之一，并且将它与bstrlib.c中现有的binstr比较。binstr的文档说它仅仅使用了“暴力搜索”的字符串算法来寻找第一个实例。我所实现的函数使用Boyer-Moore-Horspool（BMH）算法，如果你分析理论时间的话，一般认为它会更快。你也会看到，如果我的实现没有任何缺陷，BMH的实际时间会比binstr简单的暴力搜索更糟。
这个练习的要点并不是真正解释算法本身，因为你可以直接去Boyer-Moore-Horspool 的维基百科页面去阅读它。这个算法的要点就是它会计算出“跳跃字符列表”作为第一步操作，之后它使用这个列表来快速扫描整个字符串。它应当比暴力搜索更快，所以让我们在文件里写出代码来看看吧。
首先，创建头文件：
#ifndef string_algos_h #define string_algos_h #include &amp;lt;lcthw/bstrlib.h&amp;gt; #include &amp;lt;lcthw/darray.h&amp;gt; typedef struct StringScanner { bstring in; const unsigned char *haystack; ssize_t hlen; const unsigned char *needle; ssize_t nlen; size_t skip_chars[UCHAR_MAX &amp;#43; 1]; } StringScanner; int String_find(bstring in, bstring what); StringScanner *StringScanner_create(bstring in); int StringScanner_scan(StringScanner *scan, bstring tofind); void StringScanner_destroy(StringScanner *scan); #endif 为了观察“跳跃字符列表”的效果，我打算创建这个算法的两种版本：
String_find
只是在一个字符串中，寻找另一个字符串的首个实例，以一个动作执行整个算法。
StringScanner_scan
使用StringScanner状态结构，将跳跃列表的构建和实际的查找操作分开。这让我能看到什么影响了性能。这个模型有另一个优点，就是我可以在一个字符串中逐步搜索，并且快速地找到所有实例。
一旦你完成了头文件，下面就是实现了：
#include &amp;lt;lcthw/string_algos.h&amp;gt; #include &amp;lt;limits.h&amp;gt; static inline void String_setup_skip_chars( size_t *skip_chars, const unsigned char *needle, ssize_t nlen) { size_t i = 0; size_t last = nlen - 1; for(i = 0; i &amp;lt; UCHAR_MAX &amp;#43; 1; i&amp;#43;&amp;#43;) { skip_chars[i] = nlen; } for (i = 0; i &amp;lt; last; i&amp;#43;&amp;#43;) { skip_chars[needle[i]] = last - i; } } static inline const unsigned char *String_base_search( const unsigned char *haystack, ssize_t hlen, const unsigned char *needle, ssize_t nlen, size_t *skip_chars) { size_t i = 0; size_t last = nlen - 1; assert(haystack !</description>
    </item>
    
    <item>
      <title>练习40：二叉搜索树</title>
      <link>https://cuterwrite.top/TechDocs/docs/c-guide/ex40/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/c-guide/ex40/</guid>
      <description>原文：Exercise 40: Binary Search Trees
译者：飞龙
二叉树是最简单的树形数据结构，虽然它在许多语言中被哈希表取代，但仍旧对于一些应用很实用。二叉树的各种变体可用于一些非常实用东西，比如数据库的索引、搜索算法结构、以及图像处理。
我把我的二叉树叫做BSTree，描述它的最佳方法就是它是另一种Hashmap形式的键值对储存容器。它们的差异在于，哈希表为键计算哈希值来寻找位置，而二叉树将键与树中的节点进行对比，之后深入树中找到储存它的最佳位置，基于它与其它节点的关系。
在我真正解释它的工作原理之前，让我向你展示bstree.h头文件，便于你看到数据结构，之后我会用它来解释如何构建。
#ifndef _lcthw_BSTree_h #define _lcthw_BSTree_h typedef int (*BSTree_compare)(void *a, void *b); typedef struct BSTreeNode { void *key; void *data; struct BSTreeNode *left; struct BSTreeNode *right; struct BSTreeNode *parent; } BSTreeNode; typedef struct BSTree { int count; BSTree_compare compare; BSTreeNode *root; } BSTree; typedef int (*BSTree_traverse_cb)(BSTreeNode *node); BSTree *BSTree_create(BSTree_compare compare); void BSTree_destroy(BSTree *map); int BSTree_set(BSTree *map, void *key, void *data); void *BSTree_get(BSTree *map, void *key); int BSTree_traverse(BSTree *map, BSTree_traverse_cb traverse_cb); void *BSTree_delete(BSTree *map, void *key); #endif 这遵循了我之前用过的相同模式，我创建了一个基容器叫做BSTree，它含有叫做BSTreeNode的节点，组成实际内容。厌倦了吗？是的，这种结构也没有什么高明之处。</description>
    </item>
    
    <item>
      <title>练习41：将 Cachegrind 和 Callgrind 用于性能调优</title>
      <link>https://cuterwrite.top/TechDocs/docs/c-guide/ex41/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/c-guide/ex41/</guid>
      <description>原文：Exercise 41: Using Cachegrind And Callgrind For Performance Tuning
译者：飞龙
这个练习中，我打算上一节速成课，内容是使用Valgrind的两个工具callgrind和cachegrind。这两个工具会分析你程序的执行，并且告诉你哪一部分运行缓慢。这些结果非常精确，因为Valgrind的工作方式有助于你解决一些问题，比如执行过多的代码行，热点，内容访问问题，甚至是CPU的缓存未命中。
为了做这个练习，我打算使用bstree_tests单元测试，你之前用于寻找能提升算法的地方。你需要确保你这些程序的版本没有任何valgrind错误，并且和我的代码非常相似，因为我会使用我的代码的转储来谈论cachegrind和callgrind如何工作。
运行 Callgrind link为了运行Callgrind，你需要向valgrind传入--tool=callgrind选项，之后它会产生callgrind.out.PID文件（其中PID为所运行程序的进程PID）。一旦你这样运行了，你就可以使用一个叫做callgrind_annotate的工具分析callgrind.out文件，它会告诉你哪个函数运行中使用了最多的指令。下面是个例子，我在bstree_tests上运行了callgrind，之后得到了这个信息：
$ valgrind --dsymutil=yes --tool=callgrind tests/bstree_tests ... $ callgrind_annotate callgrind.out.1232 -------------------------------------------------------------------------------- Profile data file &amp;#39;callgrind.out.1232&amp;#39; (creator: callgrind-3.7.0.SVN) -------------------------------------------------------------------------------- I1 cache: D1 cache: LL cache: Timerange: Basic block 0 - 1098689 Trigger: Program termination Profiled target: tests/bstree_tests (PID 1232, part 1) Events recorded: Ir Events shown: Ir Event sort order: Ir Thresholds: 99 Include dirs: User annotated: Auto-annotation: off -------------------------------------------------------------------------------- Ir -------------------------------------------------------------------------------- 4,605,808 PROGRAM TOTALS -------------------------------------------------------------------------------- Ir file:function -------------------------------------------------------------------------------- 670,486 src/lcthw/bstrlib.</description>
    </item>
    
    <item>
      <title>练习42：栈和队列</title>
      <link>https://cuterwrite.top/TechDocs/docs/c-guide/ex42/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/c-guide/ex42/</guid>
      <description>原文：Exercise 42: Stacks and Queues
译者：飞龙
到现在为止，你已经知道了大多数用于构建其它数据结构的数据结构。如果你拥有一些List、DArray、Hashmap 和 Tree，你就能用他们构造出大多数其它的任何结构。你碰到的其它任何结构要么可以用它们实现，要么是它们的变体。如果不是的话，它可能是外来的数据结构，你可能不需要它。
Stack和Queue是非常简单的数据结构，它们是List的变体。它们是List的弱化或者转换形式，因为你只需要在List的一端放置元素。对于Stack，你只能能够在一段压入和弹出元素。而对于Queue，你只能够在开头压入元素，并在末尾弹出（或者反过来）。
我能够只通过C预处理器和两个头文件来实现这两个数据结构。我的头文件只有21行的长度，并且实现了所有Stack和Queue的操作，不带有任何神奇的定义。
我将会向你展示单元测试，你需要实现头文件来让它们正常工作。你不能创建stack.c 或 queue.c实现文件来通过测试，只能使用stack.h 和 queue.h来使测试运行。
#include &amp;#34;minunit.h&amp;#34; #include &amp;lt;lcthw/stack.h&amp;gt; #include &amp;lt;assert.h&amp;gt; static Stack *stack = NULL; char *tests[] = {&amp;#34;test1 data&amp;#34;, &amp;#34;test2 data&amp;#34;, &amp;#34;test3 data&amp;#34;}; #define NUM_TESTS 3 char *test_create() { stack = Stack_create(); mu_assert(stack != NULL, &amp;#34;Failed to create stack.&amp;#34;); return NULL; } char *test_destroy() { mu_assert(stack != NULL, &amp;#34;Failed to make stack #2&amp;#34;); Stack_destroy(stack); return NULL; } char *test_push_pop() { int i = 0; for(i = 0; i &amp;lt; NUM_TESTS; i&amp;#43;&amp;#43;) { Stack_push(stack, tests[i]); mu_assert(Stack_peek(stack) == tests[i], &amp;#34;Wrong next value.</description>
    </item>
    
    <item>
      <title>练习43：一个简单的统计引擎</title>
      <link>https://cuterwrite.top/TechDocs/docs/c-guide/ex43/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/c-guide/ex43/</guid>
      <description>原文：Exercise 43: A Simple Statistics Engine
译者：飞龙
这是一个简单的算法，我将其用于“联机”（不储存任何样本）收集概要统计。我在任何需要执行一些统计，比如均值、标准差和求和中使用它，但是其中我并不会储存所需的全部样本。我只需要储存计算出的结果，它们仅仅含有5个数值。
计算标准差和均值 link首先你需要一系列样本。它可以使任何事情，比如完成一个任务所需的时间，某人访问某个东西的次数，或者甚至是网站的评分。是什么并不重要，只要你能得到一些数字，并且你想要知道它们的下列概要统计值：
sum
对所有数字求和。
sumsq（平方和）
对所有数字求平方和。
count(n)
求出样本数量。
min
求出样本最小值。
max
求出样本最大值。
mean
求出样本的均值。它类似于但又不是中位数，但可作为中位数的估计。
stddev
使用$sqrt(sumsq - (sum * mean) / (n - 1) )来计算标准差，其中sqrt为math.h头文件中的平方根。
我将会使用R来验证这些计算，因为我知道R能够计算正确。
&amp;gt; s &amp;lt;- runif(n=10, max=10) &amp;gt; s [1] 6.1061334 9.6783204 1.2747090 8.2395131 0.3333483 6.9755066 1.0626275 [8] 7.6587523 4.9382973 9.5788115 &amp;gt; summary(s) Min. 1st Qu. Median Mean 3rd Qu. Max. 0.3333 2.1910 6.5410 5.5850 8.0940 9.6780 &amp;gt; sd(s) [1] 3.</description>
    </item>
    
    <item>
      <title>练习44：环形缓冲区</title>
      <link>https://cuterwrite.top/TechDocs/docs/c-guide/ex44/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/c-guide/ex44/</guid>
      <description>原文：Exercise 44: Ring Buffer
译者：飞龙
环形缓冲区在处理异步IO时非常实用。它们可以在一端接收随机长度和区间的数据，在另一端以相同长度和区间提供密致的数据块。它们是Queue数据结构的变体，但是它针对于字节块而不是一系列指针。这个练习中我打算向你展示RingBuffer的代码，并且之后你需要对它执行完整的单元测试。
#ifndef _lcthw_RingBuffer_h #define _lcthw_RingBuffer_h #include &amp;lt;lcthw/bstrlib.h&amp;gt; typedef struct { char *buffer; int length; int start; int end; } RingBuffer; RingBuffer *RingBuffer_create(int length); void RingBuffer_destroy(RingBuffer *buffer); int RingBuffer_read(RingBuffer *buffer, char *target, int amount); int RingBuffer_write(RingBuffer *buffer, char *data, int length); int RingBuffer_empty(RingBuffer *buffer); int RingBuffer_full(RingBuffer *buffer); int RingBuffer_available_data(RingBuffer *buffer); int RingBuffer_available_space(RingBuffer *buffer); bstring RingBuffer_gets(RingBuffer *buffer, int amount); #define RingBuffer_available_data(B) (((B)-&amp;gt;end &amp;#43; 1) % (B)-&amp;gt;length - (B)-&amp;gt;start - 1) #define RingBuffer_available_space(B) ((B)-&amp;gt;length - (B)-&amp;gt;end - 1) #define RingBuffer_full(B) (RingBuffer_available_data((B)) - (B)-&amp;gt;length == 0) #define RingBuffer_empty(B) (RingBuffer_available_data((B)) == 0) #define RingBuffer_puts(B, D) RingBuffer_write((B), bdata((D)), blength((D))) #define RingBuffer_get_all(B) RingBuffer_gets((B), RingBuffer_available_data((B))) #define RingBuffer_starts_at(B) ((B)-&amp;gt;buffer &amp;#43; (B)-&amp;gt;start) #define RingBuffer_ends_at(B) ((B)-&amp;gt;buffer &amp;#43; (B)-&amp;gt;end) #define RingBuffer_commit_read(B, A) ((B)-&amp;gt;start = ((B)-&amp;gt;start &amp;#43; (A)) % (B)-&amp;gt;length) #define RingBuffer_commit_write(B, A) ((B)-&amp;gt;end = ((B)-&amp;gt;end &amp;#43; (A)) % (B)-&amp;gt;length) #endif 观察这个数据结构，你会看到它含有buffer、start 和 end。RingBuffer的所做的事情只是在buffer中移动start和end，所以当数据到达缓冲区末尾时还可以继续“循环”。这样就会给人一种在固定空间内无限读取的“幻觉”。接下来我创建了一些宏来基于它执行各种计算。</description>
    </item>
    
    <item>
      <title>练习45：一个简单的TCP/IP客户端</title>
      <link>https://cuterwrite.top/TechDocs/docs/c-guide/ex45/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/c-guide/ex45/</guid>
      <description>原文：Exercise 45: A Simple TCP/IP Client
译者：飞龙
我打算使用RingBuffer来创建一个非常简单的小型网络测试工具，叫做netclient。为此我需要向Makefile添加一些工具，来处理bin/目录下的小程序。
扩展Makefile link首先，为程序添加一些变量，就像单元测试的TESTS和TEST_SRC变量：
PROGRAMS_SRC=$(wildcard bin/*.c) PROGRAMS=$(patsubst %.c,%,$(PROGRAMS_SRC)) 之后你可能想要添加PROGRAMS到所有目标中：
all: $(TARGET) $(SO_TARGET) tests $(PROGRAMS) 之后在clean目标中向rm那一行添加PROGRAMS：
rm -rf build $(OBJECTS) $(TESTS) $(PROGRAMS) 最后你还需要在最后添加一个目标来构建它们：
$(PROGRAMS): CFLAGS &amp;#43;= $(TARGET) 做了这些修改你就能够将.c文件扔到bin中，并且编译它们以及为其链接库文件，就像测试那样。
netclient 代码 linknetclient的代码是这样的：
#undef NDEBUG #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;sys/select.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;lcthw/ringbuffer.h&amp;gt; #include &amp;lt;lcthw/dbg.h&amp;gt; #include &amp;lt;sys/socket.h&amp;gt; #include &amp;lt;sys/types.h&amp;gt; #include &amp;lt;sys/uio.h&amp;gt; #include &amp;lt;arpa/inet.h&amp;gt; #include &amp;lt;netdb.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #include &amp;lt;fcntl.h&amp;gt; struct tagbstring NL = bsStatic(&amp;#34;\n&amp;#34;); struct tagbstring CRLF = bsStatic(&amp;#34;\r\n&amp;#34;); int nonblock(int fd) { int flags = fcntl(fd, F_GETFL, 0); check(flags &amp;gt;= 0, &amp;#34;Invalid flags on nonblock.</description>
    </item>
    
    <item>
      <title>练习46：三叉搜索树</title>
      <link>https://cuterwrite.top/TechDocs/docs/c-guide/ex46/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/c-guide/ex46/</guid>
      <description>原文：Exercise 46: Ternary Search Tree
译者：飞龙
我打算向你介绍的最后一种数据结构就是三叉搜索树（TSTree），它和BSTree很像，除了它有三个分支，low、equal和high。它的用法和BStree以及Hashmap基本相同，用于储存键值对的数据，但是它通过键中的独立字符来控制。这使得TSTree具有一些BStree和Hashmap不具备的功能。
TSTree的工作方式是，每个键都是字符串，根据字符串中字符的等性，通过构建或者遍历一棵树来进行插入。首先由根节点开始，观察每个节点的字符，如果小于、等于或大于则去往相应的方向。你可以参考这个头文件：
#ifndef _lcthw_TSTree_h #define _lctwh_TSTree_h #include &amp;lt;stdlib.h&amp;gt; #include &amp;lt;lcthw/darray.h&amp;gt; typedef struct TSTree { char splitchar; struct TSTree *low; struct TSTree *equal; struct TSTree *high; void *value; } TSTree; void *TSTree_search(TSTree *root, const char *key, size_t len); void *TSTree_search_prefix(TSTree *root, const char *key, size_t len); typedef void (*TSTree_traverse_cb)(void *value, void *data); TSTree *TSTree_insert(TSTree *node, const char *key, size_t len, void *value); void TSTree_traverse(TSTree *node, TSTree_traverse_cb cb, void *data); void TSTree_destroy(TSTree *root); #endif TSTree拥有下列成员：</description>
    </item>
    
    <item>
      <title>练习47：一个快速的URL路由</title>
      <link>https://cuterwrite.top/TechDocs/docs/c-guide/ex47/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/c-guide/ex47/</guid>
      <description>原文：Exercise 47: A Fast URL Router
译者：飞龙
我现在打算向你展示使用TSTree来创建服务器中的快速URL路由。它适用于应用中的简单的URL匹配，而不是在许多Web应用框架中的更复杂（一些情况下也不必要）的路由发现功能。
我打算编程一个小型命令行工具和路由交互，他叫做urlor，读取简单的路由文件，之后提示用户输入要检索的URL。
#include &amp;lt;lcthw/tstree.h&amp;gt; #include &amp;lt;lcthw/bstrlib.h&amp;gt; TSTree *add_route_data(TSTree *routes, bstring line) { struct bstrList *data = bsplit(line, &amp;#39; &amp;#39;); check(data-&amp;gt;qty == 2, &amp;#34;Line &amp;#39;%s&amp;#39; does not have 2 columns&amp;#34;, bdata(line)); routes = TSTree_insert(routes, bdata(data-&amp;gt;entry[0]), blength(data-&amp;gt;entry[0]), bstrcpy(data-&amp;gt;entry[1])); bstrListDestroy(data); return routes; error: return NULL; } TSTree *load_routes(const char *file) { TSTree *routes = NULL; bstring line = NULL; FILE *routes_map = NULL; routes_map = fopen(file, &amp;#34;r&amp;#34;); check(routes_map !</description>
    </item>
    
    <item>
      <title>“解构 K&amp;R C” 已死</title>
      <link>https://cuterwrite.top/TechDocs/docs/c-guide/postscript/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/c-guide/postscript/</guid>
      <description>原文：Deconstructing K&amp;amp;RC Is Dead
译者：飞龙
我彻底失败了。我放弃了多年以来尝试理清C语言如何编写的想法，因为它的发明是有缺陷的。起初，我的书中有一章叫做“解构 K&amp;amp;R C”。这一章的目的是告诉人们永远不要假设它们的代码是正确的，或者对于任何人的代码，不管它有多出名，也不能避免缺陷。这看起来似乎并不是革命性的想法，并且对我来说它只是分析代码缺陷和编写更好更可靠代码的一部分。
多年以来，我在写这本书的这一块时收到重挫，并且收到了比任何其它事情更多的批评和侮辱。不仅如此，而且书中这部分的批评以这些话而结束，“你是对的，但是你认为他们的代码很烂这件事是错的。”我不能理解，有一群被认为很聪明的人，他们的大脑中充满理性，却坚持“我可以是错的，但是同时也可以是对的”的观点。我不得不与这些学究在C IRC channels、邮件列表、评论上斗争，这包括每一个它们提出一些怪异的、迂腐的刻薄意见的情况，需要我对我的文章进行更多的逻辑性修改来说服他们。
有趣的一点是，在我写这部分之前，我收到了本书许多正面的评论。当时本书还在写作中，所以我觉得确实需要改进。我甚至设置了一些奖金让人们帮助改进。但可悲的是，一旦他们被自己的英雄蒙蔽，所崇拜的基调就发生了翻天覆地的变化。我变得十分令人讨厌，只不过是尝试教人们如何安全使用一个极易出错的垃圾语言，比如C语言。这是我很擅长的东西。
这些批评者向我承认，他们不写C代码也不教授它，他们只是死记硬背标准库来“帮助”其它人，这对我来说并不重要。我以一个开放的心态试图解决问题，甚至设置奖金给那些有助于修复它的人，这也不重要。这可以使更多的人爱上C语言，并且使其它人入门编程，这更不重要。重要的是我“侮辱”了他们的英雄，这意味着我所说的话永远地完蛋了，没有人会再次相信我。
坦率地说，这是编程文化极为的黑暗、丑陋、邪恶的一面。他们整天在说，“我与你们同在”，但是如果你不屈服于大师们海量的学识，以及乞求他们准许你质疑他们所信奉的东西，你突然就会变成敌人。程序员费尽心机地把自己放在权力的宝座上，来要求别人赞许他们高超的记忆能力，或者对一些微不足道的琐事的熟知，并且会尽全力消灭那些胆敢质疑的人。
这非常恶心，我对此也没什么能做的。我对老程序员无能为力。但他们注定会失败。它们通过标准化记忆所积累的学识，也会在咸鱼的下一次翻身中蒸发掉。它们对考虑如何事物的运作方式，以及如何改进它们，或者将它们的手艺传授给他人毫无兴趣，除非这里面涉及到大量的阿谀奉承并让他们觉得很爽。老程序员总会完蛋的。
他们向现在的年轻程序员施压，我对此并不能做任何事情。我不能阻止无能程序员的诽谤，他们甚至根本不像专业的C程序员那样。然而，我宁愿使本书有助于那些想要学习C语言以及如何编写可靠的软件的人，而不是和那些思维闭锁的保守派做斗争。它们贪图安逸的行为给人一种感觉，就是他们知道更多迂腐的、可怜的小话题，就比如未定义行为。
因此，我删除了书中的K&amp;amp;R C部分，并且找到了新的主题。我打算重写这本书，但是并不知道如何去做。我犹如在地狱中，因为我自己非常执着于我觉得很重要的一些事情，但我不知道如何推进。我现在算是明白了这是错的，因为它阻碍我将一些与C不相关的重要技巧教给许多新的程序员，包括编程规范、代码分析、缺陷和安全漏洞的检测，以及学习其它编程语言的方法。
现在我明白了，我将为这本书制作一些课程，关于编写最安全的C代码，以及将C语言代码打破为一种学习C和编程规范的方式。我会卑微地说我的书只是一个桥梁，所有人应该去读K&amp;amp;R C来迎合这些学究，并且在这些黄金法则的脚下顶礼膜拜。我要澄清我的C版本限制于一个固定的目的之中，因为这让我的代码更安全。我一定会提到所有迂腐的东西，比如每个书呆子式的，关于20世纪60年代的PDP-11电脑上空指针的要求。
之后，我会告诉人们不要再去写别的C程序。这不会很明显，完全不会，但我的目标是将人们从C带到能更好地编程的其它语言中。Go、Rust或者Swift，是我能想到的能处理C语言主要任务新型语言，所以我推荐人们学习它们。我会告诉他们，他们的技能在于发现缺陷，并且对C代码的严格分析将会对所有语言都有巨大的好处，以及使其它语言更易于学习。
但是C呢？C已经死了，它是为想要争论A.6.2章第四段的指针未定义行为的老程序员准备的。谢天谢地，我打算去学习Go（或者Rust，或者Swift，或者其它任何东西）了。</description>
    </item>
    
    <item>
      <title>捐赠名单</title>
      <link>https://cuterwrite.top/TechDocs/docs/c-guide/donors/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/c-guide/donors/</guid>
      <description>感谢以下童鞋的捐助，你们的慷慨是我继续的动力：
donor value jxdwinter 6.00 贾**@悠云.com 20.00 Mr.Moon 2.00 </description>
    </item>
    
    <item>
      <title>A. 欢迎参赛</title>
      <link>https://cuterwrite.top/TechDocs/docs/hpcgame-0/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97%E7%AE%80%E4%BB%8B/1a/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/hpcgame-0/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97%E7%AE%80%E4%BB%8B/1a/</guid>
      <description>欢迎参赛 link欢迎参加第零届北京大学高性能计算综合能力竞赛！
点击题目列表上方“进入超算平台”按钮即可登入 SCOW 平台。我们为每位选手预充值了一些金额，以方便大家的使用。
如果需要在线编写和调试程序，我们推荐使用在线 VSCode。您可以在 SCOW 平台上打开“交互式应用”，并创建一个 VSCode 应用，然后点击连接即可。请注意，默认情况下一小时后打开的实例会被自动销毁。在创建交互式应用时，保持页面的默认配置即可（分区：compute，核心数：1）。
您也可以选择使用在线 Shell 进行程序的编写和调试，但是我们提倡：不要在登录节点上运行大型计算任务。您可以通过 SCOW 的文件管理功能进行文件的上传和下载。您放在您家目录（/data/home/您的SCOW用户名（注意：和您的用户名、用户ID并不相同））内的文件将在所有集群内的机器上可见。交互式应用的销毁并不会导致您家目录内文件的丢失，但是我们仍提倡定期将集群内保存的代码等文件下载到本地。我们不对该集群上任何数据丢失负责。
如何使用 GPU：在分区 GPU （大写）即可使用 GPU，记得在分配任务时需要指定 --gres=gpu:1，从而分配一块 GPU。
关于本题 link本题意图祝愿大家在本次比赛中取得良好成绩，所以获得本题的分数也十分容易。您只需下载集群中的 /data/hpcgame/bonus/bonus.dat 并提交，即可获得本题的全部分数！</description>
    </item>
    
    <item>
      <title>B. 实验室的新机器</title>
      <link>https://cuterwrite.top/TechDocs/docs/hpcgame-0/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97%E7%AE%80%E4%BB%8B/1b/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/hpcgame-0/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97%E7%AE%80%E4%BB%8B/1b/</guid>
      <description>题面 link小北实验室最近新购置了几台服务器，供日常实验数据分析使用。为了让大家都能合理且方便地运用这些机器，你在它们上面安装了 slurm 和 SCOW，大家都使用得很开心。
李华今年刚加入小北实验室。他的日常工作需要分析大量数据。李华撰写了一个程序，专门用于分析他的这些数据。他使用他的笔记本运行这个程序。但是，李华发现，随着研究的不断深入，他需要分析的数据也越来越复杂；终于有一天，李华的笔记本“罢工”了——它所使用的“火龙一号”处理器在持续不断的满负荷工作过程中产生了过量的热，导致自己处于被烧毁的边缘，触发了“罢工”的保护机制。
于是，李华申请了实验室服务器账号，接下来他便可以把他的程序运行在实验室服务器上，他的笔记本也可以得到良好的休息。这将为他省下一大笔修理费用。
但是李华发现，每次在集群上运行自己的程序都需要先输入一堆与 slurm 有关的命令，他觉得这有些繁琐，希望你能帮他编写一个脚本，运行这个脚本以后，就会自动地创建 Job 、分配资源并运行李华的程序，在程序运行完成之后还会留存该程序运行的资源消耗情况。
你看在李华这次承诺不再需要你为他撰写一封收件人是你自己的感谢信的份上，决定帮他这个忙。
提交要求 link请你提交一个脚本文件（允许的格式：Shell 脚本或 Python 脚本），它需要满足如下要求：
在文件头部具有一个 Shebang，用于表明如何运行该脚本（例子：对于一个 Bash 脚本来说，通常为 #!/bin/bash） 该脚本需要完成如下工作： 在计算节点上运行李华的程序（./program），这个程序接收一个命令行参数，在调用你撰写的脚本时，也会传入这个参数，如果你编写 Shell 脚本，可以使用 $1 来访问；计算节点应位于 compute 分区，配置为一个机器、一个核心（-N1 -n1 -c1） 将程序的输出重定向到 output.dat 使用 seff 命令查看运行这个 Job 的资源使用情况，并将输出重定向到 seff.dat 注：李华不会使用 sbatch，所以你的程序是直接在登录节点上被执行的！
提示 link 为了降低你的工作量，李华的程序会获取 Slurm Job ID 并输出至 job_id.dat 文件。 李华的程序不会输出至 stderr，只会输出至 stdout。 在 Shell 脚本中，将一个文件的内容作为命令参数的部分方式： 使用类似 command_name &amp;quot;$(cat filename.dat)&amp;quot; 的方式 使用类似 cat filename.dat | xargs command_name 的方式 </description>
    </item>
    
    <item>
      <title>C. 小北问答超速版</title>
      <link>https://cuterwrite.top/TechDocs/docs/hpcgame-0/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97%E7%AE%80%E4%BB%8B/1c/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/hpcgame-0/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97%E7%AE%80%E4%BB%8B/1c/</guid>
      <description>背景 link小 A 热衷于小北问答。但是小 A 觉得手工判卷太慢了。于是小 A 学会了 YAML 并试图实现自动评分。小 A 把它称作“小北问答·超速版”。他想要测试自己编写的自动评分系统正不正确，于是出了一套题，让你来帮忙试一试。
据你所知，“超速”的含义是小 A 把这套自动评分程序运行于超算上。
小 A 的题目 link TOP500中能效最高的超算是哪一台？（回答一个单词）
戈登贝尔奖是并行计算领域的最高奖项，戈登贝尔奖设立在哪一年？（回答一个数字）
一般来说，服务器使用的 CPU 相比于同代同等级的游戏 CPU，核心更 （ ）（填多 / 少），多核性能更（ ）（填强 / 弱）
一般来说，服务器使用的 CPU 相比于同代同等级的游戏 CPU，单核最高频率更 （ ）（填高 / 低），因此起单核性能更 （ ）（填强 / 弱）
5~7 题：对如下实现的矩阵乘法 C[M][N] = C[M][N] + A[M][K] * B[K][N] ​, 假设单位内存是1：（均填写含 N 的表达式，可以使用 +-*/ 运算符、小括号和 pow(a, b)，sqrt(n) 函数，等价形式均可），内存写策略是直写，全相联（块大小是1），替换策略是LRU。
for m in [1, N]: for n in [1,N]: for k in [1, N]: C[m,n] = C[m,n] &amp;#43; A[m, k] * B[k, n] 对矩阵A, B, C均进行了（ ）次读，对C进行了（ ）次写。</description>
    </item>
    
    <item>
      <title>D. 简单题</title>
      <link>https://cuterwrite.top/TechDocs/docs/hpcgame-0/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97%E7%AE%80%E4%BB%8B/1d/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/hpcgame-0/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97%E7%AE%80%E4%BB%8B/1d/</guid>
      <description>题面 linkHint: mmap写入空文件的处理方式：https://stackoverflow.com/questions/44553907/mmap-sigbus-error-and-initializing-the-file
不要惊慌。你没有看错，这就是一道简单题。
啊偶，虽然在某些比赛中，被标注为“简单题”的题目往往并不简单，但是在这场比赛中，我们确实试图提供一些简单题，以让大家能够更容易地获得更多分数。
你需要用 P 个核心，把 N 个 32 位有符号整数数组中所有元素 + 1，并且求原来（未加一）的数字之和(MOD 100001651)并输出。
输入 link从 input.bin 读入。这是一个二进制文件，用小端法储存储存，可以直接进行内存映射。（题目保证这些数字小于 230）
第一个参数是核心数 P ，表示当前程序运行平台的核心数。第二个参数是 N ，表示数据总数（在32位整数表示范围内）。
输出 link输出到 output.bin。也是一个二进制文件，建议直接内存映射写入。
第一个数字是求和取模的结果，后面的数字是修改后的数组。
提交 link提交一个 C++ 源程序即可。
编译命令：
g&amp;#43;&amp;#43; -o solution solution.cpp -O1 -fopenmp -std=c&amp;#43;&amp;#43;11 一个可能有用的数据生成器 link #!/usr/bin/php &amp;lt;?php if ($argc != 4) { die(&amp;#34;USAGE: {$argv[0]} &amp;lt;OUTPUT_PATH&amp;gt; &amp;lt;P&amp;gt; &amp;lt;N_RANGE&amp;gt;\n&amp;#34;); } function i32_to_bytes(int $n): array { $rslt = []; for ($i = 0; $i &amp;lt; 4; &amp;#43;&amp;#43;$i) { $rslt[] = $n &amp;amp; 255; $n &amp;gt;&amp;gt;= 8; } return $rslt; } function bytes_to_string(array $n): string { $a = array_map(fn (int $num) =&amp;gt; chr($num), $n); return join(&amp;#39;&amp;#39;, $a); } function i32_to_string(int $n): string { return bytes_to_string(i32_to_bytes($n)); } $f = fopen($argv[1], &amp;#34;w&amp;#34;); $p = (int) $argv[2]; $n = (1 &amp;lt;&amp;lt; ((int) trim($argv[3]))); $n &amp;#43;= $n &amp;#43; rand(0, $n / 2); $part = 1; $n = floor($n / $part) * $part; echo &amp;#34;p={$p}, n={$n}&amp;#34; .</description>
    </item>
    
    <item>
      <title>A. 求积分！</title>
      <link>https://cuterwrite.top/TechDocs/docs/hpcgame-0/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%A4%A7%E8%A7%84%E6%A8%A1/2a/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/hpcgame-0/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%A4%A7%E8%A7%84%E6%A8%A1/2a/</guid>
      <description>题目 link小明对高等数学感到头疼。今天，他的作业里有一道计算积分的题目。他不知道自己的答案正不正确。他希望你能写一个程序，计算得越准确越好。由于他对于精度的要求非常高，又不希望等待程序运行花费太多时间，所以他将会把程序运行于超算上。你需要使得你编写的程序支持多线程处理从而提升处理速度。
小明遇到的题目转化为离散形式是这样的：
给定函数 $f(x)$ , 正整数 $N$ , 计算 $I_N(f)$ , 其中
$$ \int_0^1 f(x)\approx I_N(f)=\frac{1}{N}\sum_{i=1}^Nf(\frac{x^i}{N})， x_i=i-\frac{1}{2} $$
小明听说有个叫 OpenMP 的东西，能方便地帮助你编写并行的应用程序。你决定试一试。
输入格式 link文件引用 rhs.h，该头文件定义了：
void rhs(double &amp;amp;x, double &amp;amp;value); 即为提供的 f(x)。其中，x 将作为变量 x，函数将把 f(x) 函数值放入 value。
程序需要接收一个命令行参数，即为 N。
输出格式 link向文件 output.dat 中输出一个浮点数，通常可选择保留 12 位有效数字。与标准解答误差在 N⋅10−15 以内即算作正确。
样例数据 linkrhs.cpp
#include &amp;lt;cmath&amp;gt; #include &amp;#34;rhs.h&amp;#34; void rhs(double &amp;amp;x, double &amp;amp;value) { value = x; } rhs.h
#ifndef _rhs_h_ #define _rhs_h_ void rhs(double &amp;amp;, double &amp;amp;); #endif 样例输入：1</description>
    </item>
    
    <item>
      <title>B. 乘一乘！</title>
      <link>https://cuterwrite.top/TechDocs/docs/hpcgame-0/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%A4%A7%E8%A7%84%E6%A8%A1/2b/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/hpcgame-0/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%A4%A7%E8%A7%84%E6%A8%A1/2b/</guid>
      <description>题目 link小明对线性代数也感到头疼。今天，他的作业里有一道计算矩阵乘法的题目。他不知道自己的答案正不正确。他希望你能写一个程序，计算得越准确越好。由于他对于精度的要求非常高，又不希望等待程序运行花费太多时间，所以他将会把程序运行于超算上。你需要使得你编写的程序支持多线程处理从而提升处理速度。
小明遇到的题目是这样的：
给定矩阵 A,B, 满足 A 列数与 B 行数相等, 计算 AB.
小明再次向你介绍有个叫 OpenMP 的东西，能方便地帮助你编写并行的应用程序。你向他表明你在帮助他完成数学分析作业的时候，已经熟练运用了 OpenMP，并希望他下次能问你一些物理问题。
输入格式 link文件引用 rhs.h，该头文件定义了：
void matA(unsigned int &amp;amp;i, unsigned int &amp;amp;j, double &amp;amp;value); void matB(unsigned int &amp;amp;i, unsigned int &amp;amp;j, double &amp;amp;value); 设矩阵 A 为 ${a_{ij}​}$ ，矩阵 B 为 ${b_{ij}​}$ ，那么调用这两个函数将分别给出矩阵 A 和 B 第 i 行第 j 列的元素的值。函数将把值放入 value。
程序需要接收三个命令行参数，即为 N1, N2, N3，表示矩阵 A 是 N1*N2 维的，矩阵 B 是 N2*N3 维的。
输出格式 link向文件 output.dat 中输出结果矩阵，每行一个浮点数，按如下方式排布：（以 3x3 矩阵为例）</description>
    </item>
    
    <item>
      <title>C. 解方程！</title>
      <link>https://cuterwrite.top/TechDocs/docs/hpcgame-0/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%A4%A7%E8%A7%84%E6%A8%A1/2c/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/hpcgame-0/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%A4%A7%E8%A7%84%E6%A8%A1/2c/</guid>
      <description>题目 link小明这回的确问了个“物理”些的问题。虽然依旧是一个数学问题。他还是希望你能编写一个程序，帮他解决这个问题。他依旧想把你的程序运行在超算上，并要求你的程序是并行的。
给定函数 $f(x,y)$ , 正整数 $N$ , 在 $N×N$ 均匀网格上用五点格式求解 Poisson 方程
$$ \begin{cases} &amp;amp; -\Delta u(x,y)=f(x,y),(x,y)\in \Omega = (0,1)^2 \\ &amp;amp; u(x,y)=0,(x,y)\in \partial \Omega \end{cases} $$ 记 $U_{i,j}$​ 为 $u(x_i,y_j​)$ 的近似值, 离散格式为
$$ \begin{aligned} &amp;amp;4U_{i,j}-U_{i-1,j}-U{i&amp;#43;1,j}-U_{i,j-1}-U{i,j&amp;#43;1}=\frac{1}{N^2}f(x_i,y_i),x_i=\frac{i}{N},y_i=\frac{j}{N}\\ &amp;amp; U_{i,j}=0,(i=0)\lor(i=N)\lor(j=0)\lor(j=N) \end{aligned} $$ 用 Gauss-Seidel 迭代求解上述线性方程组。
小明定义了一个量，名叫 EPS（各分量绝对值差最大值）。他希望你的程序能在 EPS 小于 10−15 后输出结果。
你看着题目苦笑了一下。如你所料，小明总是念念不忘他的 OpenMP。
输入格式 link文件引用 rhs.h，该头文件定义了：
void rhs(double &amp;amp;x, double &amp;amp;y, double &amp;amp;value); 该函数即为 f(x,y)。传入 x, y, value, 那么 f(x,y) 就会被保存到 value 内。</description>
    </item>
    
    <item>
      <title>D. 道生一</title>
      <link>https://cuterwrite.top/TechDocs/docs/hpcgame-0/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%A4%A7%E8%A7%84%E6%A8%A1/2d/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/hpcgame-0/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%A4%A7%E8%A7%84%E6%A8%A1/2d/</guid>
      <description>题面 link道生一，一生二，二生三，三生万物。
我们给你选择了三个“魔力数字”genA, genB, genC，请你使用这三个数生成n个“随从数字”并排序，得到data数组。经过对data数组的计算，你会得到一个归一数，把这个数输出到标准输出即可。 （本题中的所有数字都是64位无符号整数。）
输入 link从标准输入中读入四个数字，分别是genA, genB, genC,n 。
输出 link输出一个归一数到标准输出，生成方式见下文。
数据生成与测试 link #define data_t unsigned long long /*data数组的生成的示意代码如下：*/ data_t gen_next(){ gen_A ^= gen_A &amp;lt;&amp;lt; 31; gen_A ^= gen_A &amp;gt;&amp;gt; 17; gen_B ^= gen_B &amp;lt;&amp;lt; 13; gen_B ^= gen_B &amp;gt;&amp;gt; 5; gen_C &amp;#43;&amp;#43;; gen_A ^=gen_B; gen_B ^= gen_C; return gen_A; } void data_init(){ scanf(&amp;#34;%llu%llu%llu%llu&amp;#34;, &amp;amp;gen_A, &amp;amp;gen_B, &amp;amp;gen_C, &amp;amp;n); a = (data_t *) malloc(sizeof(data_t) * n); for (data_t i = 0 ; i &amp;lt; n; i &amp;#43;&amp;#43;) { a[i] = gen_next(); } } /*归一数的计算方式如下：*/ data_t get_res(data_t *a,data_t n){ for (data_t i = 0,tmp; i &amp;lt; n; i &amp;#43;&amp;#43;) for (data_t j = 0; j &amp;lt; n - 1 - i; j &amp;#43;&amp;#43;) { if (a[j] &amp;gt; a[j &amp;#43; 1]) { tmp = a[j]; a[j] = a[j&amp;#43;1]; a[j&amp;#43;1] = tmp; } } data_t res = 0; for (data_t i = 0; i &amp;lt; n; i &amp;#43;&amp;#43;) { res ^= i * a[i]; } return res; } #undef data_t 其中i * a[i]的溢出处理方式是低64位截断。</description>
    </item>
    
    <item>
      <title>E. 卷？寄！</title>
      <link>https://cuterwrite.top/TechDocs/docs/hpcgame-0/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%A4%A7%E8%A7%84%E6%A8%A1/2e/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/hpcgame-0/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%A4%A7%E8%A7%84%E6%A8%A1/2e/</guid>
      <description>背景 link二维卷积是卷积神经网络的基础操作，可以提取数据特征，在图像识别领域应用广泛。卷积的复杂度导致训练困难，也是图像识别领域的重要瓶颈之一。
对卷积感兴趣的同学，可以去翻一翻 Ian Goodfellow 等人写的 Deep Learning 的第 9 章。我们只引用书中的一张图介绍卷积的计算。
对于矩阵 Input，我们使用一个比它规模小的多的 Kernel 进行运算。本题我们方法大概是这样：
设 Input 是 A∗B 矩阵，Kernel 是 C∗D 矩阵，对于每个位置 (i, j) ，如果可以取一个和 Kernel 大小一样的不越界矩阵(本题不考虑 padding)，我们就把这个矩阵中与 Kernel 中对应元素乘起来并求和，结果放在 Output(i,j) ​中。
$$ \left[ \begin{array}{cccc} I_{(i,j)} &amp;amp; I_{(i,j)} &amp;amp; \cdots &amp;amp; I_{(i,j&amp;#43;D)} \\\ I_{(i&amp;#43;1,j)} &amp;amp; I_{(i&amp;#43;1,j&amp;#43;2)} &amp;amp; \cdots &amp;amp; I_{(i&amp;#43;1,j&amp;#43;D)} \\\ \cdots &amp;amp; \cdots &amp;amp; \cdots &amp;amp; \cdots \\\ I_{(i&amp;#43;C,j)} &amp;amp; I_{(i&amp;#43;C,j&amp;#43;2)} &amp;amp; \cdots &amp;amp; I_{(i&amp;#43;C,j&amp;#43;D)} \\\ \end{array} \right] $$ 计算完所有可算的 i, j ，我们就得到了卷积的输出。</description>
    </item>
    
    <item>
      <title>F. MPI 算个 PI</title>
      <link>https://cuterwrite.top/TechDocs/docs/hpcgame-0/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%A4%A7%E8%A7%84%E6%A8%A1/2f/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/hpcgame-0/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%A4%A7%E8%A7%84%E6%A8%A1/2f/</guid>
      <description>前情提要 link本题是简单题，不想读背景的大佬请直接跳到题目要求。
背景 link几乎从人类数学诞生以来，一代代数学家就在试图提高圆周率π的数值精度。从五千年前的 1 位精度提升到当下世界纪录的 100 万亿位，π的计算方法从粗略估计、测量估算，再到公式逼近、机器演算，我们可以从中看到人类科技的发展史。
当下，π的计算还是衡量高性能计算集群性能和算法优越性的重要量度，问题的维度从单纯的计算，拓展到了储存、通信、内存瓶颈等方方面面，各路超算纷纷借此机会大秀肌肉。
但是在这一系列浩浩汤汤的计算过程中，有一小群人，在个人电脑刚刚普及的年代，却凭借着合作的力量，通过众包计算的方法，也达到了可喜的成就。其中一个项目是，通过分布式的方法，计算出了π中特殊位置数字的PiHex。在个人算力不足的年代，这可谓是工程学奇迹。
现在我们假设你有一些算力不是很强的机器，来模拟这个场景。
题目要求 link你有 5 个物理节点，每个的节点 2 个核心。你需要写一个MPI 程序，计算π的近似值，精确到 1∗10−14（15 位有效数字）。
因为 MPI 开销比较大，本题时间限制为 30 秒，不考察效率。（其实就是想让大家试一试MPI)
请注意，我们的平台关闭了超线程，但是直接由MPI 生成的线程数可能会是打开超线程后的。
输入输出 link输入：无
输出：一个双精度浮点数，保留 15 位有效数字。输出到output.txt 即可。如果只有 13 位有效数字，则得一半分。
编译命令 link（运行 mpi.tar 中的 compile.sh 即可）
module load mpi/2021.8.0 mpicc cpi.c -lm -o cpi 运行命令 link（运行 mpi.tar 中的 run.sh 即可）
salloc -p compute -N5 --ntasks-per-node=2 -c 1 -q normal module load mpi/2021.8.0 srun -c 1 hostname -s | sort -n &amp;gt; slurm.</description>
    </item>
    
    <item>
      <title>A. 从头开始造 AI</title>
      <link>https://cuterwrite.top/TechDocs/docs/hpcgame-0/gpu%E4%B8%8A%E7%9A%84%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/3a/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/hpcgame-0/gpu%E4%B8%8A%E7%9A%84%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/3a/</guid>
      <description>Section 1 Can you train a simple neural network using Pytorch? linkIn this section, you need to complete the code of Pytorch.ipynb. You can see more tutorials and details in the file. We will check the completion and correctness of your code in this section.
Section 2 Can you differentiate a weed from a crop seedling? linkWith the network training experience, we can solve a lot of interesting problems and let&amp;rsquo;s try one of them in this section.</description>
    </item>
    
    <item>
      <title>B. 神奇的焦散</title>
      <link>https://cuterwrite.top/TechDocs/docs/hpcgame-0/gpu%E4%B8%8A%E7%9A%84%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/3b/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/hpcgame-0/gpu%E4%B8%8A%E7%9A%84%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/3b/</guid>
      <description>任务背景 link焦散是光线经过透明物体后在某些位置汇聚形成的图案，因为其空间频率远高于单纯漫反射下的明暗，在渲染时需要较大的计算量。考虑一个简单的场景，一束方形截面的平行单色光经过若干方向玻璃板照在方形屏幕上。在这个场景中，只需要采样平行光最终到达屏幕的位置，即可得到焦散图案。
物理模型 link这里我们假设玻璃板会让经过的光线发生不均匀的相位落后，从而向不同方向折射，为了简化计算，忽略玻璃板的厚度。相位落后由多个定义在半径为r的圆形区域内的，最大值为d的旋转对称模板函数相加。 模板函数具有如下形式
$$ f(t=\frac{\sqrt{x^2 + y ^2}}{r})=d * exp(-\frac{4t^2}{1-t^2}) $$
样例程序中包含计算模板函数梯度的部分，可以根据自己的需要修改。
输入与输出 link题目数据量较大，因此将使用读写二进制文件的输入输出方式。处理输入输出的代码已经包含在样例程序中，可以根据自己的需要修改。
任务目标 link你需要适当修改提供的在cpu上进行计算的样例程序，使其运行在gpu上。如果你直接提交样例程序虽然能够获得正确的结果但会运行相当长的时间。样例程序中会包含一个没用的kernel，用于证明这个程序确实在gpu上运行了。
务必确保全程使用单精度浮点计算，允许的误差仅考虑到GPU与CPU浮点运算差异，单双精度浮点差别远大于此。
有用的信息 linkr在0.05到0.10的范围内随机分布
模板函数中心位置在方形区域内随机分布
可以使用int atomicAdd(int* address, int val);进行计数。
编译命令nvcc -O3
运行在单核，八分之一个A100上
共两个测试点：
测试点 ID 玻璃板数量 每个玻璃板上的模板函数数量 采样数量 输出像素 分值 0 2 256 4096*4096 256*256 10 1 32 256 16384*16384 1024*1024 190 附件中提供一份输入文件，可以用于本地调试。
评分标准 link如果能在目标时间内得到正确的焦散图案可以得到基本分。
运行时间越短得到的附加分越高。
样例程序 link #include &amp;lt;malloc.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdlib.h&amp;gt; struct lens_t { float x, y, r, d; }; struct pane_t { int panecount; float* panepos; int* lensindex; lens_t* lensdata; }; struct result_t { int raydensity; int sensordensity; int* sensordata; }; __global__ void ker_test(float* x, int n) { int i = blockDim.</description>
    </item>
    
    <item>
      <title>C. cuFFT 并非不可战胜！</title>
      <link>https://cuterwrite.top/TechDocs/docs/hpcgame-0/gpu%E4%B8%8A%E7%9A%84%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/3c/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/hpcgame-0/gpu%E4%B8%8A%E7%9A%84%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/3c/</guid>
      <description>背景介绍 link密度泛函理论（Density Functional Theory，简称 DFT ）在材料计算，医药和分子化学等领域扮演着重要的角色，是微观世界建模的重要工具。在高性能计算技术与机器学习方法飞速发展的今天，理论计算有望更快速地突破科学边界，解决更多的实际问题。密度泛函理论兼具效率与精度，正在释放出巨大的潜力。
ABACUS 作为积淀深厚的国产开源密度泛函计算软件，致力于结合高性能计算和机器学习方法，推动电子结构新算法的发展和普及，为更多科研人员、老师和学生们提供更方便易用的免费开源软件，为更多开发者提供一个框架清晰、方便上手的开发平台，努力将第一性原理方法打造成面向实际应用场景的解决方案。
在 ABACUS 等 DFT 软件计算中有一个很重要的倒易空间到实空间的转换，涉及到快速傅里叶算法也就是 FFT。不过这个转化和通常的 FFT 不同，它带有一定的稀疏性。我们可以将在倒易空间需要变换的数据视为是一个球体，这个球体位于一个三维的正立方体中，球体直径小于等于立方体边长的一半，立方体其他部分置零，然后将整个立方体输入到 FFT 中进行变换得到实空间数据。但受限于接口问题目前只能应用 cuFFT 或者 FFTW 等成熟的库，没法有效利用数据的稀疏性。在实际计算中，FFT 的计算占比达 30%以上，是一个相当大的计算瓶颈。我们以 ABACUS 为基础，将相关问题抽象出来，提供了一个物理意义无关的优化问题模型。
赛题描述 link考虑立方体$D$，定义其边长为 $c$ ，球 $R$ 为 $D$ 中的一个球体，球的半径为 $r$ ， $r\leq c/4$ 。
为简化起见，考虑 $D$ 和 $R$ 的中心重合位于原点处。注意：这里边长都是整数，格点位于每个整点处，若长度为 $m$ ，则格点数为 $m+1$ 。若边长为奇数，则原点分布于正中间，若边长为偶数，则自动扩充边长为变长 +1 。
FFT 输入数据示意图，仅有彩色球体为有效数据，其余部分置为零。
输入 link 立方体边长 $c$ 球体半径 $r$ 三维复数数据 $A$ ， $A$ 的大小为 $c^3$ ，以一维数组形式连续存储。 $A$ 的初始化说明如下： 遍历 A 中的数据元素 P(x,y,z) ; 如果 P 到球心距离小于半径 r，则 P=random_complex ; 否则 P 置零。 输出 link A 经过逆傅里叶变化后的输出数组 B。 其中，A 是频域空间，B 是时域空间。</description>
    </item>
    
    <item>
      <title>A. 走，我们扫雷去</title>
      <link>https://cuterwrite.top/TechDocs/docs/hpcgame-0/%E7%BB%BC%E5%90%88%E5%BA%94%E7%94%A8%E6%8F%90%E5%8D%87/4a/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/hpcgame-0/%E7%BB%BC%E5%90%88%E5%BA%94%E7%94%A8%E6%8F%90%E5%8D%87/4a/</guid>
      <description>题目背景 link你很喜欢玩扫雷。
在游戏“扫雷”中，你面对的是一个由若干方格组成的矩阵，每个方格中可能有一颗地雷，也可能没有地雷。
你的基本操作名叫“点开”。每一次，你可以选择一个格子并“点开”它，如果它是地雷，那么你的分数会被扣掉一些，如果它不是地雷，那么你会获得一分，并且会有一个数字显现在方格上，这个数字代表着周围的的八个方格（上、下、左、右、左上、左下、右上、右下）中一共有多少颗地雷（数字为 0 到 8）。如果点开的方格中的数字为 0（这代表这个方格周围的八个方格都不是地雷），那么它周围的方格也会被自动“点开”（这个过程可以递归，也即，如果新的方格中的数字也是 0，那么它周围的八个方格也会被自动“点开”。我们称其为“间接点开”，相对应的，被玩家直接点开的格子称为“直接点开”）。当玩家主动退出，或者时间耗尽后，游戏结束。
请注意，本题的扫雷与标准的扫雷有一些区别：
在标准的扫雷中，点开一个包含地雷的方格后，游戏会立刻失败 当玩家程序点开所有非地雷方格后，游戏不会自动结束，需要玩家程序主动退出。 每次“点开”一个包含数字 0 的格子时，你的程序会收到点开的格子所在的连通块中的所有数字为 0 的格子以及边缘那些数字不为 0 的格子，哪怕这些格子已经被点开过。这个在后文有具体的描述。 下面是 KDE 桌面系统中的“扫雷”游戏的例子（红色的小旗子代表这个方格中有地雷，空白的格子表示格子中的数字为 0）：
经过夜以继日的练习后，高级版扫雷的 30×16 的地图规模对你来说已经是小菜一碟。于是，你决定玩点刺激的。比如，65536×65535 的扫雷？
当然，如此大规模的扫雷肯定不能手工完成。于是，你打算把毕生所学融入到一个程序中，让这个程序来自动化地扫雷。
题目描述 link你需要写一个（可能是并行的）程序，与我们提供的扫雷 game server 交互。
你可以使用下列库函数来与 game server 交互：
void minesweeper_init(int &amp;amp;N, int &amp;amp;K, int &amp;amp;constant_A); 在程序开始前，请调用此函数来初始化程序。这个函数会把地图的边长 N 存放在变量 N 中，把地图中的雷的数量 K 存放在变量 K 中，将评分参数 A（详见下文）存放在变量 constant_A 中。
Channel create_channel(void); 请使用此函数创建一个用于和 game server 通信的 Channel 对象。保证不同的 Channel 之间互不干扰，但若有两个进程 / 线程同时操作同一个 Channel，那么大概率会出错。所以建议为每个进程 / 线程单独开一个 Channel。</description>
    </item>
    
    <item>
      <title>B. AI算子优化</title>
      <link>https://cuterwrite.top/TechDocs/docs/hpcgame-0/%E7%BB%BC%E5%90%88%E5%BA%94%E7%94%A8%E6%8F%90%E5%8D%87/4b/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/hpcgame-0/%E7%BB%BC%E5%90%88%E5%BA%94%E7%94%A8%E6%8F%90%E5%8D%87/4b/</guid>
      <description>Problem linkYou&amp;rsquo;ve entered an AI laboratory in a university.
There are many commonly used operators in the field of deep learning, and what you need to do today is to optimize three of them.
The code of your project is included in problem attachments.
matmul linkCalculate the result of multiplying two 2D matrices.
You can modify the macro MM_KERNEL_SIMPLE in /src/math/matmul_simple.c to optimize the operator.
If you want to test the operator yourself, you can run this</description>
    </item>
    
    <item>
      <title>C. RDMA就是快</title>
      <link>https://cuterwrite.top/TechDocs/docs/hpcgame-0/%E7%BB%BC%E5%90%88%E5%BA%94%E7%94%A8%E6%8F%90%E5%8D%87/4c/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/hpcgame-0/%E7%BB%BC%E5%90%88%E5%BA%94%E7%94%A8%E6%8F%90%E5%8D%87/4c/</guid>
      <description>问题描述 linkTCP/IP 协议基于软件协议栈传输的这种方式已经无法适应高速数据传输的需求，成为网络性能进一步增长的瓶颈，特别是应用数据在用户态和内核态之间的拷贝带来ms级的延时，协议栈对数据包的解析、寻址、校验等操作需要消耗大量CPU资源。为此，RDMA技术替代了传统的TCP/IP软件协议栈的设计。RDMA的全称是远程直接内存访问（remote direct memory access），它在硬件上实现了kernel bypass技术，数据不需要经过软件协议栈，并且不需要CPU参与寻址、解析等操作，从而提供低延时、高带宽、低CPU使用的性能优势。
然而，想要充分挖掘RDMA的性能优势并不是一个容易的任务。我们这里假设一个最简单的场景：有一个数据生产者producer与一个数据消费者consumer，生产者不断给consumer发送数据。我们在附件提供了一个样例程序。该样例程序包含了producer与consumer的实现。作为参赛者，你需要进一步优化该样例程序，以达到更大的传输性能。注意，参赛者的最终提交不能修改其中的farm_cons.cpp与farm_prod.cpp（改了也没用），其余文件都可以自由改动.。
你可以做的事情包括但不限于: 对原有的ringbuffer进行常数优化；调整原有ringbuffer的参数；调整RDMA的传输参数与设置以适应应用场景；利用RDMA原语自由设计新的数据结构。
（你也可以到 https://github.com/N2-Sys/rdma-ringbuffer-demo 去看未经比赛工作组修改的程序）
你主要需要关注的文件是farm.h与farm.cpp。common.cpp包含一些rdma与ringbuffer的通用接口，你也可以复用或改动其中的代码。注意，如果需要深入改动代码，你最好对RDMA编程有一些基本的了解，我们提供了一些参考资料。
提示： link大包已经快接近物理极限了，主要是小包优化。
评测环境ib卡的max_mtu是4096KB
测试方法 link测试分为若干轮。每一轮都会传输多个message，message大小随着轮数逐渐增大，是以64B为首项，8为公比直至1MB的等比数列。每一轮传输的数据总量为25GB，每个点时间越少，分数越高。
具体来说：你的得分由你程序的加速比确定，可以参考下表：
Size ZeroScoreSpeed(MiB/s) FullScoreSpeed(MiB/s) Score 64 104 1044 40 512 860 4304 40 4096 5746 8650 40 32768 10222 11500 10 262144 9730 11000 10 1048576 7015 10500 10 另有10分的满分奖励
提交方法 link你需要保留初始工作区的架构，修改其中文件。
将你的答案打包成zip后提交，请注意：所有文件必须放在压缩文件的根下。我们将编译你的程序，进行测试。
具体解释：什么叫所有文件必须放在压缩文件的根下：
压缩文件不包括子目录，直接解压就得到文件，目录结构举例：
- include/ - farm_prod.cpp - farm_cons.cpp - farm.cpp - common.cpp - cmake/ - CMakeLists.txt 而不是：
- rdma - include/ - farm_prod.</description>
    </item>
    
    <item>
      <title>A. 共轭梯度法</title>
      <link>https://cuterwrite.top/TechDocs/docs/hpcgame-0/%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E9%A2%98%E7%9B%AE/finala/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/hpcgame-0/%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E9%A2%98%E7%9B%AE/finala/</guid>
      <description>背景介绍 link在各类数值模拟计算问题中，求解线性方程是一个非常常见且重要的步骤。比如在流体数值计算（CFD）中，我们常常需要求解一个关于流体压力的泊松类型问题：
$$ \frac{\delta t}{\rho}\nabla p = \nabla \cdot \vec {u} $$
其中方程的左边是一个压力场 $p$ 的二阶导数，而右边是速度场（矢量）的散度。通常我们想要在已知速度场的情况下，求解其对应的压力场 $p$ ，在特定的网格设定下，我们可以使用有限差分的方法我们可以将上面的微分方程转化为线性方程组。比如，下图演示了一个流体数值模拟中常用的，将压力存储在网格中心，将速度存储在网格界面上的离散形式：
其对应的离散化方程式是：
$$ \frac{\delta t}{\rho}\left[\frac{1}{dx}\cdot \left(\frac{p_{i+1,j}-p_{i,j}}{dx} - \frac{p_{i,j}-p_{i-1,j}}{dx} \right) + \frac{1}{dy} \cdot \left( \frac{p_{i,j+1}-p_{i,j}}{dy} - \frac{p_{i,j}-p_{i, j-1}}{dy} \right) \right] = \frac{u_{i,j}-u_{i-1,j}}{dx} + \frac{v_{i,j}-v_{i,j-1}}{dy} $$
其中 $i$ 和 $j$ 都是 [1, n] 的整数，我们可以对整个计算区域的所有格子列出类似的方程共 $n×n$ 个。
对上式稍作整理可以发现当格子大小 $dx=dy$ 时，方程左边可以简化成
$$ \frac{\delta t}{\rho dx^2}(4p_{i,j}-p_{i+1,j}-p_{i-1,j}-p_{i,j-1}-p_{i,j+1}) $$
其中， $\frac{\delta t}{\rho dx^2}$ 是一个常数系数，为了简化问题我们可以直接将其省略。于是，我们可以将 $p$ 的系数存入一个矩阵 $A$ ，而将 $p$ 保存在一个向量中，上面的表达式就变成了如下的一个矩阵和向量的乘：
于是这个问题就被转化为了求解线性方程组的问题。在各类数值仿真中，这样的例子还有很多很多。</description>
    </item>
    
    <item>
      <title>B. 高性能存储阵列的软件开销优化</title>
      <link>https://cuterwrite.top/TechDocs/docs/hpcgame-0/%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E9%A2%98%E7%9B%AE/finalb/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/hpcgame-0/%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E9%A2%98%E7%9B%AE/finalb/</guid>
      <description>一、背景介绍 link近些年来，SSD因其高带宽、低延迟、低能耗的特点，已经成为了高性能计算、数据中心、云服务等场景下的主要存储设备。但不幸的是，由于其自身的物理性质，相较于HDD，SSD通常更容易损坏，导致数据丢失。
存储阵列（RAID）是解决这个问题的手段之一。通过条带化技术，RAID可以聚合多个SSD的性能，同时对外提供服务，以驱动高性能计算中大量I/O的场景；通过校验和技术，RAID可以保证存储阵列具有一定的容错性，即使其中的一个磁盘损坏，也能从剩余的磁盘中恢复数据。
Linux software RAID（mdraid）是Linux内核中自带的RAID引擎，设计于二十多年前，因其高昂的软件开销，已不再适合用来创建和管理现有的高性能存储设备（如NVMe SSD）。如何优化mdraid，使得高性能SSD组成的存储阵列能够发挥出优异的性能，是现在学术界和工业界关注和研究的重点。
二、赛题描述 link本次比赛允许优化mdraid中的任何软件开销，考虑到比赛时间限制，参赛者可以通过阅读论文[1][2]了解到mdraid中已知的可优化的开销。同时，我们鼓励参赛者自己通过perf，fio等工具剖析RAID软件栈，找出其他可优化的部分。
下面简单介绍一下mdraid中的一个和锁相关开销，该开销的详细分析和说明可见论文[1]。如下图所示，在mdraid中，当I/O线程在处理写请求时，它首先会将数据分割为多个stripe unit。拥有相同offset的stripe unit属于同一个条带，它们会被一起处理 ①。但在处理之前，I/O线程需要向守护进程获取一个名为stripe_head的数据结构 ②。但是，为了防止多线程之间的冲突，mdraid使用全局的锁去管理stripe_head的分配。因此，如果我们使用多个线程来处理I/O请求，它们就会被这个锁阻塞，无法并行处理，造成大量的软件开销。解决这个问题的办法很简单，我们可以给每个stripe_head都分配一个锁，单独进行管理，再使用hash算法让不同的线程去找到不同的stripe_head，从而最大化线程的并行度。
类似的软件开销还有很多，请参赛者务必阅读论文[1][2]，以对mdraid相关的设计和开销形成初步的了解。除此之外，这里推荐查看资料[3]，辅助阅读mdraid相关的代码。
三、评测说明 link 我们允许修改附件中md文件夹下的任何代码，但其中很多代码只是因为编译需要而存在，和本次比赛相关度较低，因此我们建议参赛者关注文件raid5.，md.*；
修改代码后，参赛者可以根据附件README安装测试环境，测试自己代码的正确性。评测过程中也会使用相同的内核（linux-5.11-46）；
在评测过程中，我们会使用mdadm创建RAID5，参赛者可以参考[4]学习mdadm的使用方法；
在评测过程中，我们会使用高性能的NVMe SSD组建RAID,如果参赛者自己的Coding环境没有足够的磁盘，可以参考附录A，使用RAM模拟磁盘;
[1]的代码是开源的，我们允许参赛者整合该开源代码作为基础继续修改，但必须有其他的设计以作为此次参赛的内容；
在评测过程中，我们会使用fio产生IO请求，参赛者可以参考[5]学习fio的使用。
四、评分标准 link我们会用高性能的NVMe SSD组成2+1，4+1两种RAID5，并使用fio评估I/O的带宽和完成时延。带宽越高分数越高，延迟越低分数越高，按排名正态分布给分。我们使用到的测试参数如下表所示，其中worker thread的定义可以参考论文[1][2],并通过修改文件/sys/block/mdx/md/group_thread_cnt修改，这里mdx是你通过mdadm创建的RAID：
RAID类型 I/O Size No. of I/O threads No. of Worker threads IO depth 类别 指标 分数占比 2+1 64 KB 8 8 32 随机写 带宽 6.25 % 2+1 128 KB 8 8 32 随机写 带宽 6.25 % 4+1 64 KB 8 8 32 随机写 带宽 6.</description>
    </item>
    
    <item>
      <title>C. 工程精度离散单元法计算程序优化</title>
      <link>https://cuterwrite.top/TechDocs/docs/hpcgame-0/%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E9%A2%98%E7%9B%AE/finalc/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/hpcgame-0/%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E9%A2%98%E7%9B%AE/finalc/</guid>
      <description>一、题目背景 link离散单元法 (discrete element method, DEM) 由岩土工程学者 Cundall 和 Strack 于 1979 年提出，是一种数值仿真方法。它将世界抽象为若干细小颗粒 (particle) 的集合，将时间抽象为若干个细小的时间步 (time step)，在每个时间步内，分析颗粒之间的接触 (contact)，通过适当的接触模型 (contact model) 计算接触力 (矩)，利用牛顿第三定律 (Newton&amp;rsquo;s third law) 赋予颗粒上。归集每个颗粒所受的合力 (矩)，然后利用牛顿第二定律 (Newton&amp;rsquo;s second law) 求得颗粒 (角) 加速度，再对 (角) 加速度两次时间积分，得到颗粒位置 (方位) 的变动。重复以上过程，即可模拟时间的流逝和世界的演变。
DEM 因为基本假设简单，适用范围广，限制少。相比有限单元法 (finite element method, FEM)，DEM 可以自然模拟开裂、破碎等大变形问题，显式 DEM 也没有迭代收敛问题。DEM 被广泛用于土木工程、化学工程、工业工程等领域，通过数值仿真预测产品性能或工艺效果，从而指导工程实践。DEM 具有数值仿真共同的低成本优势，能以相比实验更低的成本，创造显著的经济效益。
然而，DEM 有一个显著的劣势——计算量大，计算速度慢。因此，高性能计算 (high performance computing, HPC) 对 DEM 仿真的加速必不可少，以保证 DEM 的计算时间处于可接受的范围内，确保生产效率。
2022 年 09 月，Taichi 社区举办了活动“Taichi DEM 代码优化挑战赛”。参赛作品使用 Taichi 高性能计算语言，编写 DEM 程序，丰富和完善其 DEM 各项功能。</description>
    </item>
    
    <item>
      <title>D. Linkpack 节点的选择程序优化</title>
      <link>https://cuterwrite.top/TechDocs/docs/hpcgame-0/%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E9%A2%98%E7%9B%AE/finald/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/hpcgame-0/%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E9%A2%98%E7%9B%AE/finald/</guid>
      <description>赛题描述 link给定 2 个 SPINE 交换机下 48 个候选节点，要求在不超过 3 次 Linpack 计算的情况下，通过程序或脚本以全自动的方式选择 16 个节点，得到 16 节点的 Linpack 最优值。
linpack 的评测指标是 gflops。
输入 link无，选手可自行获取相关信息
输出 link结果输出到output.txt，其中包含 16 个节点名(可通过hostname -s 获取)。与最优值误差在 0.1%之内的结果都算正确。
提交方式 link选手提交一个压缩包，我们运行其中 run.sh，选手程序输出结果，我们进行核验。选手程序中 NB 值等可在 run.sh 指定，最后输出 gflops 值。
测试环境 link我们提供了一个样例集群共选手实验提交之用，请注意，该集群及网络拓扑与最终测试的集群并不一致，选手程序需要有通用性，请勿针对该集群进行设计。
选手可以向linpack 分区提交任务以测试。请注意，单次申请节点数不得超过 4 个，单次申请时间不得超过 30 分钟，否则将失去该节点申请资格。建议选手在 compute 节点进行编码，向 linpack 提交任务进行测试。
申请节点时请加上--exclusive 选项，以免受其他评测影响。
提示 link1． 使用 Intel OneAPI MKL 函数库下的 mp_linpack 软件测试包用于 Linpack 测试（安装在/data/software/intel/mkl/）。我们的集群中，只有SCOW 集群安装了该脚本，请 2． 建议编写 dgemm 测试程序用于筛选 Linpack 测试的 NB 值，以及筛选候选节点的双精度性能 3． 建议采用 MPI pingpong 测试的方式分析出候选节点的网络拓扑</description>
    </item>
    
    <item>
      <title>A. 欢迎参赛</title>
      <link>https://cuterwrite.top/TechDocs/docs/hpcgame-1/a/</link>
      <pubDate>Tue, 30 Jan 2024 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/hpcgame-1/a/</guid>
      <description>分数：10 分
关于本题 link为了确保每位选手都详细地阅读参赛须知，所以我们把创建集群账户这一步操作放在了这道题目中。当你完成了这道题目，您会在评测结果中收到登录 SCOW 平台（本次比赛选手与超算直接交互的平台）的地址和凭据。 请您往下阅读，即可获得通过此题的方法。
请不要使用 https://scow.pku.edu.cn/ 的集群，比赛有专门的集群，在本题的评测结果中发放给您，请注意检查评测结果！集群由登录节点和计算节点两部分组成，SCOW 的 shell 进入的是登录节点。对于所有任务，请提交脚本交由计算节点进行计算，具体方式可以参考这个 slrum 使用说明。具体的，您需要关注 slurm 介绍、salloc 、sinfo 、squene 、sacct 和 scancel 命令的使用。
特别地，教程中的 sbatch 是旧版，对于比赛集群使用的新版，--ntasks-per-node 只是每个节点上最多开的进程数，还需要指定 --ntasks 以确定总进程数。该版本的 slurm 也不需要像教程例子那样处理 hostfile 了。这里给出一个新版本跑 MPI 的例子：
#!/bin/bash #SBATCH -o job.%j.out #SBATCH --partition=C064M0256G #SBATCH --qos=normal #SBATCH -J myFirstMPIJob #SBATCH --nodes=2 #SBATCH --ntasks=8 #SBATCH --ntasks-per-node=4 # 导入 MPI 运行环境 module load openmpi # 执行 MPI 并行计算程序 mpirun -n 8 hostname &amp;gt; log 如果登录到计算节点提示需要密码，请使用</description>
    </item>
    
    <item>
      <title>B. 流量席卷土豆</title>
      <link>https://cuterwrite.top/TechDocs/docs/hpcgame-1/b/</link>
      <pubDate>Tue, 30 Jan 2024 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/hpcgame-1/b/</guid>
      <description>分数：80 分
背景 linkAD 4202 年，在 Planet Potato 上，运行着 Potato Network。来自 Potato Kingdom University 的师生在 Potato Network 上联网，进行各项社交和研究工作。
注：Potato Network 又名“土豆”网，能够以近乎无限的带宽和极低的延迟进行数据传输。唯一的缺陷似乎就是在凌晨时常出现稳定性问题，这似乎是由于它由一堆土豆电池供电。在 AD 4202 年，除了使用可控核聚变发电外，最常见的发电方法就是大规模的生物电池了。为了使得远古系统（例如运行在 Macrohard 2000 上的 tree.pku 服务）能够得以正常运行，Potato Network 在接口上与 Ethernet 和 TCP/IP 保持向下兼容。
Potato Network 在某一个抽象层次是基于“数据包”的，设备接入 Potato Network 产生数据包的同时，可以把所有产生的数据包记录下来，并使用一种名叫 Potato Capture for All Packets (PCAP) 的格式存储。
可怜的小土豆是新入职 Potato Kingdom University 的一名工程师。他的职责是运营和维护一个来自远古的庞然大物——他只知道过去人们把它称作“超级计算机”。这该死的大家伙早就该被随处可见的量子比特计算机替代了，只可惜有一些祖传的、使用一种叫做“方程式翻译”的古老语言写就的关键程式，已经没有人能读懂并修改了。维护这大家伙原本是个悠闲差事——古人制造的机器在这千百年来居然鲜有故障，但谁知在交接工作时前任工程师竟然没有告诉他这台机器的根账户密码。
小土豆可以通过自己的账户名和密码登入这台机器，但是如果没有根账户密码，他就不能及时阻止一些问题程序的运行。他刚想求助前同事，却忽然想起了一件事：在这台庞然大物的“共享硬碟”中，留存有前几个月这台计算机接入 Potato Network 产生的所有数据包（packet）。这里面一定包括了前任管理员通过 Potato Network 登入超级计算机所产生的数据包！在 AD 4202， P=NP 已被证明，从数据包中截获并破译密码就是运行个程序的事儿！
任务 link由于时空管理局的错误操作，误将 AD 2024 年的 Peking University 的超算与 AD 4202 年的 Potato Kingdom University 的超级计算机相连接。你惊奇地发现：你可以从本次比赛提供的超算集群（可以通过 SCOW 平台访问）直接访问 Potato Kingdom University 的超级计算机！好吧，你意识到或许在宇宙的哪个角落哈希算法被某个不负责任的家伙做成了简单的取缩写。你的朋友，小 X，在早些时候已经对这一集群开展了检查，他发现了几个不同寻常的地方，其中引发你的注意的是如下几点：</description>
    </item>
    
    <item>
      <title>C. 简单的编译</title>
      <link>https://cuterwrite.top/TechDocs/docs/hpcgame-1/c/</link>
      <pubDate>Tue, 30 Jan 2024 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/hpcgame-1/c/</guid>
      <description>分数：40 分
说明 link在本题中，你需要写一个简单的 Makefile 文件，和一个简单的 CMakeLists.txt 文件，来编译 Handout 中所提供的三个简单程序。
其中，hello_cuda.cu 是一个简单的 cuda 程序，hello_mpi.cpp 是一个简单的 mpi 程序，hello_omp.cpp 是一个简单的 OpenMP 程序。它们都做了同一个简单的事情：从文件中读取一个向量并求和。
你需要上传 Makefile 和 CMakeLists.txt 文件。我们会根据以下策略来评测你所写的配置文件的正确性。
对于 Makefile 文件，我们会在项目根目录下执行 make 命令。然后在项目根目录下检查程序是否被生成，并运行以检测正确性。 对于 CMakeLists.txt 文件，我们会在项目根目录下执行 mkdir build; cd build; cmake ..; make 。然后我们会在 build 目录下检查程序是否被正确生成，并运行以检测正确性。 对于所有类型的文件，hello_cuda.cu 所编译出的文件名应为 hello_cuda ；hello_mpi.cpp 所编译出的文件名应为 hello_mpi ；hello_omp.cpp 所编译出的文件名应为hello_omp 。 评分标准 link评测机加载的 module 如下，评测将会在 GPU 节点进行，选手写题时请使用 GPU80G 分区。
module load cuda gcc openmpi 测试点 文件 分值 1 Makefile 40% 2 CMakeLists.</description>
    </item>
    
    <item>
      <title>D. 小北问答 Classic</title>
      <link>https://cuterwrite.top/TechDocs/docs/hpcgame-1/d/</link>
      <pubDate>Tue, 30 Jan 2024 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/hpcgame-1/d/</guid>
      <description> 分数：100 分
背景 link经过深思熟虑，我们认为小北问答经过 极速版、超速版 的迭代后，应该回归传统。所以我们特别设计了这道 &amp;ldquo;小北问答 Classic&amp;rdquo;，让我们在 2024 年再次体验单纯、传统的答题快乐。
我们想聪明的你一定会摸索出如何提交本题。往往 Classic 的设计，是最用户友好的 。
题目 link注意：若题面和提交答案处不一致，则以题面为准
［填空］ 根据 2023 年 11 月公布的 GREEN500 排行榜，能量效率最高的超级计算的能效达到了____（GFlops/watts）（保留小数点后 3 位） ［填空］ 根据 Amdahl 定律，在关键路径上，将占据程序运行时间 10% 的部分加速到 2 倍，则程序整体的加速比为____%；将占据程序运行时间 40%的部分加速到 1.2 倍，则程序整体的加速比为____%。（均保留两位小数，均假设加速前后程序的关键路径不变） ［单选］ 以下哪个工具的作用与其他选项的区别最大？ Meson Autoconf CMake GCC ［单选］ 从以下选项中选择正确答案依次填入空中（可多次选择）：MPI 提供的是___级别的并行；OpenMP 提供的是___级别的并行；两者相比，___级别的并行更加轻量。 线程 进程 ［混合］ AVX512 指令集是现代 x86_64 CPU 上常用的用于加速 SIMD 运算的指令集，使用 AVX512 指令集，一条指令可以对最多___（填空）个 64 位浮点数进行运算。各个厂商对 AVX512 指令集的实现有所不同，如 Intel（以 Ice Lake SP 为例）（选择），AMD（以 ZEN4 架构为例）（选择）。 在 CPU 中设计独立的 AVX512 运算单元，但有可能导致调用 AVX512 指令集时因功耗过大而降频 复用两个 AVX2 运算单元执行 AVX512 运算 ［单选］ 以下哪个不是专门用于在 GPU 上设计并行计算程序的？ OpenACC CUDA HIP OpenGL ［多选］ SIMD（Single Instruction, Multiple Data）和 SIMT（Single Instruction, Multiple Threads）是并行计算的两种模型。下面哪些描述是正确的？（示例回答方式：i,ii,iii,iv ） SIMD 和 SIMT 都是同一种并行计算模型，只是不同的命名。 SIMD 每个线程执行相同的指令，但处理不同的数据；SIMT 中每个线程可以执行不同的指令。 AVX512 指令集是 SIMD 模型的代表。 在 SIMT 模型中，线程协作执行相同的指令序列，但处理不同的数据。 ［单选］ 在高性能计算中，下列哪项技术不是用于节点间通信的？ InfiniBand Ethernet NVLink HBM ［单选］ 在高性能计算集群中，哪个工具通常用于作业调度和资源管理？ 微信群 Slurm Docker Swarm Apache Mesos ［单选］ 在处理矩阵乘法的并行化时，通常会使用分块矩阵乘法来减少______，从而提高并行效率。 缓存未命中 通信开销 浮点运算错误 硬盘 I/O 延迟 </description>
    </item>
    
    <item>
      <title>E. 齐心协力</title>
      <link>https://cuterwrite.top/TechDocs/docs/hpcgame-1/e/</link>
      <pubDate>Tue, 30 Jan 2024 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/hpcgame-1/e/</guid>
      <description>分数：120 分
重要：注：如果遇到 Cannot Connect to GCS 或类似报错的请在选手群内私聊管理提交链接重测，这是由 Ray 集群启动异常造成的。如果遇到 Actor Died 或类似报错，那是由于超出了内存限制，请自行研究解决，感谢！
题目描述 link遥远的开爱大陆盛产毒药，这些毒药威力并不高，只是会让人痛苦不堪，乖乖地给开爱国王交上赎金获取解药。开爱国王富得流油，但人们对此苦不堪言。
你和宿舍小伙伴们是拉玛大陆骑士学院的优秀学员，致力于推翻开爱国王对解药的垄断，于是踏上了寻找解药方法的路程。路上你们遇到了善良的开爱国公主，她告诉你们，每一种毒药都有 40000 种可能的原料，构成药物空间的一个 40000 维 32 位浮点向量。而对应的解药就是将这个向量进行变幻得到的另一种配方。
经过对厚厚几万页配方书的阅读，你们最终发现，从毒药到解药的变换分四步，每一步都是先进行一个线性变换，然后对 0 取 Max（因为原料没有负数个）。这个线性变换类似于神经网络，具体描述如图。其中每个矩阵是的维度是(40000, 40000)。
大家都听说你们掌握了破解毒药的方法，纷纷找你们帮忙。虽然你们可以手算解药变换，不过依然是太慢了。于是你们打算用高性能计算的思想，让电脑来算这件事。但是你们宿舍的电脑都只有 16G 内存，每一个矩阵就需要 12G 内存，在一台电脑上放不下，需要四个人齐心协力，共同计算。但是天上不会掉馅饼，怎么才能让四台电脑一起计算呢？你听说 Ray 最近很热，是基于 Python 的，编程比 MPI 更加自然，于是想要试一试。
任务描述 link对于一百个(200, 40000)的矩阵 $x$ ，计算如下结果，其中 $A、B、C$ 和 $D$ 都是 (40000, 40000) 的矩阵。其中四个矩阵需要被放置在四个不同的节点上，每个节点有 4 个核心、16G 内存。你需要对于输入的每一个 $x$ ，计算得出最终的 $output$ 。
$$ \begin{aligned} &amp;amp; y_1=ReLU(xA) \\ &amp;amp; y_2=ReLU(y_1B) \\ &amp;amp; y_3=ReLU(y_2C) \\ &amp;amp; output=ReLU(y_3D) \\ \end{aligned} $$ 输入输出约定 link输入 link在 inputs 文件夹中有 input_0.</description>
    </item>
    
    <item>
      <title>F. 高性能数据校验</title>
      <link>https://cuterwrite.top/TechDocs/docs/hpcgame-1/f/</link>
      <pubDate>Tue, 30 Jan 2024 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/hpcgame-1/f/</guid>
      <description>分数：120 分
背景 link由于网络波动等等不可控的因素，文件有可能在传输过程和存储过程中损坏，而文件损坏可能会对后续任务产生不可估量的后果和破坏。 校验码是用来检测这种现象的有效手段。但是，通常的校验码实现往往是单线程的，很难利用到现代计算机的多核特性以及并行文件系统的强悍能力。
本题使用一种基于 SHA512 算法的可并行数据校验算法对数据进行分块校验。（SHA512 是一种高度安全的校验码实现，具体算法不需关心）
算法的流程如下（对算法的具体解释见 baseline 代码）：
对数据进行分块，每一块的大小为 M=1MB，记划分的块数为 n。如果文件剩余内容不足一块的大小，则补二进制 0 至一个块大小。 对于第 i 个块，在其末尾连接上第 i-1 个块的 SHA512 校验码的二进制值，将所得到的 M + 64 大小的数据进行 SHA512 校验，得到第 i 个块的校验码。（i 从 0 开始） 注，第 -1 个块的校验码为空文件的校验码 最后一个块的校验码，即为文件的校验码 注，大小为 0 的文件的校验码定义为空文件的 SHA512 校验码 输入 link选手的程序应当要能接收两个命令行参数。第一个命令行参数是输入文件，这个参数指定了待校验的文件路径。输入文件储存在我们的 lustre 并行文件系统上。
输出 link程序的第二个参数是输出文件路径，程序应当将校验码输出到输出文件中。
校验码的输出格式为 16 进制数的字符串表示，结尾 不需要换行 。例如：
a777f78b580aa6f095e16415e35cf4ce414bf425c7b2441582c1b3e7f47f0741ca1da2213b06c36070db1428b24037380d96be51b3052ae0079dfe72c147d73b
注意，所有来自 标准输出 的内容都会被忽略。测评程序只会检查输出文件中的结果。
本题提供了使用 libcrypto 库的 baseline 代码（串行，引入 MPI 是为了兼容评测环境）。
评测 link提交单个 C++ 代码文件，我们将会使用 OpenMPI + GCC 来编译你的代码（编译参数为 -lcrypto -O3 ）。 并且使用 mpirun -np 8 来运行你的程序。你的代码将会运行在两个节点，每台节点 4 个核心上，所以进程和核心是一一对应的。</description>
    </item>
    
    <item>
      <title>G. 3D 生命游戏</title>
      <link>https://cuterwrite.top/TechDocs/docs/hpcgame-1/g/</link>
      <pubDate>Tue, 30 Jan 2024 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/hpcgame-1/g/</guid>
      <description>分数：200 分
简介 link康威生命游戏（Conway&amp;rsquo;s Game of Life），是英国数学家约翰・何顿・康威在 1970 年发明的细胞自动机。
在初始版本的生命游戏中，世界是一个二维的方格矩阵，其中，每个方格中居住着存活或者死亡的细胞。一个细胞在下一时刻的生死取决于相邻的八个方块中居住的存活或者死亡的细胞的数量，具体规则如下：
当细胞为存活状态时 如果周围存活的细胞低于 2 个（不包含 2 个）时，细胞变为死亡状态 如果周围存活的细胞有 2 个或者 3 个，则细胞保持存活 如果周围存活的细胞超过 3 个（不包括 3 个）时，细胞变为死亡状态 当细胞为死亡状态时 如果周围有 3 个存活细胞时，该细胞变成存活状态 重复以上过程，康威生命游戏便可周而复始地进行。由于规则简单，又能产生一些有趣的现象，生命游戏的生命力经久不衰。你可以在 这个网站 玩到原版的生命游戏。默认的场景就是一个不断向外运输块的“太空船”，就好像人类发射火箭，探索太空一样。观察这些现象的时候，仿佛我们就是造物主，看着芸芸众生忙碌奔波。
3D 版本康威生命游戏 link在本题中，你将研究拓展到三维版本的康威生命游戏。在三维版本中，每个细胞有 26 个邻居，状态转移规则如下：
当细胞为存活状态时 如果周围存活的细胞低于 5 个（不包含 5 个）时，细胞变为死亡状态 如果周围存活的细胞有 5 到 7 个时（包含 5 和 7），则细胞保持存活 如果周围存活的细胞超过 7 个（不包括 7 个）时，细胞变为死亡状态 当细胞为死亡状态时 如果周围有 6 个存活细胞时，该细胞变成存活状态 同时我们希望研究无限空间大小下的生命游戏。但是，无限空间难以在计算机中表示，因此，我们采取一种”循环“的策略，来模拟无限空间。具体规则为：若有效信息的块的边长为 $M$ ，则无限空间中任意一点 $(x, y, z)$ 对应有效信息块中的位置为 $(x \mod M, y \mod M, z \mod M)$ 。</description>
    </item>
    
    <item>
      <title>H. 矩阵乘法</title>
      <link>https://cuterwrite.top/TechDocs/docs/hpcgame-1/h/</link>
      <pubDate>Tue, 30 Jan 2024 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/hpcgame-1/h/</guid>
      <description>分数：200 分
背景介绍 link矩阵乘法经常出现在实际代数运算中，被各种计算库（如 Eigen，MKL，OpenBLAS）集成，也经常用于基准测试中。在尺度较小时，数据量近似等于计算量；如果尺度翻倍，计算量变为原先的 8 倍，但数据量仅为原先的 4 倍；矩阵乘法存在随尺度增大的数据局域性。由于其独特的计算量和数据量增长关系，一个优秀的矩阵相乘算法必须充分利用各级存储资源。
任务描述 link你需要从文件 conf.data 中读取两个矩阵 $M_1, M_2$ 并计算乘积 $M_3=M_1 \cdot M_2$ ，然后将结果写入文件 out.data 中。
输入文件为一个二进制文件，定义如下：
三个 64 位整数 $N_1,N_2,N_3$ ； 第一个矩阵 $M_1$ 的数据，矩阵有 $N_1$ 行、$N_2$ 列，以 64 位浮点的形式存储，顺序为行优先； 第二个矩阵 $M_2$ 的数据，矩阵有 $N_2$ 行、$N_3$ 列，以 64 位浮点的形式存储，顺序为行优先。 将矩阵 $M_3$ 直接写入输出文件中，以 64 位浮点的形式存储，顺序为行优先。
输入输出文件均在内存盘上。我们提供了一组样例测试数据，可以从 附件 选项卡中下载。
样例程序 link #include &amp;lt;iostream&amp;gt; #include &amp;lt;chrono&amp;gt; void mul(double* a, double* b, double* c, uint64_t n1, uint64_t n2, uint64_t n3) { for (int i = 0; i &amp;lt; n1; i&amp;#43;&amp;#43;) { for (int j = 0; j &amp;lt; n2; j&amp;#43;&amp;#43;) { for (int k = 0; k &amp;lt; n3; k&amp;#43;&amp;#43;) { c[i * n3 &amp;#43; k] &amp;#43;= a[i * n2 &amp;#43; j] * b[j * n3 &amp;#43; k]; } } } } int main() { uint64_t n1, n2, n3; FILE* fi; fi = fopen(&amp;#34;conf.</description>
    </item>
    
    <item>
      <title>I. LOGISTIC 方程</title>
      <link>https://cuterwrite.top/TechDocs/docs/hpcgame-1/i/</link>
      <pubDate>Tue, 30 Jan 2024 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/hpcgame-1/i/</guid>
      <description>分数：100 分
简介 link混沌系统因其对微扰的极度敏感性而让大家十分感兴趣，“亚马逊雨林的蝴蝶扇动翅膀，就可能在太平洋刮起飓风”便是混沌系统的有趣例子。我们这里介绍一种混沌系统，称为 logistic 方程。该方程描述种群在资源有限的情况下数量随时间的变化，数学形式如下：
$$ \frac{dx}{dt} = rx(1-x) $$
logistic 映射是与其相似的离散映射，具有如下形式。
$$ x=rx(1-x) $$
logistic 映射尽管形式简单，但作为混沌系统具有很多典型的特征，例如分叉和吸引子。
当 $1&amp;lt;r&amp;lt;3$ 时，$x$ 会稳定在 $0~ 1 $ 区间内的某个值。一旦 $r&amp;gt;3$ ，会在两个数值中循环形成稳定的周期，随着 $r$ 增加，周期长度逐渐翻倍，直到在临界点 $(r 3.56995)$ 趋于无穷，意味着在这里没有任何的周期现象。
如果统计 $r$ 取不同值时 $x$ 的分布，就会得到如下图案。
logistic 映射的分叉图 在 $r$ 大于临界点的若干区间中，仍存在稳定的周期，并且有和临界点左侧相似的逐步分叉现象。这也是 logistic 映射有趣的地方。
这里将使用 logistic 映射作为样例，初步了解向量化指令是如何加速数值计算的。
任务 link你需要计算 $n$ 个 64 位浮点数的 itn 次 logistic 映射，所有浮点数会使用相同参数 $r$ 。$n$ 为 1024 的整数倍。
从输入文件 conf.data 中依次读取如下内容：
项目 类型 itn 64 位整数 r 64 位浮点 n 64 位整数 初始值 n 个 64 位浮点 将迭代 itn 次后的结果直接写入输出文件 out.</description>
    </item>
    
    <item>
      <title>J. H-66</title>
      <link>https://cuterwrite.top/TechDocs/docs/hpcgame-1/j/</link>
      <pubDate>Tue, 30 Jan 2024 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/hpcgame-1/j/</guid>
      <description>分数：200 分
（如果你急着做题，请跳到“任务描述”部分）
背景 link室温超导在推动能量的无损传输、磁场应用以及人类在材料和能源方面的研究等方面有着非常重要的前景。H 星球上的居民将其视为通往无限能源时代最重要的钥匙。你的朋友小金对这个话题也非常感兴趣，每天都泡在实验室里，试图合成室温超导材料。
有一天，小金通过某种奇妙的方法合成出了一种似乎有抗磁性的材料。他非常激动，向你炫耀这一成果，并表示，如果你投资 1 亿 H 币用来和他一起大规模生产这种材料，他会用你的名字小何命名这种材料，叫它“H-66”。
作为理论物理的学渣，你当然不会按他的方法进行材料合成。不过小金给了你一份他测出来的样品的结构，你或许可以理论上算看看这个结构是否是超导体。你并不会什么复杂的方法，于是查资料找到了一种叫 Hubbard Model 的模型。这似乎是一种简单的方法，能帮你获取样品的一些性质。
计算背景 linkHubbard Model 指的是固体物理学中的一种简化模型，用于研究电子在晶格中的行为，特别是在强电子关联系统中。这个模型最初是由物理学家 John Hubbard 在 20 世纪 60 年代提出的，主要用于理解固体中的磁性和超导性。
在 Hubbard 模型中，电子可以在一个简化的原子格点系统中跃迁，同时受到两个主要因素的影响：
跃迁项 ：描述电子从一个格点跃迁到另一个格点的能力，通常与电子的动能相关。 相互作用项 ：描述当两个电子占据同一格点时的库仑排斥能。 这个模型的重要之处在于其简单性和灵活性。虽然它是高度简化的，但仍然能够捕捉到复杂电子系统的一些关键特性，如绝缘体与金属的转变、磁性的形成，以及高温超导体的某些性质。
例如，可以建立一个一维的哈伯德模型，并计算携带不同动量的电子（黑色）或空穴（白色）的激发谱，如下图所示。电子和空穴之间的能隙告诉我们它是一种绝缘体而非导体。
Hubbard 在量子多粒子系统的理论和光谱测量的理论描述中，如角分辨光电子能谱（ARPES）和 X 射线吸收谱（XAS），常常会出现像 $\left \langle i | \frac{1}{\omega - H} | i \right \rangle$ 这样的表达式。ARPES 直接与单粒子激发的谱函数相关，它简要描述了电子结构。而 XAS 则涉及到核心层到价带的激发，并且对元素的价态和轨道占据敏感。现在我们关注一种特定类型的 $A(\omega)= -Im (\left \langle x | \frac{1}{\omega +i \Gamma - H} | x \right \rangle)$ ，其中 $H$ 是一个厄米算符。如果我们用常见的基来表示这个系统，向量 $x$ 和厄米矩阵 $H$ 的维数会非常大，以至于不能直接计算这个表达式。另一种方法是使用迭代方法为每个 $\omega$ 解线性方程，但这仍然太慢。一个更实用的方法是尝试将 $H$ 分解为几个特征值和特征向量，$H \approx \sum v_i e_i v^\prime_i$ ，那么 $A(\omega) \approx -Im (\sum \frac{1}{\omega +i \Gamma - H}) |v^\prime_i x|^2$ 。</description>
    </item>
    
    <item>
      <title>K. 光之游戏</title>
      <link>https://cuterwrite.top/TechDocs/docs/hpcgame-1/k/</link>
      <pubDate>Tue, 30 Jan 2024 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/hpcgame-1/k/</guid>
      <description>分数：200 分
背景 link小 C 很喜欢玩游戏。他最近在玩一款名为《光》的游戏，这是一款非常真实的游戏，游戏中的光照效果非常逼真。小 C 一直想知道这款游戏是如何实现的，于是他找到了游戏的开发者，想要了解一下游戏的实现原理。
开发者说：
辐照度是一种用于计算光照的方法，它的基本思想是将光照分解为一系列的光子，每个光子都有一个辐照度，光子之间的相互作用可以通过辐照度的传递来计算。
下图展示的是一个典型的迭代过程，顶部的光源先照亮周围的墙壁和地面，地面和墙壁的散射再进一步照亮天花板和阴影。
图：一个典型的迭代过程 任务 link本题提供一个利用辐照度方法渲染场景样例程序，你需要以此为基础进行优化。程序接受一个场景的描述，进行细分，然后计算出每个点的辐照度。场景由一系列的面组成，每个面都有一个辐照度，每个面都可以反射光；每个面都可以被其他面照亮，每个面都可以照亮其他面。辐照度的计算过程如下：
顶部的光源照亮所有的面，每个面的辐照度为光源的辐照度。 每个面将自己的辐照度平均分配给所有照亮自己的面。 渲染场景，输出本轮迭代图像 重复步骤 2 若干次，直到所有面的辐照度都收敛。 输出最终图像。 本题提供 Baseline 和样例，请在“附件”选项卡中下载。
输入输出函数在样例中已经给出，不需要改动。
输入格式 link输入文件 conf.data 为一个二进制文件，定义如下：
一个 64 位整数 $N$ ，表示平行四边形面的数量； $N$ 个面的数据，每个面的数据包含： double3 $pos$ ，表示面的一个顶点； double3 $a$ ，表示面的一条边； double3 $b$ ，表示面的另一条边； double3 $emission$ ，表示自发光； double3 $reflectance$ ，表示反射率。 输出格式 link输出文件为 6 个 BMP 图像。
评测方式 link提交的代码会以最简单的方式编译并执行，编译选项为 -O3 -fopenmp -march=native -ffast-math -std=c++20 。如果需要链接特定系统或编译器自带库，请联系工作人员并说明理由，编译条件的更改会对所有选手可见。程序运行在 Intel Xeon 8358 机器中的 8 个核心上。</description>
    </item>
    
    <item>
      <title>L. 洪水 困兽</title>
      <link>https://cuterwrite.top/TechDocs/docs/hpcgame-1/l/</link>
      <pubDate>Tue, 30 Jan 2024 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/hpcgame-1/l/</guid>
      <description>分数：80 分
背景 link你是一名游戏开发者，正在开发一款名为《洪水 困兽》的游戏。在《洪水 困兽》的游戏中，玩家将被置于一个动态变化的环境中。这个环境由一系列的地形组成，包括山丘、森林、河流和洞穴。随着游戏的进行，洪水将逐渐淹没这些地形，玩家需要引导小狗在洪水到来之前找到安全的地方。
小狗的移动速度会受到地形的影响。例如，在山丘上，小狗的移动速度会降低，但是可以获得更好的视野；在森林中，小狗可以躲避洪水，但是视野会受到限制；在河流中，小狗的移动速度会增加，但是方向控制会变得困难。此外，游戏中还有一些特殊的地形，如瀑布和漩涡，它们会对小狗的移动产生特殊的影响。玩家需要利用这些地形的特性，制定出逃离洪水的策略。
游戏的目标是让小狗在洪水淹没整个环境之前逃离出来。每次成功逃离，游戏的难度将会增加，洪水的速度会变快，地形会变得更加复杂。玩家需要不断地挑战自己，提高自己的策略和操作技巧，才能在游戏中取得更高的分数。
为了增加游戏的真实性，你决定在游戏中采用优越的粒子-网格混合方法进行流体模拟。这一过程大致如下图所示：
你的游戏引擎中已经实现了流体模拟，但是由于流体模拟的计算量较大，导致游戏的帧率较低。你想着：一帧能玩五帧流畅，于是直接发布了游戏，并在最低运行需求中写下了：CPU: AMD EPYC 9654 。
粒子-网格混合方法（PIC/FLIP, APIC）是计算机图形学流体仿真中十分流行的算法。纯粒子方法难以保证流体的不可压条件，纯网格方法难以精确表示和追踪流体的几何信息；而粒子-网格混合方法在一定程度上综合了二者的优点。
PIC/FLIP 的算法流程可简化为以下步骤：
粒子运动（advection） 粒子将速度转换到网格（particle2grid） 在网格上施加重力（external force） 在网格上求解流体不可压条件（projection）（bottleneck） 网格将速度转换到粒子（grid2particle） 从离散化速度场的角度，粒子方法用粒子存储速度，网格方法用格点存储速度，混合方法的关键步骤就是在两种存储速度的格式之间转换，即 particle2grid 和 grid2particle 。
直到有一天你的玩家给你发了一张这个图片：
你意识到你应当优化你的游戏，并把最低硬件要求降低至 CPU: Intel Xeon 8358 了。
你强迫自己仔细阅读了游戏引擎的代码，发现其中实现了粒子-网格混合方法的 particle2grid 过程，但是它是单线程的；然而，这一步的计算量非常大，这使得游戏渲染时无法达到流畅的帧率。因此，你决定将 particle2grid 过程并行化，以进一步提高游戏性能。
你计划使用多线程技术来实现这个目标。每个线程将负责处理一部分粒子，将它们的速度转换到网格上。这样，你可以在多个处理器核心上同时进行计算，大大减少了 particle2grid 过程的总计算时间。
然而，多线程编程并不简单。你需要确保所有线程都能正确地访问和修改共享数据，而不会发生数据竞争或者其他并发问题。此外，你还需要使用一个有效的线程调度策略，以确保所有线程都能得到充分的计算资源。为了解决这些问题，你决定使用一些并行编程的工具和技术，例如 OpenMP 。
你知道这将是一个挑战，但你也相信，只要你能成功实现这个并行化的 particle2grid 过程，你的游戏《洪水 困兽》就能达到流畅的帧率，给玩家带来更好的游戏体验。
任务描述 link我们提供了一个 Handout，提供了串行版本代码和测试数据。你需要在 Handout 的基础上，使用 OpenMP 实现并行化的 particle2grid 过程。以下是对这一过程算法的详细介绍。
背景网格 link流体模拟经常采用 Marker-And-Cell (MAC) 网格。对于二维的情况，速度总是存储在边中心。下图 $u$ 表示沿 $x$ 轴的横向速度，$v$ 表示沿 $y$ 轴的纵向速度；其余部分的速度使用插值得到；速度的 $x、y$ 轴分量分别从 $u$ 和 $v$ 两个不同的背景网格插值得到。</description>
    </item>
    
    <item>
      <title>M. RISC-V OPENBLAS</title>
      <link>https://cuterwrite.top/TechDocs/docs/hpcgame-1/m/</link>
      <pubDate>Tue, 30 Jan 2024 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/hpcgame-1/m/</guid>
      <description>分数：50 分
任务描述 linkRISC-V 是一种开放授权的精简指令集，目前在体系结构等领域广受欢迎。究其原因，有如下几点：
开源开放：任何人都可以免费使用这套指令集来设计、制造和销售 RISC-V 芯片，不用支付授权费用。 可定制性和灵活性：RISC-V 允许设计者根据自己的需要添加或修改指令，并以指令集扩展的形式体现 促进创新：开放和灵活的特性使得 RISC-V 成为学术研究和创新实验的热门平台，学者和工程师可以自由地试验新的设计思路和优化方法 前几年，RISC-V 还是纸上谈兵，大部分的硬件都是模拟器或者小型开发板，并非能真实使用的物理硬件。但到目前，由于许多开源 RISC-V 实现如（香山、玄铁）的出现， 众多可用的 RISC-V 硬件也横空出世。特别是 SG2042 等高核心数，支持 DDR4 内存和 PCIE 等功能的“通用 RISC-V”主机出现，让我们看到了 RISC-V blob
但同时，开源的坏处就是，没有人为此负责。RISC-V 的生态目前还是亟待解决的问题，特别是在高性能计算领域，毕竟很少有人想过 RISC-V 还能用来进行高性能计算。目前数值计算最重要的开源库之一 OpenBLAS 在节点上无法得到正确结果，这导致了很多麻烦的问题。
本题的目标是，解决 OpenBLAS 在 RVV-0.7.1 向量扩展上的计算错误问题，附件为 baseline 代码
题在排行榜总分中占 50 分，但本题参与 RISC-V 赛道的赛道奖励，权重为 50 %。同时，本题也是下一题的重要前提条件。
评分标准 link机器环境 link在登录节点可访问，命令如下：
rv_machine init 初始化 rv_machine start 开机 rv_machine shell 登录 系统为 RevyOS，CPU 数为 64
编译运行 （20%） link提交打包的 OpenBLAS 后编译文件。由评测机运行，结果正确即得分，不要求带向量扩展编译。我们会使用官方测试点和 HPL 进行正确性测试，附件中有 HPL 的编译文件。</description>
    </item>
    
    <item>
      <title>N. RISC-V LLM</title>
      <link>https://cuterwrite.top/TechDocs/docs/hpcgame-1/n/</link>
      <pubDate>Tue, 30 Jan 2024 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/hpcgame-1/n/</guid>
      <description>分数：50 分
题目说明 link请先阅读 RISC-V OpenBLAS 的题目说明。建议在有可以正确执行的 OpenBLAS 的前提下完成本题。
LLM 自出现就成为了日益重要的工具，也成为了软硬件体系性能的重要测试场景。本题要求选手运行 4bit 量化过的 ChatGLM2 ，进行性能测试。
本题在总分中占比为 0 分，在 RISC-V 赛道中的权重为 50%
框架 link我们建议使用如下框架。由于本题是手工评测，选手也可以提交任意框架，但必须有详细的编译方法和使用方法，以及相应权重。权重必须至少是 q4_0 量化的，即允许更高精度的权重，但不再允许向更低精度量化。
chatglm.cpp 提交方式 link选手提交一个 tar.xf 文件，使用 tar xf --strip-components=1 file.tar.gz 解压后，根目录需要有一个 CMakeLists.txt 文件。评测机将会使用 cmake -B build &amp;amp;&amp;amp; cmake --build build -j 32 进行编译。 并使用如下代码评测。该代码将使用不同 prompt 执行十次，所得结果取平均值。
./build/bin/main -m /opt/models/chatglm2-6b-int4.bin --mode generate -p &amp;#34;当前评测 prompt&amp;#34; --max_new_tokens 100 --temp 0 -t 64 性能评分 link最终性能评分为 prompt tokens + 1.</description>
    </item>
    
    <item>
      <title>深度学习调优指南中文版</title>
      <link>https://cuterwrite.top/TechDocs/docs/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/readme/</link>
      <pubDate>Fri, 15 Sep 2023 02:21:15 +0000</pubDate>
      
      <guid>https://cuterwrite.top/TechDocs/docs/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/readme/</guid>
      <description>这不是官方认证的 Google 产品。
Varun Godbole † , George E. Dahl † , Justin Gilmer † , Christopher J. Shallue ‡ , Zachary Nado †
† 谷歌研究，谷歌大脑团队
‡ 哈佛大学
目录 link 这份手册是为谁准备的？ 为什么需要这份调优手册？ 开始新项目的指南 选择模型架构 选择优化器 [选择 BatchSize](#选择 Batchsize) 选择初始配置 提高模型性能的科学方法 增量调整策略 探索与利用 选择下一轮实验的目标 设计下一轮实验 确定是否采用此训练工作流更改或超参数配置 探索结束后 确定每次训练运行的步数 当训练不受计算限制时如何决定该训练多久 当训练受计算限制时如何决定该训练多久 关于训练工作流的额外补充 优化输入管道 评估模型性能 保存检查点并追溯选择最佳检查点 设置实验跟踪 [BatchNorm 的实现细节](#batchnorm 的实现细节) 多主机工作流的注意事项 常见问题的回答 致谢 引用 关于贡献 这份手册是为谁准备的？ link本文档适用于对最大化深度学习的性能感兴趣的工程师和研究人员（包括个人和团队）。我们假定您具备机器学习和深度学习概念的基本知识。
我们的重点是超参数调优的过程，但我们还涉及深度学习学习的其他方面。例如工作流实施和优化，但这些方面并不详尽
我们假设机器学习问题是监督学习或类似的东西（例如自监督学习）。但是，本文档中描述的技术也可能适用于其他类型的问题。
为什么需要这份调优手册？ link目前，要使深度神经网络在实践中正常运行，需要付出大量的努力和猜测。更糟糕的是，目前很少有人记录下那些深度学习中获得良好结果的实际方法。一方面，通常，论文忽略了导致最终结果的过程，以呈现更清晰的原理。另一方面，处理商业问题的机器学习工程师很少有时间回顾并概括他们的调参过程。教科书也往往回避实用指南，而偏重于基本原理，即使它们的作者具有在应用工作中提供有用建议的经验。在准备创建此文档时，我们找不到任何系统性的资料来解释如何使用深度学习获得良好的结果. 相反，我们看到了博客文章和社交媒体上的建议片段、从研究论文附录中收集的技巧、特定项目或工作流的偶然案例研究，以及很多困惑。在深度学习领域，专家和新手用着表面上类似的方法，但所取得的结果之间存在着巨大的差距。与此同时，这些专家也很乐意承认他们所做的一些事情可能没有充分的理由。随着深度学习的成熟并对世界产生更大的影响，社区需要更多涵盖有用方法的资源，包括对于获得良好结果至关重要的所有实用细节。
我们是一个由五名研究人员和工程师组成的团队，多年来一直致力于深度学习。我们已经将深度学习应用到从语音识别到天文学的方方面面，并在此过程中学到了很多东西。本文档源于我们自己训练神经网络、教授学生以及为我们的同事提供实践建议的经验。虽然深度学习已经从少数学术研究实验室中实践的机器学习方法发展成为为数十亿人使用的产品提供动力的技术，但深度学习在工程领域仍处于起步阶段，我们希望本文档能鼓励其他人也来帮助系统化该领域的实验细节。</description>
    </item>
    
  </channel>
</rss>
