<!DOCTYPE html>





    
        
    

    

    

    

<html lang="zh-cn"><head>
    <meta charset="utf-8" />
    <title>练习22：栈、作用域和全局 | CS技术文档</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="keywords" content="Documentation, Hugo, Hugo Theme, Bootstrap" />
    <meta name="author" content="Colin Wilson - Lotus Labs" />
    <meta name="email" content="support@aigis.uk" />
    <meta name="website" content="https://lotusdocs.dev" />
    <meta name="Version" content="v0.1.0" />
    
    <link rel="icon" href="https://cuterwrite.top/TechDocs/favicon.ico" sizes="any">
<link rel="icon" type="image/svg+xml" href="https://cuterwrite.top/TechDocs/favicon.svg">
<link rel="apple-touch-icon" sizes="180x180" href="https://cuterwrite.top/TechDocs/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://cuterwrite.top/TechDocs/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://cuterwrite.top/TechDocs/favicon-16x16.png">
<link rel="manifest" crossorigin="use-credentials" href="https://cuterwrite.top/TechDocs/site.webmanifest">

    
    <script>(()=>{var t=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,e=localStorage.getItem("theme");t&&e===null&&(localStorage.setItem("theme","dark"),document.documentElement.setAttribute("data-dark-mode","")),t&&e==="dark"&&document.documentElement.setAttribute("data-dark-mode",""),e==="dark"&&document.documentElement.setAttribute("data-dark-mode","")})()</script>
    
    
            
                
                <script type="text/javascript" src="https://cuterwrite.top/TechDocs/docs/js/flexsearch.bundle.min.249548594cb6843f3060a3cdd3043799676c59ce8db83358a3fc2e4d20598d05dfa6ce4994805d2835cb33b54dc9b9e7.js" integrity="sha384-JJVIWUy2hD8wYKPN0wQ3mWdsWc6NuDNYo/wuTSBZjQXfps5JlIBdKDXLM7VNybnn" crossorigin="anonymous"></script>
                
        
    
    
    
    
        
        
        
        
    
        
        
        
        
    
    
    <link rel="preconnect" href="https://fonts.gstatic.com/" />
    <link rel="preconnect" href="https://fonts.gstatic.com/" crossorigin />
    <link href="https://fonts.googleapis.com/css?family=Inter:300,400,600,700|Fira+Code:500,700&display=block" rel="stylesheet">

    <link rel="stylesheet" href="/TechDocs/docs/scss/style.min.5bb3dfeb65c03e070002541c55f854a7d4f6c68f39935b635fbe8d467961fb63a553660f6c0ec039e0472772a67aa8aa.css" integrity="sha384-W7Pf62XAPgcAAlQcVfhUp9T2xo85k1tjX76NRnlh&#43;2OlU2YPbA7AOeBHJ3Kmeqiq"crossorigin="anonymous">
    
    
    
    <script defer data-domain="lotusdocs.dev" data-api='/docs/s/api/event/' src='/docs/s/js/script.outbound-links.js'></script>
<script>window.plausible = window.plausible || function() { (window.plausible.q = window.plausible.q || []).push(arguments) }</script></head><body>
    <div class="content">
        <div class="page-wrapper toggled">
<nav id="sidebar" class="sidebar-wrapper">
    <div class="sidebar-brand">
        <a href='/TechDocs' aria-label="HomePage" alt="HomePage">
            
                <?xml version="1.0" encoding="UTF-8"?><svg id="Layer_1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 250 250"><path d="m143,39.5c-18,0-18,18-18,18,0,0,0-18-18-18H22c-2.76,0-5,2.24-5,5v143c0,2.76,2.24,5,5,5h76c7.2,0,8.64,11.52,8.93,16.13.07,1.05.95,1.87,2,1.87h32.14c1.06,0,1.94-.82,2-1.87.29-4.61,1.73-16.13,8.93-16.13h76c2.76,0,5-2.24,5-5V44.5c0-2.76-2.24-5-5-5h-85Zm63,123.5c0,1.38-1.12,2.5-2.5,2.5h-60.5c-18,0-18,18-18,18,0,0,0-18-18-18h-60.5c-1.38,0-2.5-1.12-2.5-2.5v-94c0-1.38,1.12-2.5,2.5-2.5h51.5c7.2,0,8.64,11.52,8.93,16.13.07,1.05.95,1.87,2,1.87h32.14c1.06,0,1.94-.82,2-1.87.29-4.61,1.73-16.13,8.93-16.13h51.5c1.38,0,2.5,1.12,2.5,2.5v94Z" style="fill:#06f;"/></svg>
            
        </a>
    </div>
    <div class="sidebar-content" style="height: calc(100% - 131px);">
        <ul class="sidebar-menu">
            
                
                
                    
                        
                        <li class="">
                            <a class="sidebar-root-link" href="https://cuterwrite.top/TechDocs/docs/overview/">
                                <i class="material-icons me-2">circle</i>
                                
                                前言
                            </a>
                        </li>
                    
                
                    
                        
                        <li class="">
                            <a class="sidebar-root-link" href="https://cuterwrite.top/TechDocs/docs/practical-programing-book/">
                                <i class="material-icons me-2">menu_book</i>
                                
                                计算机相关技术资料整理 
                            </a>
                        </li>
                    
                
                    
                    
                        <li class="sidebar-dropdown  ">
                            <button class="btn">
                                <i class="material-icons me-2">menu_book</i>
                                数据库技术
                            </button>
                            <div class="sidebar-submenu ">
                                <ul>
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF/readme/">Redis 指南</a></li>
                                        
                                    
                                </ul>
                            </div>
                        </li>
                    
                
                    
                    
                        <li class="sidebar-dropdown  current active">
                            <button class="btn">
                                <i class="material-icons me-2">menu_book</i>
                                笨方法学C
                            </button>
                            <div class="sidebar-submenu d-block">
                                <ul>
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/c-guide/summary/"></a></li>
                                        
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/c-guide/readme/">笨办法学C 中文版</a></li>
                                        
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/c-guide/preface/">前言</a></li>
                                        
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/c-guide/introduction/">导言：C的笛卡尔之梦</a></li>
                                        
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/c-guide/ex0/">练习0：准备</a></li>
                                        
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/c-guide/ex1/">练习1：启用编译器</a></li>
                                        
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/c-guide/ex2/">练习2：用Make来代替Python</a></li>
                                        
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/c-guide/ex3/">练习3：格式化输出</a></li>
                                        
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/c-guide/ex4/">练习4：Valgrind 介绍</a></li>
                                        
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/c-guide/ex5/">练习5：一个C程序的结构</a></li>
                                        
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/c-guide/ex6/">练习6：变量类型</a></li>
                                        
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/c-guide/ex7/">练习7：更多变量和一些算术</a></li>
                                        
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/c-guide/ex8/">练习8：大小和数组</a></li>
                                        
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/c-guide/ex9/">练习9：数组和字符串</a></li>
                                        
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/c-guide/ex10/">练习10：字符串数组和循环</a></li>
                                        
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/c-guide/ex11/">练习11：While循环和布尔表达式</a></li>
                                        
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/c-guide/ex12/">练习12：If，Else If，Else</a></li>
                                        
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/c-guide/ex13/">练习13：Switch语句</a></li>
                                        
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/c-guide/ex14/">练习14：编写并使用函数</a></li>
                                        
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/c-guide/ex15/">练习15：指针，可怕的指针</a></li>
                                        
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/c-guide/ex16/">练习16：结构体和指向它们的指针</a></li>
                                        
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/c-guide/ex17/">练习17：堆和栈的内存分配</a></li>
                                        
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/c-guide/ex18/">练习18：函数指针</a></li>
                                        
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/c-guide/ex19/">练习19：一个简单的对象系统</a></li>
                                        
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/c-guide/ex20/">练习20：Zed的强大的调试宏</a></li>
                                        
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/c-guide/ex21/">练习21：高级数据类型和控制结构</a></li>
                                        
                                    
                                        
                                        
                                            <li class="current "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/c-guide/ex22/">练习22：栈、作用域和全局</a></li>
                                        
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/c-guide/ex23/">练习23：认识达夫设备</a></li>
                                        
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/c-guide/ex24/">练习24：输入输出和文件</a></li>
                                        
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/c-guide/ex25/">练习25：变参函数</a></li>
                                        
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/c-guide/ex26/">练习26：编写第一个真正的程序</a></li>
                                        
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/c-guide/ex27/">练习27：创造性和防御性编程</a></li>
                                        
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/c-guide/ex28/">练习28：Makefile 进阶</a></li>
                                        
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/c-guide/ex29/">练习29：库和链接</a></li>
                                        
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/c-guide/ex30/">练习30：自动化测试</a></li>
                                        
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/c-guide/ex31/">练习31：代码调试</a></li>
                                        
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/c-guide/ex32/">练习32：双向链表</a></li>
                                        
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/c-guide/ex33/">练习33：链表算法</a></li>
                                        
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/c-guide/ex34/">练习34：动态数组</a></li>
                                        
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/c-guide/ex35/">练习35：排序和搜索</a></li>
                                        
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/c-guide/ex36/">练习36：更安全的字符串</a></li>
                                        
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/c-guide/ex37/">练习37：哈希表</a></li>
                                        
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/c-guide/ex38/">练习38：哈希算法</a></li>
                                        
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/c-guide/ex39/">练习39：字符串算法</a></li>
                                        
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/c-guide/ex40/">练习40：二叉搜索树</a></li>
                                        
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/c-guide/ex41/">练习41：将 Cachegrind 和 Callgrind 用于性能调优</a></li>
                                        
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/c-guide/ex42/">练习42：栈和队列</a></li>
                                        
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/c-guide/ex43/">练习43：一个简单的统计引擎</a></li>
                                        
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/c-guide/ex44/">练习44：环形缓冲区</a></li>
                                        
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/c-guide/ex45/">练习45：一个简单的TCP/IP客户端</a></li>
                                        
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/c-guide/ex46/">练习46：三叉搜索树</a></li>
                                        
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/c-guide/ex47/">练习47：一个快速的URL路由</a></li>
                                        
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/c-guide/postscript/">“解构 K&amp;R C” 已死</a></li>
                                        
                                    
                                        
                                        
                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/c-guide/donors/">捐赠名单</a></li>
                                        
                                    
                                </ul>
                            </div>
                        </li>
                    
                
                    
                    
                        <li class="sidebar-dropdown  ">
                            <button class="btn">
                                <i class="material-icons me-2">menu_book</i>
                                高性能计算竞赛存档
                            </button>
                            <div class="sidebar-submenu ">
                                <ul>
                                    
                                        
                                        
                                            <li class="sidebar-dropdown nested  ">
                                                <button class="btn">
                                                    
                                                    1. 高性能计算简介
                                                </button>
                                                <div class="sidebar-submenu ">
                                                    <ul>
                                                        
                                                            
                                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/hpcgame/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97%E7%AE%80%E4%BB%8B/1a/">A. 欢迎参赛</a></li>
                                                        
                                                            
                                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/hpcgame/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97%E7%AE%80%E4%BB%8B/1b/">B. 实验室的新机器</a></li>
                                                        
                                                            
                                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/hpcgame/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97%E7%AE%80%E4%BB%8B/1c/">C. 小北问答超速版</a></li>
                                                        
                                                            
                                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/hpcgame/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97%E7%AE%80%E4%BB%8B/1d/">D. 简单题</a></li>
                                                        
                                                    </ul>
                                                </div>
                                            </li>
                                        
                                    
                                        
                                        
                                            <li class="sidebar-dropdown nested  ">
                                                <button class="btn">
                                                    
                                                    2. 并行与大规模
                                                </button>
                                                <div class="sidebar-submenu ">
                                                    <ul>
                                                        
                                                            
                                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/hpcgame/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%A4%A7%E8%A7%84%E6%A8%A1/2a/">A. 求积分！</a></li>
                                                        
                                                            
                                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/hpcgame/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%A4%A7%E8%A7%84%E6%A8%A1/2b/">B. 乘一乘！</a></li>
                                                        
                                                            
                                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/hpcgame/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%A4%A7%E8%A7%84%E6%A8%A1/2c/">C. 解方程！</a></li>
                                                        
                                                            
                                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/hpcgame/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%A4%A7%E8%A7%84%E6%A8%A1/2d/">D. 道生一</a></li>
                                                        
                                                            
                                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/hpcgame/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%A4%A7%E8%A7%84%E6%A8%A1/2e/">E. 卷？寄！</a></li>
                                                        
                                                            
                                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/hpcgame/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%A4%A7%E8%A7%84%E6%A8%A1/2f/">F. MPI算个PI</a></li>
                                                        
                                                    </ul>
                                                </div>
                                            </li>
                                        
                                    
                                        
                                        
                                            <li class="sidebar-dropdown nested  ">
                                                <button class="btn">
                                                    
                                                    3. GPU上的并行计算
                                                </button>
                                                <div class="sidebar-submenu ">
                                                    <ul>
                                                        
                                                            
                                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/hpcgame/gpu%E4%B8%8A%E7%9A%84%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/3a/">A. 从头开始造AI</a></li>
                                                        
                                                            
                                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/hpcgame/gpu%E4%B8%8A%E7%9A%84%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/3b/">B. 神奇的焦散</a></li>
                                                        
                                                            
                                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/hpcgame/gpu%E4%B8%8A%E7%9A%84%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97/3c/">C. cuFFT并非不可战胜！</a></li>
                                                        
                                                    </ul>
                                                </div>
                                            </li>
                                        
                                    
                                        
                                        
                                            <li class="sidebar-dropdown nested  ">
                                                <button class="btn">
                                                    
                                                    4. 综合应用提升
                                                </button>
                                                <div class="sidebar-submenu ">
                                                    <ul>
                                                        
                                                            
                                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/hpcgame/%E7%BB%BC%E5%90%88%E5%BA%94%E7%94%A8%E6%8F%90%E5%8D%87/4a/">A. 走，我们扫雷去</a></li>
                                                        
                                                            
                                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/hpcgame/%E7%BB%BC%E5%90%88%E5%BA%94%E7%94%A8%E6%8F%90%E5%8D%87/4b/">AI算子优化</a></li>
                                                        
                                                            
                                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/hpcgame/%E7%BB%BC%E5%90%88%E5%BA%94%E7%94%A8%E6%8F%90%E5%8D%87/4c/">RDMA就是快</a></li>
                                                        
                                                    </ul>
                                                </div>
                                            </li>
                                        
                                    
                                        
                                        
                                            <li class="sidebar-dropdown nested  ">
                                                <button class="btn">
                                                    
                                                    5. 第二阶段题目
                                                </button>
                                                <div class="sidebar-submenu ">
                                                    <ul>
                                                        
                                                            
                                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/hpcgame/%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E9%A2%98%E7%9B%AE/finala/">A. 共轭梯度法</a></li>
                                                        
                                                            
                                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/hpcgame/%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E9%A2%98%E7%9B%AE/finalb/">B. 高性能存储阵列的软件开销优化</a></li>
                                                        
                                                            
                                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/hpcgame/%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E9%A2%98%E7%9B%AE/finalc/">C. 工程精度离散单元法计算程序优化</a></li>
                                                        
                                                            
                                                            <li class=" "><a class="sidebar-nested-link" href="https://cuterwrite.top/TechDocs/docs/hpcgame/%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E9%A2%98%E7%9B%AE/finald/">D. Linkpack节点的选择程序优化</a></li>
                                                        
                                                    </ul>
                                                </div>
                                            </li>
                                        
                                    
                                </ul>
                            </div>
                        </li>
                    
                
            
        </ul>
        
    </div>
    
        <ul class="sidebar-footer list-unstyled mb-0">
            
        </ul>
    
</nav>

                <main class="page-content bg-transparent">
<div id="top-header" class="top-header d-print-none">
    <div class="header-bar d-flex justify-content-between">
        <div class="d-flex align-items-center">
            <a href='/TechDocs' class="logo-icon me-3" aria-label="HomePage" alt="HomePage">
                <div class="small">
                    
                            <?xml version="1.0" encoding="UTF-8"?><svg id="Layer_1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 250 250"><path d="m143,39.5c-18,0-18,18-18,18,0,0,0-18-18-18H22c-2.76,0-5,2.24-5,5v143c0,2.76,2.24,5,5,5h76c7.2,0,8.64,11.52,8.93,16.13.07,1.05.95,1.87,2,1.87h32.14c1.06,0,1.94-.82,2-1.87.29-4.61,1.73-16.13,8.93-16.13h76c2.76,0,5-2.24,5-5V44.5c0-2.76-2.24-5-5-5h-85Zm63,123.5c0,1.38-1.12,2.5-2.5,2.5h-60.5c-18,0-18,18-18,18,0,0,0-18-18-18h-60.5c-1.38,0-2.5-1.12-2.5-2.5v-94c0-1.38,1.12-2.5,2.5-2.5h51.5c7.2,0,8.64,11.52,8.93,16.13.07,1.05.95,1.87,2,1.87h32.14c1.06,0,1.94-.82,2-1.87.29-4.61,1.73-16.13,8.93-16.13h51.5c1.38,0,2.5,1.12,2.5,2.5v94Z" style="fill:#06f;"/></svg>
                    
                </div>
                <div class="big">
                    
                            <?xml version="1.0" encoding="UTF-8"?><svg id="Layer_1" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 250 250"><path d="m143,39.5c-18,0-18,18-18,18,0,0,0-18-18-18H22c-2.76,0-5,2.24-5,5v143c0,2.76,2.24,5,5,5h76c7.2,0,8.64,11.52,8.93,16.13.07,1.05.95,1.87,2,1.87h32.14c1.06,0,1.94-.82,2-1.87.29-4.61,1.73-16.13,8.93-16.13h76c2.76,0,5-2.24,5-5V44.5c0-2.76-2.24-5-5-5h-85Zm63,123.5c0,1.38-1.12,2.5-2.5,2.5h-60.5c-18,0-18,18-18,18,0,0,0-18-18-18h-60.5c-1.38,0-2.5-1.12-2.5-2.5v-94c0-1.38,1.12-2.5,2.5-2.5h51.5c7.2,0,8.64,11.52,8.93,16.13.07,1.05.95,1.87,2,1.87h32.14c1.06,0,1.94-.82,2-1.87.29-4.61,1.73-16.13,8.93-16.13h51.5c1.38,0,2.5,1.12,2.5,2.5v94Z" style="fill:#06f;"/></svg>
                    
                </div>
            </a>
            <button id="close-sidebar" class="btn btn-icon btn-soft">
                <span class="material-icons size-20 menu-icon align-middle">menu</span>
            </button>
            
            
                    
                    <button id="flexsearch-button" class="ms-3 btn btn-soft" data-bs-toggle="collapse" data-bs-target="#FlexSearchCollapse" aria-expanded="false" aria-controls="FlexSearchCollapse">
                        <span class="material-icons size-20 menu-icon align-middle">search</span>
                        <span class="flexsearch-button-placeholder ms-1 me-2 d-none d-sm-block">Search</span>
                        <div class="d-none d-sm-block">
                            <span class="flexsearch-button-keys">
                                <kbd class="flexsearch-button-cmd-key">
                                    <svg width="44" height="15"><path d="M2.118,11.5A1.519,1.519,0,0,1,1,11.042,1.583,1.583,0,0,1,1,8.815a1.519,1.519,0,0,1,1.113-.458h.715V6.643H2.118A1.519,1.519,0,0,1,1,6.185,1.519,1.519,0,0,1,.547,5.071,1.519,1.519,0,0,1,1,3.958,1.519,1.519,0,0,1,2.118,3.5a1.519,1.519,0,0,1,1.114.458A1.519,1.519,0,0,1,3.69,5.071v.715H5.4V5.071A1.564,1.564,0,0,1,6.976,3.5,1.564,1.564,0,0,1,8.547,5.071,1.564,1.564,0,0,1,6.976,6.643H6.261V8.357h.715a1.575,1.575,0,0,1,1.113,2.685,1.583,1.583,0,0,1-2.227,0A1.519,1.519,0,0,1,5.4,9.929V9.214H3.69v.715a1.519,1.519,0,0,1-.458,1.113A1.519,1.519,0,0,1,2.118,11.5Zm0-.857a.714.714,0,0,0,.715-.714V9.214H2.118a.715.715,0,1,0,0,1.429Zm4.858,0a.715.715,0,1,0,0-1.429H6.261v.715a.714.714,0,0,0,.715.714ZM3.69,8.357H5.4V6.643H3.69ZM2.118,5.786h.715V5.071a.714.714,0,0,0-.715-.714.715.715,0,0,0-.5,1.22A.686.686,0,0,0,2.118,5.786Zm4.143,0h.715a.715.715,0,0,0,.5-1.22.715.715,0,0,0-1.22.5Z" fill="currentColor"></path><path d="M12.4,11.475H11.344l3.879-7.95h1.056Z" fill="currentColor"></path><path d="M25.073,5.384l-.864.576a2.121,2.121,0,0,0-1.786-.923,2.207,2.207,0,0,0-2.266,2.326,2.206,2.206,0,0,0,2.266,2.325,2.1,2.1,0,0,0,1.782-.918l.84.617a3.108,3.108,0,0,1-2.622,1.293,3.217,3.217,0,0,1-3.349-3.317,3.217,3.217,0,0,1,3.349-3.317A3.046,3.046,0,0,1,25.073,5.384Z" fill="currentColor"></path><path d="M30.993,5.142h-2.07v5.419H27.891V5.142h-2.07V4.164h5.172Z" fill="currentColor"></path><path d="M34.67,4.164c1.471,0,2.266.658,2.266,1.851,0,1.087-.832,1.809-2.134,1.855l2.107,2.691h-1.28L33.591,7.87H33.07v2.691H32.038v-6.4Zm-1.6.969v1.8h1.572c.832,0,1.22-.3,1.22-.918s-.411-.882-1.22-.882Z" fill="currentColor"></path><path d="M42.883,10.561H38.31v-6.4h1.033V9.583h3.54Z" fill="currentColor"></path></svg>
                                </kbd>
                                <kbd class="flexsearch-button-key">
                                    <svg width="15" height="15"><path d="M5.926,12.279H4.41L9.073,2.721H10.59Z" fill="currentColor"/></svg>
                                </kbd>
                            </span>
                        </div>
                    </button>
                
            </div>

        <div class="d-flex align-items-center">
            <ul class="list-unstyled mb-0">
                
                
                    
                    <li class="list-inline-item mb-0">
                        <a href=" https://github.com/PKUColdkeyboard " alt="github" rel="noopener noreferrer" target="_blank">
                            <div class="btn btn-icon btn-default border-0">
                                
                                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><title>GitHub</title><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg>
                                
                            </div>
                        </a>
                    </li>
                    
                
            </ul>
            <button id="mode" class="btn btn-icon btn-default ms-2" type="button" aria-label="Toggle user interface mode">
                <span class="toggle-dark">
                    <svg xmlns="http://www.w3.org/2000/svg" height="30" width="30" viewBox="0 0 48 48" fill="currentColor"><path d="M24 42q-7.5 0-12.75-5.25T6 24q0-7.5 5.25-12.75T24 6q.4 0 .85.025.45.025 1.15.075-1.8 1.6-2.8 3.95-1 2.35-1 4.95 0 4.5 3.15 7.65Q28.5 25.8 33 25.8q2.6 0 4.95-.925T41.9 22.3q.05.6.075.975Q42 23.65 42 24q0 7.5-5.25 12.75T24 42Zm0-3q5.45 0 9.5-3.375t5.05-7.925q-1.25.55-2.675.825Q34.45 28.8 33 28.8q-5.75 0-9.775-4.025T19.2 15q0-1.2.25-2.575.25-1.375.9-3.125-4.9 1.35-8.125 5.475Q9 18.9 9 24q0 6.25 4.375 10.625T24 39Zm-.2-14.85Z"/></svg>
                </span>
                <span class="toggle-light">
                    <svg xmlns="http://www.w3.org/2000/svg" height="30" width="30" viewBox="0 0 48 48" fill="currentColor"><path d="M24 31q2.9 0 4.95-2.05Q31 26.9 31 24q0-2.9-2.05-4.95Q26.9 17 24 17q-2.9 0-4.95 2.05Q17 21.1 17 24q0 2.9 2.05 4.95Q21.1 31 24 31Zm0 3q-4.15 0-7.075-2.925T14 24q0-4.15 2.925-7.075T24 14q4.15 0 7.075 2.925T34 24q0 4.15-2.925 7.075T24 34ZM3.5 25.5q-.65 0-1.075-.425Q2 24.65 2 24q0-.65.425-1.075Q2.85 22.5 3.5 22.5h5q.65 0 1.075.425Q10 23.35 10 24q0 .65-.425 1.075-.425.425-1.075.425Zm36 0q-.65 0-1.075-.425Q38 24.65 38 24q0-.65.425-1.075.425-.425 1.075-.425h5q.65 0 1.075.425Q46 23.35 46 24q0 .65-.425 1.075-.425.425-1.075.425ZM24 10q-.65 0-1.075-.425Q22.5 9.15 22.5 8.5v-5q0-.65.425-1.075Q23.35 2 24 2q.65 0 1.075.425.425.425.425 1.075v5q0 .65-.425 1.075Q24.65 10 24 10Zm0 36q-.65 0-1.075-.425-.425-.425-.425-1.075v-5q0-.65.425-1.075Q23.35 38 24 38q.65 0 1.075.425.425.425.425 1.075v5q0 .65-.425 1.075Q24.65 46 24 46ZM12 14.1l-2.85-2.8q-.45-.45-.425-1.075.025-.625.425-1.075.45-.45 1.075-.45t1.075.45L14.1 12q.4.45.4 1.05 0 .6-.4 1-.4.45-1.025.45-.625 0-1.075-.4Zm24.7 24.75L33.9 36q-.4-.45-.4-1.075t.45-1.025q.4-.45 1-.45t1.05.45l2.85 2.8q.45.45.425 1.075-.025.625-.425 1.075-.45.45-1.075.45t-1.075-.45ZM33.9 14.1q-.45-.45-.45-1.05 0-.6.45-1.05l2.8-2.85q.45-.45 1.075-.425.625.025 1.075.425.45.45.45 1.075t-.45 1.075L36 14.1q-.4.4-1.025.4-.625 0-1.075-.4ZM9.15 38.85q-.45-.45-.45-1.075t.45-1.075L12 33.9q.45-.45 1.05-.45.6 0 1.05.45.45.45.45 1.05 0 .6-.45 1.05l-2.8 2.85q-.45.45-1.075.425-.625-.025-1.075-.425ZM24 24Z"/></svg>
                </span>
            </button>
            
        </div>
    </div>
    
    
            <div class="collapse" id="FlexSearchCollapse">
                <div class="flexsearch-container">
                    <div class="flexsearch-keymap">
                        <li>
                            <kbd class="flexsearch-button-cmd-key"><svg width="15" height="15" aria-label="Arrow down" role="img"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.2"><path d="M7.5 3.5v8M10.5 8.5l-3 3-3-3"></path></g></svg></kbd>
                            <kbd class="flexsearch-button-cmd-key"><svg width="15" height="15" aria-label="Arrow up" role="img"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.2"><path d="M7.5 11.5v-8M10.5 6.5l-3-3-3 3"></path></g></svg></kbd>
                            <span class="flexsearch-key-label">to navigate</span>
                        </li>
                        <li>
                            <kbd class="flexsearch-button-cmd-key"><svg width="15" height="15" aria-label="Enter key" role="img"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.2"><path d="M12 3.53088v3c0 1-1 2-2 2H4M7 11.53088l-3-3 3-3"></path></g></svg></kbd>
                            <span class="flexsearch-key-label">to select</span>
                        </li>
                        <li>
                            <kbd class="flexsearch-button-cmd-key"><svg width="15" height="15" aria-label="Escape key" role="img"><g fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="1.2"><path d="M13.6167 8.936c-.1065.3583-.6883.962-1.4875.962-.7993 0-1.653-.9165-1.653-2.1258v-.5678c0-1.2548.7896-2.1016 1.653-2.1016.8634 0 1.3601.4778 1.4875 1.0724M9 6c-.1352-.4735-.7506-.9219-1.46-.8972-.7092.0246-1.344.57-1.344 1.2166s.4198.8812 1.3445.9805C8.465 7.3992 8.968 7.9337 9 8.5c.032.5663-.454 1.398-1.4595 1.398C6.6593 9.898 6 9 5.963 8.4851m-1.4748.5368c-.2635.5941-.8099.876-1.5443.876s-1.7073-.6248-1.7073-2.204v-.4603c0-1.0416.721-2.131 1.7073-2.131.9864 0 1.6425 1.031 1.5443 2.2492h-2.956"></path></g></svg></kbd>
                            <span class="flexsearch-key-label">to close</span>
                        </li>
                    </div>
                    <form class="flexsearch position-relative flex-grow-1 ms-2 me-2">
                        <div class="d-flex flex-row">
                            <input id="flexsearch" class="form-control" type="search" placeholder="Search" aria-label="Search" autocomplete="off">
                            <button id="hideFlexsearch" type="button" class="ms-2 btn btn-soft">
                                cancel
                            </button>
                        </div>
                        <div id="suggestions" class="shadow rounded-1 d-none"></div>
                    </form>
                </div>
            </div>
        
    
    
</div>
<div class="container-fluid">
                            <div class="layout-spacing">
                                
                                    <div class="d-md-flex justify-content-between align-items-center"><nav aria-label="breadcrumb" class="d-inline-block pb-2 mt-1 mt-sm-0">
    <ul id="breadcrumbs" class="breadcrumb bg-transparent mb-0" itemscope itemtype="https://schema.org/BreadcrumbList">
        
            
                <li class="breadcrumb-item text-capitalize active" aria-current="page" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
                    <a itemprop="item" href="/TechDocs/docs/">
                        <i class="material-icons size-20 align-text-bottom" itemprop="name">Home</i>
                    </a>
                    <meta itemprop="position" content='1' />
                </li>
            
            
                <li class="breadcrumb-item text-capitalize" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
                    <a itemprop="item" href="/TechDocs/docs/c-guide/">
                        <span itemprop="name">笨方法学C</span>
                    </a>
                    <meta itemprop="position" content='2' />
                </li>
            
        
            <li class="breadcrumb-item text-capitalize active" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
                <span itemprop="name">练习22：栈、作用域和全局</span>
                <meta itemprop="position" content='3' />
            </li>
        
    </ul>
</nav></div>
                                
                                <div class="row flex-xl-nowrap">
                                    
                                    <div class="docs-toc col-xl-3    d-xl-block"><toc>
    <div class="fw-bold text-uppercase mb-2">On this page</div>
    <nav id="toc">
  <ul>
    <li>
      <ul>
        <li><a href="#ex22h-和-ex22c">ex22.h 和 ex22.c</a></li>
        <li><a href="#ex22_mainc">ex22_main.c</a></li>
        <li><a href="#你会看到什么">你会看到什么</a></li>
        <li><a href="#作用域栈和bug">作用域、栈和Bug</a></li>
        <li><a href="#如何使它崩溃">如何使它崩溃</a></li>
        <li><a href="#附加题">附加题</a></li>
      </ul>
    </li>
  </ul>
</nav>
    </toc></div>
                                    
                                    
                                    <div class="docs-toc-mobile    d-print-none d-xl-none">
                                        <button id="toc-dropdown-btn" class="btn-secondary dropdown-toggle" type="button" data-bs-toggle="dropdown" data-bs-offset="0,0" aria-expanded="false">
                                            Table of Contents
                                        </button>
<nav id="toc-mobile">
  <ul class="dropdown-menu">
    <li>
      <ul>
        <li><a href="#ex22h-和-ex22c">ex22.h 和 ex22.c</a></li>
        <li><a href="#ex22_mainc">ex22_main.c</a></li>
        <li><a href="#你会看到什么">你会看到什么</a></li>
        <li><a href="#作用域栈和bug">作用域、栈和Bug</a></li>
        <li><a href="#如何使它崩溃">如何使它崩溃</a></li>
        <li><a href="#附加题">附加题</a></li>
      </ul>
    </li>
  </ul>
</nav></div>
                                    <div class="docs-content col-12 col-xl-9 mt-0">
                                        <div class="mb-0 d-flex">
                                            
                                            <h1 class="content-title mb-0">
                                                <span class="title-text">
                                                    练习22：栈、作用域和全局
                                                </span>
                                                
                                            </h1>
                                        </div>
                                        
                                            <p class="lead mb-3"></p>
                                        
                                        <div id="content" class="main-content" data-bs-spy="scroll" data-bs-root-margin="0px 0px -65%" data-bs-target="#toc-mobile">
                                            
    
    <div data-prismjs-copy="" data-prismjs-copy-success="" data-prismjs-copy-error="">
        <blockquote>
<p>原文：<a href="http://c.learncodethehardway.org/book/ex22.html" rel="external" target="_blank">Exercise 22: The Stack, Scope, And Globals<svg width="16" height="16" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M14 5c-.552 0-1-.448-1-1s.448-1 1-1h6c.552 0 1 .448 1 1v6c0 .552-.448 1-1 1s-1-.448-1-1v-3.586l-7.293 7.293c-.391.39-1.024.39-1.414 0-.391-.391-.391-1.024 0-1.414l7.293-7.293h-3.586zm-9 2c-.552 0-1 .448-1 1v11c0 .552.448 1 1 1h11c.552 0 1-.448 1-1v-4.563c0-.552.448-1 1-1s1 .448 1 1v4.563c0 1.657-1.343 3-3 3h-11c-1.657 0-3-1.343-3-3v-11c0-1.657 1.343-3 3-3h4.563c.552 0 1 .448 1 1s-.448 1-1 1h-4.563z"/></svg></a></p>
</blockquote>
<blockquote>
<p>译者：<a href="https://github.com/wizardforcel" rel="external" target="_blank">飞龙<svg width="16" height="16" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M14 5c-.552 0-1-.448-1-1s.448-1 1-1h6c.552 0 1 .448 1 1v6c0 .552-.448 1-1 1s-1-.448-1-1v-3.586l-7.293 7.293c-.391.39-1.024.39-1.414 0-.391-.391-.391-1.024 0-1.414l7.293-7.293h-3.586zm-9 2c-.552 0-1 .448-1 1v11c0 .552.448 1 1 1h11c.552 0 1-.448 1-1v-4.563c0-.552.448-1 1-1s1 .448 1 1v4.563c0 1.657-1.343 3-3 3h-11c-1.657 0-3-1.343-3-3v-11c0-1.657 1.343-3 3-3h4.563c.552 0 1 .448 1 1s-.448 1-1 1h-4.563z"/></svg></a></p>
</blockquote>
<p>许多人在开始编程时，对“作用域”这个概念都不是很清楚。起初它来源于系统栈的使用方式（在之前提到过一些），以及它用于临时变量储存的方式。这个练习中，我们会通过学习栈数据结构如何工作来了解作用域，然后再来看看现代C语言处理作用域的方式。</p>
<p>这个练习的真正目的是了解一些比较麻烦的东西在C中如何存储。当一个人没有掌握作用域的概念时，它几乎也不能理解变量在哪里被创建，存在以及销毁。一旦你知道了这些，作用域的概念会变得易于理解。</p>
<p>这个练习需要如下三个文件：</p>
<p><code>ex22.h</code></p>
<p>用于创建一些外部变量和一些函数的头文件。</p>
<p><code>ex22.c</code></p>
<p>它并不像通常一样，是包含<code>main</code>的源文件，而是含有一些<code>ex22.h</code>中声明的函数和变量，并且会变成<code>ex22.o</code>。</p>
<p><code>ex22_main.c</code></p>
<p><code>main</code>函数实际所在的文件，它会包含另外两个文件，并演示了它们包含的东西以及其它作用域概念。</p>
<h2 id="ex22h-和-ex22c">ex22.h 和 ex22.c <a href="#ex22h-%e5%92%8c-ex22c" class="anchor" aria-hidden="true"><i class="material-icons align-middle">link</i></a></h2><p>你的第一步是创建你自己的<code>ex22.h</code>头文件，其中定义了所需的函数和“导出”变量。</p>



  
  
  

  
  
  
  

  

  <div class="prism-codeblock ">
  <pre id="4bd4690" class="language-c ">
  <code>#ifndef _ex22_h
#define _ex22_h

// makes THE_SIZE in ex22.c available to other .c files
extern int THE_SIZE;

// gets and sets an internal static variable in ex22.c
int get_age();
void set_age(int age);

// updates a static variable that&#39;s inside update_ratio
double update_ratio(double ratio);

void print_size();

#endif</code>
  </pre>
  </div>
<p>最重要的事情是<code>extern int THE_SIZE</code>的用法，我将会在你创建完<code>ex22.c</code>之后解释它：</p>



  
  
  

  
  
  
  

  

  <div class="prism-codeblock ">
  <pre id="8129d06" class="language-c ">
  <code>#include &lt;stdio.h&gt;
#include &#34;ex22.h&#34;
#include &#34;dbg.h&#34;

int THE_SIZE = 1000;

static int THE_AGE = 37;

int get_age()
{
    return THE_AGE;
}

void set_age(int age)
{
    THE_AGE = age;
}


double update_ratio(double new_ratio)
{
    static double ratio = 1.0;

    double old_ratio = ratio;
    ratio = new_ratio;

    return old_ratio;
}

void print_size()
{
    log_info(&#34;I think size is: %d&#34;, THE_SIZE);
}</code>
  </pre>
  </div>
<p>这两个文件引入了一些新的变量储存方式：</p>
<p><code>extern</code></p>
<p>这个关键词告诉编译器“这个变量已存在，但是他在别的‘外部区域’里”。通常它的意思是一个<code>.c</code>文件要用到另一个<code>.c</code>文件中定义的变量。这种情况下，我们可以说<code>ex22.c</code>中的<code>THE_SIZE</code>变量能被<code>ex22_main.c</code>访问到。</p>
<p><code>static</code>（文件）</p>
<p>这个关键词某种意义上是<code>extern</code>的反义词，意思是这个变量只能在当前的<code>.c</code>文件中使用，程序的其它部分不可访问。要记住文件级别的<code>static</code>（比如这里的<code>THE_AGE</code>）和其它位置不同。</p>
<p><code>static</code>（函数）</p>
<p>如果你使用<code>static</code>在函数中声明变量，它和文件中的<code>static</code>定义类似，但是只能够在该函数中访问。它是一种创建某个函数的持续状态的方法，但事实上它很少用于现代的C语言，因为它们很难和线程一起使用。</p>
<p>在上面的两个文件中，你需要理解如下几个变量和函数：</p>
<p><code>THE_SIZE</code></p>
<p>这个你使用<code>extern</code>声明的变量将会在<code>ex22_main.c</code>中用到。</p>
<p><code>get_age</code>和<code>set_age</code></p>
<p>它们用于操作静态变量<code>THE_AGE</code>，并通过函数将其暴露给程序的其它部分。你不能够直接访问到<code>THE_AGE</code>，但是这些函数可以。</p>
<p><code>update_ratio</code></p>
<p>它生成新的<code>ratio</code>值并返回旧的值。它使用了函数级的静态变量<code>ratio</code>来跟踪<code>ratio</code>当前的值。</p>
<p><code>print_size</code></p>
<p>打印出<code>ex22.c</code>所认为的<code>THE_SIZE</code>的当前值。</p>
<h2 id="ex22_mainc">ex22_main.c <a href="#ex22_mainc" class="anchor" aria-hidden="true"><i class="material-icons align-middle">link</i></a></h2><p>一旦你写完了上面那些文件，你可以接着编程<code>main</code>函数，它会使用所有上面的文件并且演示了一些更多的作用域转换：</p>



  
  
  

  
  
  
  

  

  <div class="prism-codeblock ">
  <pre id="bf655e4" class="language-c ">
  <code>#include &#34;ex22.h&#34;
#include &#34;dbg.h&#34;

const char *MY_NAME = &#34;Zed A. Shaw&#34;;

void scope_demo(int count)
{
    log_info(&#34;count is: %d&#34;, count);

    if(count &gt; 10) {
        int count = 100;  // BAD! BUGS!

        log_info(&#34;count in this scope is %d&#34;, count);
    }

    log_info(&#34;count is at exit: %d&#34;, count);

    count = 3000;

    log_info(&#34;count after assign: %d&#34;, count);
}

int main(int argc, char *argv[])
{
    // test out THE_AGE accessors
    log_info(&#34;My name: %s, age: %d&#34;, MY_NAME, get_age());

    set_age(100);

    log_info(&#34;My age is now: %d&#34;, get_age());

    // test out THE_SIZE extern
    log_info(&#34;THE_SIZE is: %d&#34;, THE_SIZE);
    print_size();

    THE_SIZE = 9;

    log_info(&#34;THE SIZE is now: %d&#34;, THE_SIZE);
    print_size();

    // test the ratio function static
    log_info(&#34;Ratio at first: %f&#34;, update_ratio(2.0));
    log_info(&#34;Ratio again: %f&#34;, update_ratio(10.0));
    log_info(&#34;Ratio once more: %f&#34;, update_ratio(300.0));

    // test the scope demo
    int count = 4;
    scope_demo(count);
    scope_demo(count * 20);

    log_info(&#34;count after calling scope_demo: %d&#34;, count);

    return 0;
}</code>
  </pre>
  </div>
<p>我会把这个文件逐行拆分，你应该能够找到我提到的每个变量在哪里定义。</p>
<p>ex22_main.c:4</p>
<p>使用了<code>const</code>来创建常量，它可用于替代<code>define</code>来创建常量。</p>
<p>ex22_main.c:6</p>
<p>一个简单的函数，演示了函数中更多的作用域问题。</p>
<p>ex22_main.c:8</p>
<p>在函数顶端打印出<code>count</code>的值。</p>
<p>ex22_main.c:10</p>
<p><code>if</code>语句会开启一个新的作用域区块，并且在其中创建了另一个<code>count</code>变量。这个版本的<code>count</code>变量是一个全新的变量。<code>if</code>语句就好像开启了一个新的“迷你函数”。</p>
<p>ex22_main.c:11</p>
<p><code>count</code>对于当前区块是局部变量，实际上不同于函数参数列表中的参数。</p>
<p>ex22_main.c:13</p>
<p>将它打印出来，所以你可以在这里看到100，并不是传给<code>scope_demo</code>的参数。</p>
<p>ex22_main.c:16</p>
<p>这里是最难懂得部分。你在两部分都有<code>count</code>变量，一个数函数参数，另一个是<code>if</code>语句中。<code>if</code>语句创建了新的代码块，所以11行的<code>count</code>并不影响同名的参数。这一行将其打印出来，你会看到它打印了参数的值而不是100。</p>
<p>ex22_main.c:18-20</p>
<p>之后我将<code>count</code>参数设为3000并且打印出来，这里演示了你也可以修改函数参数的值，但并不会影响变量的调用者版本。</p>
<p>确保你浏览了整个函数，但是不要认为你已经十分了解作用娱乐。如果你在一个代码块中（比如<code>if</code>或<code>while</code>语句）创建了一些变量，这些变量是全新的变量，并且只在这个代码块中存在。这是至关重要的东西，也是许多bug的来源。我要强调你应该在这里花一些时间。</p>
<p><code>ex22_main.c</code>的剩余部分通过操作和打印变量演示了它们的全部。</p>
<p>ex22_main.c:26</p>
<p>打印出<code>MY_NAME</code>的当前值，并且使用<code>get_age</code>读写器从<code>ex22.c</code>获取<code>THE_AGE</code>。</p>
<p>ex22_main.c:27-30</p>
<p>使用了<code>ex22.c</code>中的<code>set_age</code>来修改并打印<code>THE_AGE</code>。</p>
<p>ex22_main.c:33-39</p>
<p>接下来我对<code>ex22.c</code>中的<code>THE_SIZE</code>做了相同的事情，但这一次我直接访问了它，并且同时演示了它实际上在那个文件中已经修改了，还使用<code>print_size</code>打印了它。</p>
<p>ex22_main.c:42-44</p>
<p>展示了<code>update_ratio</code>中的<code>ratio</code>在两次函数调用中如何保持了它的值。</p>
<p>ex22_main.c:46-51</p>
<p>最后运行<code>scope_demo</code>，你可以在实例中观察到作用域。要注意到的关键点是，<code>count</code>局部变量在调用后保持不变。你将它像一个变量一样传入函数，它一定不会发生改变。要想达到目的你需要我们的老朋友指针。如果你将指向<code>count</code>的指针传入函数，那么函数就会持有它的地址并且能够改变它。</p>
<p>上面解释了这些文件中所发生的事情，但是你应该跟踪它们，并且确保在你学习的过程中明白了每个变量都在什么位置。</p>
<h2 id="你会看到什么">你会看到什么 <a href="#%e4%bd%a0%e4%bc%9a%e7%9c%8b%e5%88%b0%e4%bb%80%e4%b9%88" class="anchor" aria-hidden="true"><i class="material-icons align-middle">link</i></a></h2><p>这次我想让你手动构建这两个文件，而不是使用你的<code>Makefile</code>。于是你可以看到它们实际上如何被编译器放到一起。这是你应该做的事情，并且你应该看到如下输出：</p>



  
  
  

  
  
  
  

  

  <div class="prism-codeblock ">
  <pre id="57babf7" class="language-sh ">
  <code>$ cc -Wall -g -DNDEBUG   -c -o ex22.o ex22.c
$ cc -Wall -g -DNDEBUG    ex22_main.c ex22.o   -o ex22_main
$ ./ex22_main
[INFO] (ex22_main.c:26) My name: Zed A. Shaw, age: 37
[INFO] (ex22_main.c:30) My age is now: 100
[INFO] (ex22_main.c:33) THE_SIZE is: 1000
[INFO] (ex22.c:32) I think size is: 1000
[INFO] (ex22_main.c:38) THE SIZE is now: 9
[INFO] (ex22.c:32) I think size is: 9
[INFO] (ex22_main.c:42) Ratio at first: 1.000000
[INFO] (ex22_main.c:43) Ratio again: 2.000000
[INFO] (ex22_main.c:44) Ratio once more: 10.000000
[INFO] (ex22_main.c:8) count is: 4
[INFO] (ex22_main.c:16) count is at exit: 4
[INFO] (ex22_main.c:20) count after assign: 3000
[INFO] (ex22_main.c:8) count is: 80
[INFO] (ex22_main.c:13) count in this scope is 100
[INFO] (ex22_main.c:16) count is at exit: 80
[INFO] (ex22_main.c:20) count after assign: 3000
[INFO] (ex22_main.c:51) count after calling scope_demo: 4</code>
  </pre>
  </div>
<p>确保你跟踪了每个变量是如何改变的，并且将其匹配到所输出的那一行。我使用了<code>dbg.h</code>的<code>log_info</code>来让你获得每个变量打印的具体行号，并且在文件中找到它用于跟踪。</p>
<h2 id="作用域栈和bug">作用域、栈和Bug <a href="#%e4%bd%9c%e7%94%a8%e5%9f%9f%e6%a0%88%e5%92%8cbug" class="anchor" aria-hidden="true"><i class="material-icons align-middle">link</i></a></h2><p>如果你正确完成了这个练习，你会看到有很多不同方式在C代码中放置变量。你可以使用<code>extern</code>或者访问类似<code>get_age</code>的函数来创建全局。你也可以在任何代码块中创建新的变量，它们在退出代码块之前会拥有自己的值，并且屏蔽掉外部的变量。你也可以响函数传递一个值并且修改它，但是调用者的变量版本不会发生改变。</p>
<p>需要理解的最重要的事情是，这些都可以造成bug。C中在你机器中许多位置放置和访问变量的能力会让你对它们所在的位置感到困扰。如果你不知道它们的位置，你就可能不能适当地管理它们。</p>
<p>下面是一些编程C代码时需要遵循的规则，可以让你避免与栈相关的bug：</p>
<ul>
<li>不要隐藏某个变量，就像上面<code>scope_demo</code>中对<code>count</code>所做的一样。这可能会产生一些隐蔽的bug，你认为你改变了某个变量但实际上没有。</li>
<li>避免过多的全局变量，尤其是跨越多个文件。如果必须的话，要使用读写器函数，就像<code>get_age</code>。这并不适用于常量，因为它们是只读的。我是说对于<code>THE_SIZE</code>这种变量，如果你希望别人能够修改它，就应该使用读写器函数。</li>
<li>在你不清楚的情况下，应该把它放在堆上。不要依赖于栈的语义，或者指定区域，而是要直接使用<code>malloc</code>创建它。</li>
<li>不要使用函数级的静态变量，就像<code>update_ratio</code>。它们并不有用，而且当你想要使你的代码运行在多线程环境时，会有很大的隐患。对于良好的全局变量，它们也非常难于寻找。</li>
<li>避免复用函数参数，因为你搞不清楚仅仅想要复用它还是希望修改它的调用者版本。</li>
</ul>
<h2 id="如何使它崩溃">如何使它崩溃 <a href="#%e5%a6%82%e4%bd%95%e4%bd%bf%e5%ae%83%e5%b4%a9%e6%ba%83" class="anchor" aria-hidden="true"><i class="material-icons align-middle">link</i></a></h2><p>对于这个练习，崩溃这个程序涉及到尝试访问或修改你不能访问的东西。</p>
<ul>
<li>试着从<code>ex22_main.c</code>直接访问<code>ex22.c</code>中的你不能访问变量。例如，你能不能获取<code>update_ratio</code>中的<code>ratio</code>？如果你用一个指针指向它会发生什么？</li>
<li>移除<code>ex22.h</code>的<code>extern</code>声明，来观察会得到什么错误或警告。</li>
<li>对不同变量添加<code>static</code>或者<code>const</code>限定符，之后尝试修改它们。</li>
</ul>
<h2 id="附加题">附加题 <a href="#%e9%99%84%e5%8a%a0%e9%a2%98" class="anchor" aria-hidden="true"><i class="material-icons align-middle">link</i></a></h2><ul>
<li>研究“值传递”和“引用传递”的差异，并且为二者编写示例。（译者注：C中没有引用传递，你可以搜索“指针传递”。）</li>
<li>使用指针来访问原本不能访问的变量。</li>
<li>使用<code>Valgrind</code>来观察错误的访问是什么样子。</li>
<li>编写一个递归调用并导致栈溢出的函数。如果不知道递归函数是什么的话，试着在<code>scope_demo</code>底部调用<code>scope_demo</code>本身，会形成一种循环。</li>
<li>重新编写<code>Makefile</code>使之能够构建这些文件。</li>
</ul>

    </div>

    





    
    






<div class="gitinfo d-flex flex-wrap justify-content-between align-items-center opacity-85 pt-3">
    <div id="edit-this-page" class="mt-1">
        <a href="https://github.com/PKUColdkeyboard/TechDocs/blob/main/content/docs/c-guide/ex22.md" alt="练习22：栈、作用域和全局" rel="noopener noreferrer" target="_blank">
            
            <span class="me-1 align-text-bottom">
                
                    <svg width="20px" height="20px" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg" fill="currentColor">
  <path d="M16 0.396c-8.839 0-16 7.167-16 16 0 7.073 4.584 13.068 10.937 15.183 0.803 0.151 1.093-0.344 1.093-0.772 0-0.38-0.009-1.385-0.015-2.719-4.453 0.964-5.391-2.151-5.391-2.151-0.729-1.844-1.781-2.339-1.781-2.339-1.448-0.989 0.115-0.968 0.115-0.968 1.604 0.109 2.448 1.645 2.448 1.645 1.427 2.448 3.744 1.74 4.661 1.328 0.14-1.031 0.557-1.74 1.011-2.135-3.552-0.401-7.287-1.776-7.287-7.907 0-1.751 0.62-3.177 1.645-4.297-0.177-0.401-0.719-2.031 0.141-4.235 0 0 1.339-0.427 4.4 1.641 1.281-0.355 2.641-0.532 4-0.541 1.36 0.009 2.719 0.187 4 0.541 3.043-2.068 4.381-1.641 4.381-1.641 0.859 2.204 0.317 3.833 0.161 4.235 1.015 1.12 1.635 2.547 1.635 4.297 0 6.145-3.74 7.5-7.296 7.891 0.556 0.479 1.077 1.464 1.077 2.959 0 2.14-0.020 3.864-0.020 4.385 0 0.416 0.28 0.916 1.104 0.755 6.4-2.093 10.979-8.093 10.979-15.156 0-8.833-7.161-16-16-16z"/>
</svg>

                
            </span>
            Edit this page
            
        </a>
    </div>
    
    <div id="last-modified" class="mt-1">
        <p class="mb-0 fw-semibold">Last updated <span
            id="relativetime"
            data-authdate="2023-09-15T23:30:48&#43;0800"
            title="15 Sep 2023, 23:30 &#43;0800">
            15 Sep 2023, 23:30 &#43;0800
        </span>. <span class="material-icons size-20 align-text-bottom opacity-75">history</span>
        </p>
    </div>
    
</div>

    

    
                                        </div>
                                        <div><hr class="doc-hr">
<div id="doc-nav" class="d-print-none">

	<div class="row flex-xl-nowrap ">
	<div class="col-sm-6 pt-2 doc-next">
		<a href="/TechDocs/docs/c-guide/ex21/">
			<div class="card h-100 my-1">
				<div class="card-body py-2">
                    <p class="card-title fs-5 fw-semibold lh-base mb-0"><i class="material-icons align-middle">navigate_before</i> 练习21：高级数据类型和控制结构</p>
					<p class="card-text ms-2"></p>
					
				</div>
			</div>
		</a>
        </div>
	<div class="col-sm-6 pt-2 doc-prev">
		<a class="ms-auto" href="/TechDocs/docs/c-guide/ex23/">
			<div class="card h-100 my-1 text-end">
				<div class="card-body py-2">
                    <p class="card-title fs-5 fw-semibold lh-base mb-0">练习23：认识达夫设备 <i class="material-icons align-middle">navigate_next</i></p>
					<p class="card-text me-2"></p>
					
				</div>
			</div>
		</a>
        </div>
	</div>
</div></div>
                                    </div>
                                </div>
                            </div>
                        </div>
<footer class="shadow py-3 d-print-none">
    <div class="container-fluid">
        <div class="row align-items-center">
            <div class="col">
                <div class="text-sm-start text-center mx-md-2">
                    <p class="mb-0">
                        
                        © 2023 cuterwrite. Built with <a href="https://github.com/colinwilson/lotusdocs"><strong>Lotus Docs</strong></a>
                    </p>
                </div>
            </div>
        </div>
    </div>
</footer>
</main>
        </div>
    </div>

    
    
    <button onclick="topFunction()" id="back-to-top" aria-label="Back to Top Button" class="back-to-top fs-5"><svg width="24" height="24"><path d="M12,10.224l-6.3,6.3L4.32,15.152,12,7.472l7.68,7.68L18.3,16.528Z" style="fill:#fff"/></svg></button>
    
    

    
    
        <script>(()=>{var e=document.getElementById("mode");e!==null&&(window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change",e=>{e.matches?(localStorage.setItem("theme","dark"),document.documentElement.setAttribute("data-dark-mode","")):(localStorage.setItem("theme","light"),document.documentElement.removeAttribute("data-dark-mode"))}),e.addEventListener("click",()=>{document.documentElement.toggleAttribute("data-dark-mode"),localStorage.setItem("theme",document.documentElement.hasAttribute("data-dark-mode")?"dark":"light")}),localStorage.getItem("theme")==="dark"?document.documentElement.setAttribute("data-dark-mode",""):document.documentElement.removeAttribute("data-dark-mode"))})()</script>
    




    
        
        
    
    
    






    

    <script src="/TechDocs/docs/js/bootstrap.39e36097440e8ae1bae5fa5b30b62819b701b2b6a0b19a492a1bf309e2a1dcfc02734909ea7951d33c11038d5ac48cd4.js" integrity="sha384-OeNgl0QOiuG65fpbMLYoGbcBsragsZpJKhvzCeKh3PwCc0kJ6nlR0zwRA41axIzU"defer></script>


    <script type="text/javascript" src="https://cuterwrite.top/TechDocs/docs/js/bundle.min.fadb30d71fd1560a0277e58cce2f06da367f12ed4e6d22545b39e167b61d3abd0f930918104e515259a27804cabbfd71.js" integrity="sha384-&#43;tsw1x/RVgoCd&#43;WMzi8G2jZ/Eu1ObSJUWznhZ7YdOr0PkwkYEE5RUlmieATKu/1x" crossorigin="anonymous" defer></script>
    

    
    <script type="module">
    var suggestions = document.getElementById('suggestions');
    var search = document.getElementById('flexsearch');

    const flexsearchContainer = document.getElementById('FlexSearchCollapse');

    const hideFlexsearchBtn = document.getElementById('hideFlexsearch');

    const configObject = { toggle: false }
    const flexsearchContainerCollapse = new Collapse(flexsearchContainer, configObject) 

    if (search !== null) {
        document.addEventListener('keydown', inputFocus);
        flexsearchContainer.addEventListener('shown.bs.collapse', function () {
            search.focus();
        });
        
        var topHeader = document.getElementById("top-header");
        document.addEventListener('click', function(elem) {
            if (!flexsearchContainer.contains(elem.target) && !topHeader.contains(elem.target))
                flexsearchContainerCollapse.hide();
        });
    }

    hideFlexsearchBtn.addEventListener('click', () =>{
        flexsearchContainerCollapse.hide()
    })

    function inputFocus(e) {
        if (e.ctrlKey && e.key === '/') {
            e.preventDefault();
            flexsearchContainerCollapse.toggle();
        }
        if (e.key === 'Escape' ) {
            search.blur();
            
            flexsearchContainerCollapse.hide();
        }
    };

    document.addEventListener('click', function(event) {

    var isClickInsideElement = suggestions.contains(event.target);

    if (!isClickInsideElement) {
        suggestions.classList.add('d-none');
    }

    });

    


    document.addEventListener('keydown',suggestionFocus);

    function suggestionFocus(e) {
    const suggestionsHidden = suggestions.classList.contains('d-none');
    if (suggestionsHidden) return;

    const focusableSuggestions= [...suggestions.querySelectorAll('a')];
    if (focusableSuggestions.length === 0) return;

    const index = focusableSuggestions.indexOf(document.activeElement);

    if (e.key === "ArrowUp") {
        e.preventDefault();
        const nextIndex = index > 0 ? index - 1 : 0;
        focusableSuggestions[nextIndex].focus();
    }
    else if (e.key === "ArrowDown") {
        e.preventDefault();
        const nextIndex= index + 1 < focusableSuggestions.length ? index + 1 : index;
        focusableSuggestions[nextIndex].focus();
    }

    }

    


    (function(){

    var index = new FlexSearch.Document({
        
        tokenize: "full",
        minlength:  1 ,
        cache:  100 ,
        optimize:  true ,
        document: {
        id: 'id',
        store: [
            "href", "title", "description"
        ],
        index: ["title", "description", "content"]
        }
    });


    


    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    


    

    

    index.add(
            {
                id:  0 ,
                href: "\/TechDocs\/docs\/",
                title: "CS技术文档",
                description: "",
                content: ""
            }
        );
    index.add(
            {
                id:  1 ,
                href: "\/TechDocs\/docs\/overview\/",
                title: "前言",
                description: "这是一个计算机的技术资料库。",
                content: "这是一个计算机的技术资料库。\n"
            }
        );
    index.add(
            {
                id:  2 ,
                href: "\/TechDocs\/docs\/practical-programing-book\/",
                title: "计算机相关技术资料整理 ",
                description: "这里收录比较实用的计算机相关技术书籍，可以在短期之内入门的简单实用教程、一些技术网站以及一些写的比较好的博文，欢迎Fork，你也可以通过Pull Request参与编辑。\n程序员必读书籍 目录 link 语言相关类\nAndroid AWK SED C/C++ CSS/HTML Dart Erlang Fortran Go Groovy Haskell iOS Java JavaScript LaTeX LISP Lua Perl PHP Prolog Python R Ruby Scala Scheme Shell Swift WebAssembly 语言无关类\n操作系统 版本控制 分布式系统 编辑器 NoSQL MySQL PostgreSQL 项目相关 设计模式 Web 大数据 编程艺术 函数式编程 运维监控 WEB服务器 语言无关类 link操作系统 link 开源世界旅行手册 鸟哥的Linux私房菜 Linux 系统高级编程 Zephyr OS 中文文档(v1.6.0) The Linux Command Line (中英文版) Linux 设备驱动 (第三版) 深入分析Linux内核源码 UNIX TOOLBOX Docker中文指南 Docker —— 从入门到实践 Docker入门实战 Docker Cheat Sheet FreeRADIUS新手入门 Mac 开发配置手册 FreeBSD 使用手册 Linux 命令行(中文版) Linux 构建指南 Linux工具快速教程 Linux Documentation (中文版) 嵌入式 Linux 知识库 (eLinux.",
                content: " 这里收录比较实用的计算机相关技术书籍，可以在短期之内入门的简单实用教程、一些技术网站以及一些写的比较好的博文，欢迎Fork，你也可以通过Pull Request参与编辑。\n程序员必读书籍 目录 link 语言相关类\nAndroid AWK SED C/C++ CSS/HTML Dart Erlang Fortran Go Groovy Haskell iOS Java JavaScript LaTeX LISP Lua Perl PHP Prolog Python R Ruby Scala Scheme Shell Swift WebAssembly 语言无关类\n操作系统 版本控制 分布式系统 编辑器 NoSQL MySQL PostgreSQL 项目相关 设计模式 Web 大数据 编程艺术 函数式编程 运维监控 WEB服务器 语言无关类 link操作系统 link 开源世界旅行手册 鸟哥的Linux私房菜 Linux 系统高级编程 Zephyr OS 中文文档(v1.6.0) The Linux Command Line (中英文版) Linux 设备驱动 (第三版) 深入分析Linux内核源码 UNIX TOOLBOX Docker中文指南 Docker —— 从入门到实践 Docker入门实战 Docker Cheat Sheet FreeRADIUS新手入门 Mac 开发配置手册 FreeBSD 使用手册 Linux 命令行(中文版) Linux 构建指南 Linux工具快速教程 Linux Documentation (中文版) 嵌入式 Linux 知识库 (eLinux.org 中文版) 理解Linux进程 Linux From Scratch systemd 中文翻译 55分钟学会正则表达式 每个Linux用户都应该知道的命令行技巧 每个程序员都应该了解的内存知识 每个程序员都应该了解的CPU缓存知识 每个程序员都应该了解的虚拟内存知识 shell脚本教程 查找命令行的网站 正则表达式在线测试 科学上网 分布式系统 link 走向分布式 函数式编程 link 傻瓜函数编程 web服务器 link Nginx开发从入门到精通 (淘宝团队出品) Nginx教程从入门到精通(PDF版本，运维生存时间出品) OpenResty最佳实践 Apache 中文手册 Elasticsearch权威指南 25 台服务器是怎样支撑 StackOverflow 的？ 图片服务架构演进（孔凡勇） 最佳日志实践（王健） 版本控制 link Git教程 git简易指南 猴子都能懂的GIT入门 Git 参考手册 Pro Git Pro Git 中文版 (整理在gitbook上) Git Magic GotGitHub Git权威指南 Git Community Book 中文版 Mercurial 使用教程 HgInit (中文版) 沉浸式学 Git Git-Cheat-Sheet （感谢 @flyhigher139 翻译了中文版） GitHub秘籍 Github帮助文档 git-flow 备忘清单 svn 手册 GitHub漫游指南 编辑器 link exvim–vim 改良成IDE项目 笨方法学Vimscript 中译本 Vim中文文档 所需即所获：像 IDE 一样使用 vim 在线MarkDown编辑 简明VIM练级攻略 MySQL link MySQL中文手册 十步完全理解SQL MySQL索引背后的数据结构及算法原理 21分钟MySQL入门教程 NoSQL link NoSQL数据库笔谈 Redis 设计与实现 Redis 命令参考 带有详细注释的 Redis 3.0 代码 带有详细注释的 Redis 2.6 代码 The Little MongoDB Book The Little Redis Book Neo4j 简体中文手册 v1.8 Neo4j .rb 中文資源 Disque 使用教程 Apache Spark 设计与实现 8种Nosql数据库系统对比 PostgreSQL link PostgreSQL 8.2.3 中文文档 PostgreSQL 9.3.1 中文文档 PostgreSQL 9.5.3 中文文档 运维监控 link ELKstack 中文指南 Mastering Elasticsearch(中文版) ElasticSearch 权威指南 Elasticsearch 权威指南（中文版） Logstash 最佳实践 Puppet 2.7 Cookbook 中文版 项目相关 link Gradle实战 持续集成（第二版） (译言网) 让开发自动化系列专栏 追求代码质量 selenium 中文文档 Joel谈软件 約耳談軟體(Joel on Software) Gradle 2 用户指南 编码规范 开源软件架构 GNU make 指南 GNU make 中文手册 The Twelve-Factor App 设计模式 link 图说设计模式 史上最全设计模式导学目录 design pattern 包教不包会 设计模式 Java 版 Web link 网络传输基础 关于浏览器和网络的 20 项须知 前端知识体系 浏览器开发工具的秘密 Chrome 开发者工具中文手册 Chrome扩展开发文档 Grunt中文文档 Yeoman中文文档 移动Web前端知识库 正则表达式30分钟入门教程 前端开发体系建设日记 移动前端开发收藏夹 JSON风格指南 HTTP 接口设计指北 前端资源分享（一） 前端资源分享（二） 前端代码规范 及 最佳实践 前端开发者手册 前端工程师手册 w3school教程整理 Wireshark用户手册 一站式学习Wireshark HTTP 下午茶 HTTP/2.0 中文翻译 RFC 7540 - HTTP/2 中文翻译版 http2讲解 3 Web Designs in 3 Weeks 站点可靠性工程 大数据 link 大数据/数据挖掘/推荐系统/机器学习相关资源 面向程序员的数据挖掘指南 大型集群上的快速和通用数据处理架构 数据挖掘中经典的算法实现和详细的注释 Spark 编程指南简体中文版 编程艺术 link 程序员编程艺术 每个程序员都应该了解的内存知识(译)【第一部分】 取悦的工序：如何理解游戏 (豆瓣阅读，免费书籍) 编程技巧总汇 语言相关类 linkAWK link awk程序设计语言 awk教程 SED link sed教程 SED简明教程 Java link Apache Shiro 用户指南 Jersey 2.x 用户指南 Spring Framework 4.x参考文档 Spring Boot参考指南 (翻译中) MyBatis中文文档 用jersey构建REST服务 Activiti 5.x 用户指南 Google Java编程风格指南 Netty 4.x 用户指南 Netty 实战(精髓) REST 实战 Java 编码规范 Apache MINA 2 用户指南 JVM必备指南 Java入门教程 javarevisited博客 journaldev教程 Android link 开发工具下载 CodePath Android教程 Android Design(中文版) Google Material Design 正體中文版 (译本一 译本二) Google Android官方培训课程中文版 Android学习之路 Android构建工具 Android开发技术前线(android-tech-frontier) Android内存优化(上) Android内存优化(中) Android内存优化(全) 查找代码的一个网站 Android开源库汇总 查找示例代码的网站 Android SDK使用教程 Android最佳实践 Android Material icons C/C++ link C/C++ 中文参考手册 (欢迎大家参与在线翻译和校对) C 语言编程透视 C++ 并发编程指南 Linux C编程一站式学习 (宋劲杉, 北京亚嵌教育研究中心) CGDB中文手册 100个gdb小技巧 100个gcc小技巧 学习gdb调试技巧 ZMQ 指南 How to Think Like a Computer Scientist (中英文版) 跟我一起写Makefile(PDF) GNU make中文手册 GNU make 指南 Google C++ 风格指南 C/C++ Primer (by @andycai) 简单易懂的C魔法 Cmake 实践 (PDF版) C++ FAQ LITE(中文版) C++ Primer 5th Answers C++ 并发编程(基于C++11) QT 教程 C进阶指南（1) libuv中文教程 Boost 库中文教程 笨办法学C C进阶指南（2) C进阶指南（3) C语言全局变量那些事儿 如何实现一个malloc 在线编程和调试的网站 CSS link 学习CSS布局 通用 CSS 笔记、建议与指导 CSS参考手册 Emmet 文档 前端代码规范 (腾讯alloyteam团队) HTML和CSS编码规范 Sass Guidelines 中文 CSS3 Tutorial 《CSS3 教程》 MDN HTML 中文文档 MDN CSS 中文文档 Go link Go编程基础 Go入门指南 学习Go语言 (PDF) Go Web 编程 (此书已经出版，希望开发者们去购买，支持作者的创作) Go实战开发 (当我收录此项目时，作者已经写完第三章，如果读完前面章节觉得有帮助，可以给作者捐赠，以鼓励作者的继续创作) Network programming with Go 中文翻译版本 Effective Go Go 语言标准库 Golang标准库文档 Revel 框架手册 Java程序员的Golang入门指南 Go命令教程 Go语言博客实践 Go 官方文档翻译 深入解析Go Go语言圣经(中文版) (GitBook) Go语言高级编程 Groovy link 实战 Groovy 系列 Haskell link Real World Haskell 中文版 Haskell趣学指南 Learn You a Haskell for Great Good!(质量不错的一个网书) iOS link iOS开发60分钟入门 iOS7人机界面指南 Google Objective-C Style Guide 中文版 iPhone 6 屏幕揭秘 Apple Watch开发初探 马上着手开发 iOS 应用程序 网易斯坦福大学公开课：iOS 7应用开发字幕文件 JavaScript link Google JavaScript 代码风格指南\nGoogle JSON 风格指南\nAirbnb JavaScript 规范\nJavaScript 标准参考教程（alpha）\nJavascript编程指南 (源码)\njavascript 的 12 个怪癖\nJavaScript 秘密花园\nJavaScript核心概念及实践 (PDF) (此书已由人民邮电出版社出版发行，但作者依然免费提供PDF版本，希望开发者们去购买，支持作者)\n《JavaScript 模式》 “JavaScript patterns”中译本\n命名函数表达式探秘 (注:原文由为之漫笔翻译，原始地址无法打开，所以此处地址为我博客上的备份)\n学用 JavaScript 设计模式 (开源中国)\n深入理解JavaScript系列\nECMAScript 6 入门 (作者：阮一峰)\nJavaScript Promise迷你书\nYou-Dont-Know-JS (深入JavaScript语言核心机制的系列图书)\nJavaScript 教程 廖雪峰\nMDN JavaScript 中文文档\njQuery\njQuery 解构 简单易懂的JQuery魔法 How to write jQuery plugin Node.js\nNode入门 七天学会NodeJS Nodejs Wiki Book (繁体中文) express.js 中文文档 koa 中文文档 一起学koa 使用 Express + MongoDB 搭建多人博客 Express框架 Node.js 包教不包会 Learn You The Node.js For Much Win! (中文版) Node debug 三法三例 nodejs中文文档 orm2 中文文档 underscore.js\nUnderscore.js中文文档 backbone.js\nbackbone.js中文文档 backbone.js入门教程 (PDF) Backbone.js入门教程第二版 Developing Backbone.js Applications(中文版) AngularJS\nAngularJS最佳实践和风格指南 AngularJS中译本 AngularJS入门教程 构建自己的AngularJS 在Windows环境下用Yeoman构建AngularJS项目 Zepto.js\nZepto.js 中文文档 Sea.js\nHello Sea.js React.js\nReact.js 中文文档 React webpack-cookbook React 入门教程 React Native 中文文档(含最新Android内容) Learn React \u0026 Webpack by building the Hacker News front page impress.js\nimpress.js的中文教程 CoffeeScript\nCoffeeScript Cookbook The Little Book on CoffeeScript中文版 CoffeeScript 编码风格指南 TypeScipt\nTypeScript Handbook ExtJS\nExt4.1.0 中文文档 Meteor\nDiscover Meteor Meteor 中文文档 Angular-Meteor 中文教程 Chrome扩展及应用开发\nLaTeX link 一份其实很短的 LaTeX 入门文档 一份不太简短的 LATEX 2ε 介绍 （PDF版） LISP link Common Lisp ANSI Common Lisp 中文翻譯版 On Lisp 中文翻译版本 Scheme Yet Another Scheme Tutorial Scheme入门教程 Scheme语言简明教程 Racket Racket book Lua link Lua编程入门 Lua 5.1 参考手册 中文翻译 Lua 5.3 参考手册 中文翻译 Lua源码欣赏 Perl link Modern Perl 中文版 Perl 程序员应该知道的事 PHP link PHP 官方手册 PHP调试技术手册(PDF) XDebug 2中文手册(译) (CHM) PHP之道 PHP 最佳实践 PHP 开发者实践 深入理解PHP内核 PHP扩展开发及内核应用 CodeIgniter 用户指南 Laravel4 中文文档 Laravel 入门 Symfony2中文文档 (未译完) Phalcon中文文档（翻译进行中） YiiBook几本Yii框架的在线教程 深入理解 Yii 2.0 Yii 框架中文文檔 简单易懂的PHP魔法 swoole文档及入门教程 Composer 中文网 Slim 中文文档 Lumen 中文文档 PHPUnit 中文文档 Prolog link 笨办法学Prolog Python link 廖雪峰 Python 2.7 中文教程 廖雪峰 Python 3 中文教程 简明Python教程 零基础学 Python 第一版 零基础学 Python 第二版 可爱的 Python Python 2.7 官方教程中文版 Python 3.3 官方教程中文版 Python Cookbook 中文版 Python3 Cookbook 中文版 深入 Python 深入 Python 3 PEP8 Python代码风格规范 Google Python 风格指南 中文版 Python入门教程 (PDF) Python的神奇方法指南 笨办法学 Python （PDF版下载） The Django Book 中文版 web.py 0.3 新手指南 Web.py Cookbook 简体中文版 Dive Into Python 中文版 Bottle 文档中文版 (需翻墙) Flask 文档中文版 Jinja2 文档中文版 Werkzeug 文档中文版 Flask之旅 Introduction to Tornado 中文翻译 Python自然语言处理中文版 （感谢陈涛同学的翻译，也谢谢 @shwley 联系了作者） Python 绘图库 matplotlib 官方指南中文翻译 Scrapy 0.25 文档 ThinkPython Python快速教程 Python 正则表达式操作指南 python初级教程：入门详解 Python Cookbook 第3版 中文版 Twisted 与异步编程入门 TextGrocery 中文 API ( 基于svm算法的一个短文本分类 Python 库 ) Requests: HTTP for Humans Pillow 中文文档 PyMOTW 中文版 Python 官方文档中文版 Fabric 中文文档 Beautiful Soup 4.2.0 中文文档 用Python做科学计算 Sphinx 中文文档 精通 Python 设计模式 python 安全编程教程 程序设计思想与方法 知乎周刊·编程小白学Python Scipy 讲义 Python 学习笔记 基础篇 Python 学习笔记 模块篇 Python 标准库 中文版 Python进阶 Python 核心编程 第二版 CPyUG译 Python最佳实践指南 Python 精要教程 Python 量化交易教程 Django Django 1.5 文档中文版 正在翻译中 Diango 1.7 文档中文版 正在翻译中，目前只翻译了目录 Django 1.8.2 文档中文版 正在翻译中 Django 最佳实践 Django搭建简易博客教程 The Django Book 中文版 Django 设计模式与最佳实践 Django 网站开发 Cookbook Django Girls 學習指南 Flask Flask 文档中文版 Jinja2 文档中文版 Werkzeug 文档中文版 Flask之旅 Flask 扩展文档汇总 Flask 大型教程 SQLAlchemy 中文文档 web.py web.py 0.3 新手指南 Web.py Cookbook 简体中文版 Tornado Introduction to Tornado 中文翻译 Tornado源码解析 Tornado 4.3 文档中文版 R link R语言忍者秘笈 Ruby link Ruby 风格指南 Rails 风格指南 笨方法學 Ruby Ruby on Rails 指南 Ruby on Rails 實戰聖經 Ruby on Rails Tutorial 原书第 3 版 (本书网页版免费提供，电子版以 PDF、EPub 和 Mobi 格式提供购买，仅售 9.9 美元) Rails 实践 Rails 5 开发进阶(Beta) Rails 102 编写Ruby的C拓展 Ruby 源码解读 Ruby中的元编程 Scala link Scala课堂 (Twitter的Scala中文教程) Effective Scala(Twitter的Scala最佳实践的中文翻译) Scala指南 Scala-for-the-impatient-2nd(自行购买或pdf) Scala|写点什么(国人的一个很好的关于Scala的博客) Scheme link Yet Another Scheme Tutorial Scheme入门教程 Scheme语言简明教程 Shell link Shell脚本编程30分钟入门 Bash脚本15分钟进阶教程 Linux工具快速教程 shell十三问 Swift link The Swift Programming Language 中文版 Swift 语言指南 Stanford 公开课，Developing iOS 8 Apps with Swift 字幕翻译文件 WebAssembly link C/C++面向WebAssembly编程 "
            }
        );
    index.add(
            {
                id:  3 ,
                href: "\/TechDocs\/docs\/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF\/",
                title: "数据库技术",
                description: "",
                content: ""
            }
        );
    index.add(
            {
                id:  4 ,
                href: "\/TechDocs\/docs\/%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF\/readme\/",
                title: "Redis 指南",
                description: "\\\n关于此书 link许可证 link《The Little Redis Book》是经由Attribution-NonCommercial 3.0 Unported license许可的，你不需要为此书付钱。\n你可以自由地对此书进行复制，分发，修改或者展示等操作。当然，你必须知道且认可这本书的作者是Karl Seguin，译者是赖立维，而且不应该将此书用于商业用途。\n关于这个许可证的详细描述在这里：\nhttp://creativecommons.org/licenses/by-nc/3.0/legalcode\n关于作者 link作者Karl Seguin是一名在多项技术领域浸淫多年的开发者。他是开源软件计划的活跃贡献者，同时也是一名技术作者以及业余演讲者。他写过若干关于Radis的文章以及一些工具。在他的一个面向业余游戏开发者的免费服务里，Redis为其中的评级和统计功能提供了支持：mogade.com。\nKarl之前还写了《The Little MongoDB Book》，这是一本免费且受好评，关于MongoDB的书。\n他的博客是http://openmymind.net，你也可以关注他的Twitter帐号，via @karlseguin。\n关于译者 link译者 赖立维 是一名长在天朝的普通程序员，对许多技术都有浓厚的兴趣，是开源软件的支持者，Emacs的轻度使用者。\n虽然译者已经很认真地对待这次翻译，但是限于水平有限，肯定会有不少错漏，如果发现该书的翻译有什么需要修改，可以通过他的邮箱与他联系。他的邮箱是jasonlai256@gmail.com。\n致谢 link必须特别感谢Perry Neal一直以来的指导，我的眼界、触觉以及激情都来源于你。你为我提供了无价的帮助，感谢你。\n最新版本 link此书的最新有效资源在： http://github.com/karlseguin/the-little-redis-book\n中文版是英文版的一个分支，最新的中文版本在： https://github.com/JasonLai256/the-little-redis-book\n\\clearpage\n简介 link最近几年来，关于持久化和数据查询的相关技术，其需求已经增长到了让人惊讶的程度。可以断言，关系型数据库再也不是放之四海皆准。换一句话说，围绕数据的解决方案不可能再只有唯一一种。\n对于我来说，在众多新出现的解决方案和工具里，最让人兴奋的，无疑是Redis。为什么？首先是因为其让人不可思议的容易学习，只需要简短的几个小时学习时间，就能对Redis有个大概的认识。还有，Redis在处理一组特定的问题集的同时能保持相当的通用性。更准确地说就是，Redis不会尝试去解决关于数据的所有事情。在你足够了解Redis后，事情就会变得越来越清晰，什么是可行的，什么是不应该由Redis来处理的。作为一名开发人员，如此的经验当是相当的美妙。\n当你能仅使用Redis去构建一个完整系统时，我想大多数人将会发现，Redis能使得他们的许多数据方案变得更为通用，不论是一个传统的关系型数据库，一个面向文档的系统，或是其它更多的东西。这是一种用来实现某些特定特性的解决方法。就类似于一个索引引擎，你不会在Lucene上构建整个程序，但当你需要足够好的搜索，为什么不使用它呢？这对你和你的用户都有好处。当然，关于Redis和索引引擎之间相似性的讨论到此为止。\n本书的目的是向读者传授掌握Redis所需要的基本知识。我们将会注重于学习Redis的5种数据结构，并研究各种数据建模方法。我们还会接触到一些主要的管理细节和调试技巧。\n入门 link每个人的学习方式都不一样，有的人喜欢亲自实践学习，有的喜欢观看教学视频，还有的喜欢通过阅读来学习。对于Redis，没有什么比亲自实践学习来得效果更好的了。Redis的安装非常简单。而且通过随之安装的一个简单的命令解析程序，就能处理我们想做的一切事情。让我们先花几分钟的时间把Redis安装到我们的机器上。\nWindows平台 linkRedis并没有官方支持Windows平台，但还是可供选择。你不会想在这里配置实际的生产环境，不过在我过往的开发经历里并没有感到有什么限制。\n首先进入https://github.com/dmajkic/redis/downloads，然后下载最新的版本（应该会在列表的最上方）。\n获取zip文件，然后根据你的系统架构，打开64bit或32bit文件夹。\n*nix和MacOSX平台 link对于*nix和MacOSX平台的用户，从源文件来安装是你的最佳选择。通过最新的版本号来选择，有效地址于http://redis.io/download。在编写此书的时候，最新的版本是2.4.6，我们可以运行下面的命令来安装该版本：\nwget http://redis.googlecode.com/files/redis-2.4.6.tar.gz tar xzf redis-2.4.6.tar.gz cd redis-2.4.6 make （当然，Redis同样可以通过套件管理程序来安装。例如，使用Homebrew的MaxOSX用户可以只键入brew install redis即可。）\n如果你是通过源文件来安装，二进制可执行文件会被放置在src目录里。通过运行cd src可跳转到src目录。\n运行和连接Redis link如果一切都工作正常，那Redis的二进制文件应该已经可以曼妙地跳跃于你的指尖之下。Redis只有少量的可执行文件，我们将着重于Redis的服务器和命令行界面（一个类DOS的客户端）。首先，让我们来运行服务器。在Windows平台，双击redis-server，在*nix/MacOSX平台则运行./redis-server.\n如果你仔细看了启动信息，你会看到一个警告，指没能找到redis.conf文件。Redis将会采用内置的默认设置，这对于我们将要做的已经足够了。\n然后，通过双击redis-cli（Windows平台）或者运行./redis-cli（*nix/MacOSX平台），启动Redis的控制台。控制台将会通过默认的端口（6379）来连接本地运行的服务器。\n可以在命令行界面键入info命令来查看一切是不是都运行正常。你会很乐意看到这么一大组关键字-值（key-value）对的显示，这为我们查看服务器的状态提供了大量有效信息。\n如果在上面的启动步骤里遇到什么问题，我建议你到Redis的官方支持组里获取帮助。",
                content: " \\\n关于此书 link许可证 link《The Little Redis Book》是经由Attribution-NonCommercial 3.0 Unported license许可的，你不需要为此书付钱。\n你可以自由地对此书进行复制，分发，修改或者展示等操作。当然，你必须知道且认可这本书的作者是Karl Seguin，译者是赖立维，而且不应该将此书用于商业用途。\n关于这个许可证的详细描述在这里：\nhttp://creativecommons.org/licenses/by-nc/3.0/legalcode\n关于作者 link作者Karl Seguin是一名在多项技术领域浸淫多年的开发者。他是开源软件计划的活跃贡献者，同时也是一名技术作者以及业余演讲者。他写过若干关于Radis的文章以及一些工具。在他的一个面向业余游戏开发者的免费服务里，Redis为其中的评级和统计功能提供了支持：mogade.com。\nKarl之前还写了《The Little MongoDB Book》，这是一本免费且受好评，关于MongoDB的书。\n他的博客是http://openmymind.net，你也可以关注他的Twitter帐号，via @karlseguin。\n关于译者 link译者 赖立维 是一名长在天朝的普通程序员，对许多技术都有浓厚的兴趣，是开源软件的支持者，Emacs的轻度使用者。\n虽然译者已经很认真地对待这次翻译，但是限于水平有限，肯定会有不少错漏，如果发现该书的翻译有什么需要修改，可以通过他的邮箱与他联系。他的邮箱是jasonlai256@gmail.com。\n致谢 link必须特别感谢Perry Neal一直以来的指导，我的眼界、触觉以及激情都来源于你。你为我提供了无价的帮助，感谢你。\n最新版本 link此书的最新有效资源在： http://github.com/karlseguin/the-little-redis-book\n中文版是英文版的一个分支，最新的中文版本在： https://github.com/JasonLai256/the-little-redis-book\n\\clearpage\n简介 link最近几年来，关于持久化和数据查询的相关技术，其需求已经增长到了让人惊讶的程度。可以断言，关系型数据库再也不是放之四海皆准。换一句话说，围绕数据的解决方案不可能再只有唯一一种。\n对于我来说，在众多新出现的解决方案和工具里，最让人兴奋的，无疑是Redis。为什么？首先是因为其让人不可思议的容易学习，只需要简短的几个小时学习时间，就能对Redis有个大概的认识。还有，Redis在处理一组特定的问题集的同时能保持相当的通用性。更准确地说就是，Redis不会尝试去解决关于数据的所有事情。在你足够了解Redis后，事情就会变得越来越清晰，什么是可行的，什么是不应该由Redis来处理的。作为一名开发人员，如此的经验当是相当的美妙。\n当你能仅使用Redis去构建一个完整系统时，我想大多数人将会发现，Redis能使得他们的许多数据方案变得更为通用，不论是一个传统的关系型数据库，一个面向文档的系统，或是其它更多的东西。这是一种用来实现某些特定特性的解决方法。就类似于一个索引引擎，你不会在Lucene上构建整个程序，但当你需要足够好的搜索，为什么不使用它呢？这对你和你的用户都有好处。当然，关于Redis和索引引擎之间相似性的讨论到此为止。\n本书的目的是向读者传授掌握Redis所需要的基本知识。我们将会注重于学习Redis的5种数据结构，并研究各种数据建模方法。我们还会接触到一些主要的管理细节和调试技巧。\n入门 link每个人的学习方式都不一样，有的人喜欢亲自实践学习，有的喜欢观看教学视频，还有的喜欢通过阅读来学习。对于Redis，没有什么比亲自实践学习来得效果更好的了。Redis的安装非常简单。而且通过随之安装的一个简单的命令解析程序，就能处理我们想做的一切事情。让我们先花几分钟的时间把Redis安装到我们的机器上。\nWindows平台 linkRedis并没有官方支持Windows平台，但还是可供选择。你不会想在这里配置实际的生产环境，不过在我过往的开发经历里并没有感到有什么限制。\n首先进入https://github.com/dmajkic/redis/downloads，然后下载最新的版本（应该会在列表的最上方）。\n获取zip文件，然后根据你的系统架构，打开64bit或32bit文件夹。\n*nix和MacOSX平台 link对于*nix和MacOSX平台的用户，从源文件来安装是你的最佳选择。通过最新的版本号来选择，有效地址于http://redis.io/download。在编写此书的时候，最新的版本是2.4.6，我们可以运行下面的命令来安装该版本：\nwget http://redis.googlecode.com/files/redis-2.4.6.tar.gz tar xzf redis-2.4.6.tar.gz cd redis-2.4.6 make （当然，Redis同样可以通过套件管理程序来安装。例如，使用Homebrew的MaxOSX用户可以只键入brew install redis即可。）\n如果你是通过源文件来安装，二进制可执行文件会被放置在src目录里。通过运行cd src可跳转到src目录。\n运行和连接Redis link如果一切都工作正常，那Redis的二进制文件应该已经可以曼妙地跳跃于你的指尖之下。Redis只有少量的可执行文件，我们将着重于Redis的服务器和命令行界面（一个类DOS的客户端）。首先，让我们来运行服务器。在Windows平台，双击redis-server，在*nix/MacOSX平台则运行./redis-server.\n如果你仔细看了启动信息，你会看到一个警告，指没能找到redis.conf文件。Redis将会采用内置的默认设置，这对于我们将要做的已经足够了。\n然后，通过双击redis-cli（Windows平台）或者运行./redis-cli（*nix/MacOSX平台），启动Redis的控制台。控制台将会通过默认的端口（6379）来连接本地运行的服务器。\n可以在命令行界面键入info命令来查看一切是不是都运行正常。你会很乐意看到这么一大组关键字-值（key-value）对的显示，这为我们查看服务器的状态提供了大量有效信息。\n如果在上面的启动步骤里遇到什么问题，我建议你到Redis的官方支持组里获取帮助。\n驱动Redis link很快你就会发现，Redis的API就如一组定义明确的函数那般容易理解。Redis具有让人难以置信的简单性，其操作过程也同样如此。这意味着，无论你是使用命令行程序，或是使用你喜欢的语言来驱动，整体的感觉都不会相差多少。因此，相对于命令行程序，如果你更愿意通过一种编程语言去驱动Redis，你不会感觉到有任何适应的问题。如果真想如此，可以到Redis的客户端推荐页面下载适合的Redis载体。\n\\clearpage\n第1章 - 基础知识 link是什么使Redis显得这么特别？Redis具体能解决什么类型的问题？要实际应用Redis，开发者必须储备什么知识？在我们能回答这么一些问题之前，我们需要明白Redis到底是什么。\nRedis通常被人们认为是一种持久化的存储器关键字-值型存储（in-memory persistent key-value store）。我认为这种对Redis的描述并不太准确。Redis的确是将所有的数据存放于存储器（更多是是按位存储），而且也确实通过将数据写入磁盘来实现持久化，但是Redis的实际意义比单纯的关键字-值型存储要来得深远。纠正脑海里的这种误解观点非常关键，否则你对于Redis之道以及其应用的洞察力就会变得越发狭义。\n事实是，Redis引入了5种不同的数据结构，只有一个是典型的关键字-值型结构。理解Redis的关键就在于搞清楚这5种数据结构，其工作的原理都是如何，有什么关联方法以及你能怎样应用这些数据结构去构建模型。首先，让我们来弄明白这些数据结构的实际意义。\n应用上面提及的数据结构概念到我们熟悉的关系型数据库里，我们可以认为其引入了一个单独的数据结构——表格。表格既复杂又灵活，基于表格的存储和管理，没有多少东西是你不能进行建模的。然而，这种通用性并不是没有缺点。具体来说就是，事情并不是总能达到假设中的简单或者快速。相对于这种普遍适用（one-size-fits-all）的结构体系，我们可以使用更为专门化的结构体系。当然，因此可能有些事情我们会完成不了(至少，达不到很好的程度）。但话说回来，这样做就能确定我们可以获得想象中的简单性和速度吗？\n针对特定类型的问题使用特定的数据结构？我们不就是这样进行编程的吗？你不会使用一个散列表去存储每份数据，也不会使用一个标量变量去存储。对我来说，这正是Redis的做法。如果你需要处理标量、列表、散列或者集合，为什么不直接就用标量、列表、散列和集合去存储他们？为什么不是直接调用exists(key)去检测一个已存在的值，而是要调用其他比O(1)（常量时间查找，不会因为待处理元素的增长而变慢）慢的操作？\n数据库（Databases） link与你熟悉的关系型数据库一致，Redis有着相同的数据库基本概念，即一个数据库包含一组数据。典型的数据库应用案例是，将一个程序的所有数据组织起来，使之与另一个程序的数据保持独立。\n在Redis里，数据库简单的使用一个数字编号来进行辨认，默认数据库的数字编号是0。如果你想切换到一个不同的数据库，你可以使用select命令来实现。在命令行界面里键入select 1，Redis应该会回复一条OK的信息，然后命令行界面里的提示符会变成类似redis 127.0.0.1:6379[1]\u003e这样。如果你想切换回默认数据库，只要在命令行界面键入select 0即可。\n命令、关键字和值（Commands, Keys and Values） linkRedis不仅仅是一种简单的关键字-值型存储，从其核心概念来看，Redis的5种数据结构中的每一个都至少有一个关键字和一个值。在转入其它关于Redis的有用信息之前，我们必须理解关键字和值的概念。\n关键字（Keys）是用来标识数据块。我们将会很常跟关键字打交道，不过在现在，明白关键字就是类似于users:leto这样的表述就足够了。一般都能很好地理解到，这样关键字包含的信息是一个名为leto的用户。这个关键字里的冒号没有任何特殊含义，对于Redis而言，使用分隔符来组织关键字是很常见的方法。\n值（Values）是关联于关键字的实际值，可以是任何东西。有时候你会存储字符串，有时候是整数，还有时候你会存储序列化对象（使用JSON、XML或其他格式）。在大多数情况下，Redis会把值看做是一个字节序列，而不会关注它们实质上是什么。要注意，不同的Redis载体处理序列化会有所不同（一些会让你自己决定）。因此，在这本书里，我们将仅讨论字符串、整数和JSON。\n现在让我们活动一下手指吧。在命令行界面键入下面的命令：\nset users:leto \"{name: leto, planet: dune, likes: [spice]}\" 这就是Redis命令的基本构成。首先我们要有一个确定的命令，在上面的语句里就是set。然后就是相应的参数，set命令接受两个参数，包括要设置的关键字，以及相应要设置的值。很多的情况是，命令接受一个关键字（当这种情况出现，其经常是第一个参数）。你能想到如何去获取这个值吗？我想你会说（当然一时拿不准也没什么）：\nget users:leto 关键字和值的是Redis的基本概念，而get和set命令是对此最简单的使用。你可以创建更多的用户，去尝试不同类型的关键字以及不同的值，看看一些不同的组合。\n查询（Querying） link随着学习的持续深入，两件事情将变得清晰起来。对于Redis而言，关键字就是一切，而值是没有任何意义。更通俗来看就是，Redis不允许你通过值来进行查询。回到上面的例子，我们就不能查询生活在dune行星上的用户。\n对许多人来说，这会引起一些担忧。在我们生活的世界里，数据查询是如此的灵活和强大，而Redis的方式看起来是这么的原始和不高效。不要让这些扰乱你太久。要记住，Redis不是一种普遍使用（one-size-fits-all）的解决方案，确实存在这么一些事情是不应该由Redis来解决的（因为其查询的限制）。事实上，在考虑了这些情况后，你会找到新的方法去构建你的数据。\n很快，我们就能看到更多实际的用例。很重要的一点是，我们要明白关于Redis的这些基本事实。这能帮助我们弄清楚为什么值可以是任何东西，因为Redis从来不需要去读取或理解它们。而且，这也可以帮助我们理清思路，然后去思考如何在这个新世界里建立模型。\n存储器和持久化（Memory and Persistence） link我们之前提及过，Redis是一种持久化的存储器内存储（in-memory persistent store）。对于持久化，默认情况下，Redis会根据已变更的关键字数量来进行判断，然后在磁盘里创建数据库的快照（snapshot）。你可以对此进行设置，如果X个关键字已变更，那么每隔Y秒存储数据库一次。默认情况下，如果1000个或更多的关键字已变更，Redis会每隔60秒存储数据库；而如果9个或更少的关键字已变更，Redis会每隔15分钟存储数据库。\n除了创建磁盘快照外，Redis可以在附加模式下运行。任何时候，如果有一个关键字变更，一个单一附加（append-only）的文件会在磁盘里进行更新。在一些情况里，虽然硬件或软件可能发生错误，但用那60秒有效数据存储去换取更好性能是可以接受的。而在另一些情况里，这种损失就难以让人接受，Redis为你提供了选择。在第5章里，我们将会看到第三种选择，其将持久化任务减荷到一个从属数据库里。\n至于存储器，Redis会将所有数据都保留在存储器中。显而易见，运行Redis具有不低的成本：因为RAM仍然是最昂贵的服务器硬件部件。\n我很清楚有一些开发者对即使是一点点的数据空间都是那么的敏感。一本《威廉·莎士比亚全集》需要近5.5MB的存储空间。对于缩放的需求，其它的解决方案趋向于IO-bound或者CPU-bound。这些限制（RAM或者IO）将会需要你去理解更多机器实际依赖的数据类型，以及应该如何去进行存储和查询。除非你是存储大容量的多媒体文件到Redis中，否则存储器内存储应该不会是一个问题。如果这对于一个程序是个问题，你就很可能不会用IO-bound的解决方案。\nRedis有虚拟存储器的支持。然而，这个功能已经被认为是失败的了（通过Redis的开发者），而且它的使用已经被废弃了。\n（从另一个角度来看，一本5.5MB的《威廉·莎士比亚全集》可以通过压缩减小到近2MB。当然，Redis不会自动对值进行压缩，但是因为其将所有值都看作是字节，没有什么限制让你不能对数据进行压缩/解压，通过牺牲处理时间来换取存储空间。）\n整体来看（Putting It Together） link我们已经接触了好几个高层次的主题。在继续深入Redis之前，我想做的最后一件事情是将这些主题整合起来。这些主题包括，查询的限制，数据结构以及Redis在存储器内存储数据的方法。\n当你将这3个主题整合起来，你最终会得出一个绝妙的结论：速度。一些人可能会想，当然Redis会很快速，要知道所有的东西都在存储器里。但这仅仅是其中的一部分，让Redis闪耀的真正原因是其不同于其它解决方案的特殊数据结构。\n能有多快速？这依赖于很多东西，包括你正在使用着哪个命令，数据的类型等等。但Redis的性能测试是趋向于数万或数十万次操作每秒。你可以通过运行redis-benchmark（就在redis-server和redis-cli的同一个文件夹里）来进行测试。\n我曾经试过将一组使用传统模型的代码转向使用Redis。在传统模型里，运行一个我写的载入测试，需要超过5分钟的时间来完成。而在Redis里，只需要150毫秒就完成了。你不会总能得到这么好的收获，但希望这能让你对我们所谈的东西有更清晰的理解。\n理解Redis的这个特性很重要，因为这将影响到你如何去与Redis进行交互。拥有SQL背景的程序员通常会致力于让数据库的数据往返次数减至最小。这对于任何系统都是个好建议，包括Redis。然而，考虑到我们是在处理比较简单的数据结构，有时候我们还是需要与Redis服务器频繁交互，以达到我们的目的。刚开始的时候，可能会对这种数据访问模式感到不太自然。实际上，相对于我们通过Redis获得的高性能而言，这仅仅是微不足道的损失。\n小结 link虽然我们只接触和摆弄了Redis的冰山一角，但我们讨论的主题已然覆盖了很大范围内的东西。如果觉得有些事情还是不太清楚（例如查询），不用为此而担心，在下一章我们将会继续深入探讨，希望你的问题都能得到解答。\n这一章的要点包括：\n关键字（Keys）是用于标识一段数据的一个字符串\n值（Values）是一段任意的字节序列，Redis不会关注它们实质上是什么\nRedis展示了（也实现了）5种专门的数据结构\n上面的几点使得Redis快速而且容易使用，但要知道Redis并不适用于所有的应用场景\n\\clearpage\n第2章 - 数据结构 link现在开始将探究Redis的5种数据结构，我们会解释每种数据结构都是什么，包含了什么有效的方法（Method），以及你能用这些数据结构处理哪些类型的特性和数据。\n目前为止，我们所知道的Redis构成仅包括命令、关键字和值，还没有接触到关于数据结构的具体概念。当我们使用set命令时，Redis是怎么知道我们是在使用哪个数据结构？其解决方法是，每个命令都相对应于一种特定的数据结构。例如，当你使用set命令，你就是将值存储到一个字符串数据结构里。而当你使用hset命令，你就是将值存储到一个散列数据结构里。考虑到Redis的关键字集很小，这样的机制具有相当的可管理性。\nRedis的网站里有着非常优秀的参考文档，没有任何理由去重造轮子。但为了搞清楚这些数据结构的作用，我们将会覆盖那些必须知道的重要命令。\n没有什么事情比高兴的玩和试验有趣的东西来得更重要的了。在任何时候，你都能通过键入flushdb命令将你数据库里的所有值清除掉，因此，不要再那么害羞了，去尝试做些疯狂的事情吧！\n字符串（Strings) link在Redis里，字符串是最基本的数据结构。当你在思索着关键字-值对时，你就是在思索着字符串数据结构。不要被名字给搞混了，如之前说过的，你的值可以是任何东西。我更喜欢将他们称作“标量”（Scalars），但也许只有我才这样想。\n我们已经看到了一个常见的字符串使用案例，即通过关键字存储对象的实例。有时候，你会频繁地用到这类操作：\nset users:leto \"{name: leto, planet: dune, likes: [spice]}\" 除了这些外，Redis还有一些常用的操作。例如，strlen 能用来获取一个关键字对应值的长度；getrange 将返回指定范围内的关键字对应值；append 会将value附加到已存在的关键字对应值中（如果该关键字并不存在，则会创建一个新的关键字-值对）。不要犹豫，去试试看这些命令吧。下面是我得到的：\n\u003e strlen users:leto (integer) 42 \u003e getrange users:leto 27 40 \"likes: [spice]\" \u003e append users:leto \" OVER 9000!!\" (integer) 54 现在你可能会想，这很好，但似乎没有什么意义。你不能有效地提取出一段范围内的JSON文件，或者为其附加一些值。你是对的，这里的经验是，一些命令，尤其是关于字符串数据结构的，只有在给定了明确的数据类型后，才会有实际意义。\n之前我们知道了，Redis不会去关注你的值是什么东西。通常情况下，这没有错。然而，一些字符串命令是专门为一些类型或值的结构而设计的。作为一个有些含糊的用例，我们可以看到，对于一些自定义的空间效率很高的（space-efficient）串行化对象，append和getrange命令将会很有用。对于一个更为具体的用例，我们可以再看一下incr、incrby、decr和decrby命令。这些命令会增长或者缩减一个字符串数据结构的值：\n\u003e incr stats:page:about (integer) 1 \u003e incr stats:page:about (integer) 2 \u003e incrby ratings:video:12333 5 (integer) 5 \u003e incrby ratings:video:12333 3 (integer) 8 由此你可以想象到，Redis的字符串数据结构能很好地用于分析用途。你还可以去尝试增长users:leto（一个不是整数的值），然后看看会发生什么（应该会得到一个错误）。\n更为进阶的用例是setbit和getbit命令。“今天我们有多少个独立用户访问”是个在Web应用里常见的问题，有一篇精彩的博文，在里面可以看到Spool是如何使用这两个命令有效地解决此问题。对于1.28亿个用户，一部笔记本电脑在不到50毫秒的时间里就给出了答复，而且只用了16MB的存储空间。\n最重要的事情不是在于你是否明白位图（Bitmaps)的工作原理，或者Spool是如何去使用这些命令，而是应该要清楚Redis的字符串数据结构比你当初所想的要有用许多。然而，最常见的应用案例还是上面我们给出的：存储对象（简单或复杂）和计数。同时，由于通过关键字来获取一个值是如此之快，字符串数据结构很常被用来缓存数据。\n散列（Hashes） link我们已经知道把Redis称为一种关键字-值型存储是不太准确的，散列数据结构是一个很好的例证。你会看到，在很多方面里，散列数据结构很像字符串数据结构。两者显著的区别在于，散列数据结构提供了一个额外的间接层：一个域（Field）。因此，散列数据结构中的set和get是：\nhset users:goku powerlevel 9000 hget users:goku powerlevel 相关的操作还包括在同一时间设置多个域、同一时间获取多个域、获取所有的域和值、列出所有的域或者删除指定的一个域：\nhmset users:goku race saiyan age 737 hmget users:goku race powerlevel hgetall users:goku hkeys users:goku hdel users:goku age 如你所见，散列数据结构比普通的字符串数据结构具有更多的可操作性。我们可以使用一个散列数据结构去获得更精确的描述，是存储一个用户，而不是一个序列化对象。从而得到的好处是能够提取、更新和删除具体的数据片段，而不必去获取或写入整个值。\n对于散列数据结构，可以从一个经过明确定义的对象的角度来考虑，例如一个用户，关键之处在于要理解他们是如何工作的。从性能上的原因来看，这是正确的，更具粒度化的控制可能会相当有用。在下一章我们将会看到，如何用散列数据结构去组织你的数据，使查询变得更为实效。在我看来，这是散列真正耀眼的地方。\n列表（Lists） link对于一个给定的关键字，列表数据结构让你可以存储和处理一组值。你可以添加一个值到列表里、获取列表的第一个值或最后一个值以及用给定的索引来处理值。列表数据结构维护了值的顺序，提供了基于索引的高效操作。为了跟踪在网站里注册的最新用户，我们可以维护一个newusers的列表：\nlpush newusers goku ltrim newusers 0 50 （译注：ltrim命令的具体构成是LTRIM Key start stop。要理解ltrim命令，首先要明白Key所存储的值是一个列表，理论上列表可以存放任意个值。对于指定的列表，根据所提供的两个范围参数start和stop，ltrim命令会将指定范围外的值都删除掉，只留下范围内的值。）\n首先，我们将一个新用户推入到列表的前端，然后对列表进行调整，使得该列表只包含50个最近被推入的用户。这是一种常见的模式。ltrim是一个具有O(N)时间复杂度的操作，N是被删除的值的数量。从上面的例子来看，我们总是在插入了一个用户后再进行列表调整，实际上，其将具有O(1)的时间复杂度（因为N将永远等于1）的常数性能。\n这是我们第一次看到一个关键字的对应值索引另一个值。如果我们想要获取最近的10个用户的详细资料，我们可以运行下面的组合操作：\nkeys = redis.lrange('newusers', 0, 10) redis.mget(*keys.map {|u| \"users:#{u}\"}) 我们之前谈论过关于多次往返数据的模式，上面的两行Ruby代码为我们进行了很好的演示。\n当然，对于存储和索引关键字的功能，并不是只有列表数据结构这种方式。值可以是任意的东西，你可以使用列表数据结构去存储日志，也可以用来跟踪用户浏览网站时的路径。如果你过往曾构建过游戏，你可能会使用列表数据结构去跟踪用户的排队活动。\n集合（Sets） link集合数据结构常常被用来存储只能唯一存在的值，并提供了许多的基于集合的操作，例如并集。集合数据结构没有对值进行排序，但是其提供了高效的基于值的操作。使用集合数据结构的典型用例是朋友名单的实现：\nsadd friends:leto ghanima paul chani jessica sadd friends:duncan paul jessica alia 不管一个用户有多少个朋友，我们都能高效地（O(1)时间复杂度）识别出用户X是不是用户Y的朋友：\nsismember friends:leto jessica sismember friends:leto vladimir 而且，我们可以查看两个或更多的人是不是有共同的朋友：\nsinter friends:leto friends:duncan 甚至可以在一个新的关键字里存储结果：\nsinterstore friends:leto_duncan friends:leto friends:duncan 有时候需要对值的属性进行标记和跟踪处理，但不能通过简单的复制操作完成，集合数据结构是解决此类问题的最好方法之一。当然，对于那些需要运用集合操作的地方（例如交集和并集），集合数据结构就是最好的选择。\n分类集合（Sorted Sets） link最后也是最强大的数据结构是分类集合数据结构。如果说散列数据结构类似于字符串数据结构，主要区分是域（field）的概念；那么分类集合数据结构就类似于集合数据结构，主要区分是标记（score）的概念。标记提供了排序（sorting）和秩划分（ranking）的功能。如果我们想要一个秩分类的朋友名单，可以这样做：\nzadd friends:duncan 70 ghanima 95 paul 95 chani 75 jessica 1 vladimir 对于duncan的朋友，要怎样计算出标记（score）为90或更高的人数？\nzcount friends:duncan 90 100 如何获取chani在名单里的秩（rank）？\nzrevrank friends:duncan chani （译注：zrank命令的具体构成是ZRANK Key menber，要知道Key存储的Sorted Set默认是根据Score对各个menber进行升序的排列，该命令就是用来获取menber在该排列里的次序，这就是所谓的秩。）\n我们使用了zrevrank命令而不是zrank命令，这是因为Redis的默认排序是从低到高，但是在这个例子里我们的秩划分是从高到低。对于分类集合数据结构，最常见的应用案例是用来实现排行榜系统。事实上，对于一些基于整数排序，且能以标记（score）来进行有效操作的东西，使用分类集合数据结构来处理应该都是不错的选择。\n小结 link对于Redis的5种数据结构，我们进行了高层次的概述。一件有趣的事情是，相对于最初构建时的想法，你经常能用Redis创造出一些更具实效的事情。对于字符串数据结构和分类集合数据结构的使用，很有可能存在一些构建方法是还没有人想到的。当你理解了那些常用的应用案例后，你将发现Redis对于许多类型的问题，都是很理想的选择。还有，不要因为Redis展示了5种数据结构和相应的各种方法，就认为你必须要把所有的东西都用上。只使用一些命令去构建一个特性是很常见的。\n\\clearpage\n第3章 - 使用数据结构 link在上一章里，我们谈论了Redis的5种数据结构，对于一些可能的用途也给出了用例。现在是时候来看看一些更高级，但依然很常见的主题和设计模式。\n大O表示法（Big O Notation） link在本书中，我们之前就已经看到过大O表示法，包括O(1)和O(N)的表示。大O表示法的惯常用途是，描述一些用于处理一定数量元素的行为的综合表现。在Redis里，对于一个要处理一定数量元素的命令，大O表示法让我们能了解该命令的大概运行速度。\n在Redis的文档里，每一个命令的时间复杂度都用大O表示法进行了描述，还能知道各命令的具体性能会受什么因素影响。让我们来看看一些用例。\n常数时间复杂度O(1)被认为是最快速的，无论我们是在处理5个元素还是5百万个元素，最终都能得到相同的性能。对于sismember命令，其作用是告诉我们一个值是否属于一个集合，时间复杂度为O(1)。sismember命令很强大，很大部分的原因是其高效的性能特征。许多Redis命令都具有O(1)的时间复杂度。\n对数时间复杂度O(log(N))被认为是第二快速的，其通过使需扫描的区间不断皱缩来快速完成处理。使用这种“分而治之”的方式，大量的元素能在几个迭代过程里被快速分解完整。zadd命令的时间复杂度就是O(log(N))，其中N是在分类集合中的元素数量。\n再下来就是线性时间复杂度O(N)，在一个表格的非索引列里进行查找就需要O(N)次操作。ltrim命令具有O(N)的时间复杂度，但是，在ltrim命令里，N不是列表所拥有的元素数量，而是被删除的元素数量。从一个具有百万元素的列表里用ltrim命令删除1个元素，要比从一个具有一千个元素的列表里用ltrim命令删除10个元素来的快速（实际上，两者很可能会是一样快，因为两个时间都非常的小）。\n根据给定的最小和最大的值的标记，zremrangebyscore命令会在一个分类集合里进行删除元素操作，其时间复杂度是O(log(N)+M)。这看起来似乎有点儿杂乱，通过阅读文档可以知道，这里的N指的是在分类集合里的总元素数量，而M则是被删除的元素数量。可以看出，对于性能而言，被删除的元素数量很可能会比分类集合里的总元素数量更为重要。\n（译注：zremrangebyscore命令的具体构成是ZREMRANGEBYSCORE Key max mix。）\n对于sort命令，其时间复杂度为O(N+M*log(M))，我们将会在下一章谈论更多的相关细节。从sort命令的性能特征来看，可以说这是Redis里最复杂的一个命令。\n还存在其他的时间复杂度描述，包括O(N^2)和O(C^N)。随着N的增大，其性能将急速下降。在Redis里，没有任何一个命令具有这些类型的时间复杂度。\n值得指出的一点是，在Redis里，当我们发现一些操作具有O(N)的时间复杂度时，我们可能可以找到更为好的方法去处理。\n（译注：对于Big O Notation，相信大家都非常的熟悉，虽然原文仅仅是对该表示法进行简单的介绍，但限于个人的算法知识和文笔水平实在有限，此小节的翻译让我头痛颇久，最终成果也确实难以让人满意，望见谅。）\n仿多关键字查询（Pseudo Multi Key Queries） link时常，你会想通过不同的关键字去查询相同的值。例如，你会想通过电子邮件（当用户开始登录时）去获取用户的具体信息，或者通过用户id（在用户登录后）去获取。有一种很不实效的解决方法，其将用户对象分别放置到两个字符串值里去：\nset users:leto@dune.gov \"{id: 9001, email: 'leto@dune.gov', ...}\" set users:9001 \"{id: 9001, email: 'leto@dune.gov', ...}\" 这种方法很糟糕，如此不但会产生两倍数量的内存，而且这将会成为数据管理的恶梦。\n如果Redis允许你将一个关键字链接到另一个的话，可能情况会好很多，可惜Redis并没有提供这样的功能（而且很可能永远都不会提供）。Redis发展到现在，其开发的首要目的是要保持代码和API的整洁简单，关键字链接功能的内部实现并不符合这个前提（对于关键字，我们还有很多相关方法没有谈论到）。其实，Redis已经提供了解决的方法：散列。\n使用散列数据结构，我们可以摆脱重复的缠绕：\nset users:9001 \"{id: 9001, email: leto@dune.gov, ...}\" hset users:lookup:email leto@dune.gov 9001 我们所做的是，使用域来作为一个二级索引，然后去引用单个用户对象。要通过id来获取用户信息，我们可以使用一个普通的get命令：\nget users:9001 而如果想通过电子邮箱来获取用户信息，我们可以使用hget命令再配合使用get命令（Ruby代码）：\nid = redis.hget('users:lookup:email', 'leto@dune.gov') user = redis.get(\"users:#{id}\") 你很可能将会经常使用这类用法。在我看来，这就是散列真正耀眼的地方。在你了解这类用法之前，这可能不是一个明显的用例。\n引用和索引（References and Indexes） link我们已经看过几个关于值引用的用例，包括介绍列表数据结构时的用例，以及在上面使用散列数据结构来使查询更灵活一些。进行归纳后会发现，对于那些值与值间的索引和引用，我们都必须手动的去管理。诚实来讲，这确实会让人有点沮丧，尤其是当你想到那些引用相关的操作，如管理、更新和删除等，都必须手动的进行时。在Redis里，这个问题还没有很好的解决方法。\n我们已经看到，集合数据结构很常被用来实现这类索引：\nsadd friends:leto ghanima paul chani jessica 这个集合里的每一个成员都是一个Redis字符串数据结构的引用，而每一个引用的值则包含着用户对象的具体信息。那么如果chani改变了她的名字，或者删除了她的帐号，应该如何处理？从整个朋友圈的关系结构来看可能会更好理解，我们知道，chani也有她的朋友：\nsadd friends_of:chani leto paul 如果你有什么待处理情况像上面那样，那在维护成本之外，还会有对于额外索引值的处理和存储空间的成本。这可能会令你感到有点退缩。在下一小节里，我们将会谈论减少使用额外数据交互的性能成本的一些方法（在第1章我们粗略地讨论了下）。\n如果你确实在担忧着这些情况，其实，关系型数据库也有同样的开销。索引需要一定的存储空间，必须通过扫描或查找，然后才能找到相应的记录。其开销也是存在的，当然他们对此做了很多的优化工作，使之变得更为有效。\n再次说明，需要在Redis里手动地管理引用确实是颇为棘手。但是，对于你关心的那些问题，包括性能或存储空间等，应该在经过测试后，才会有真正的理解。我想你会发现这不会是一个大问题。\n数据交互和流水线（Round Trips and Pipelining） link我们已经提到过，与服务器频繁交互是Redis的一种常见模式。这类情况可能很常出现，为了使我们能获益更多，值得仔细去看看我们能利用哪些特性。\n许多命令能接受一个或更多的参数，也有一种关联命令（sister-command）可以接受多个参数。例如早前我们看到过mget命令，接受多个关键字，然后返回值：\nkeys = redis.lrange('newusers', 0, 10) redis.mget(*keys.map {|u| \"users:#{u}\"}) 或者是sadd命令，能添加一个或多个成员到集合里：\nsadd friends:vladimir piter sadd friends:paul jessica leto \"leto II\" chani Redis还支持流水线功能。通常情况下，当一个客户端发送请求到Redis后，在发送下一个请求之前必须等待Redis的答复。使用流水线功能，你可以发送多个请求，而不需要等待Redis响应。这不但减少了网络开销，还能获得性能上的显著提高。\n值得一提的是，Redis会使用存储器去排列命令，因此批量执行命令是一个好主意。至于具体要多大的批量，将取决于你要使用什么命令（更明确来说，该参数有多大）。另一方面来看，如果你要执行的命令需要差不多50个字符的关键字，你大概可以对此进行数千或数万的批量操作。\n对于不同的Redis载体，在流水线里运行命令的方式会有所差异。在Ruby里，你传递一个代码块到pipelined方法：\nredis.pipelined do 9001.times do redis.incr('powerlevel') end end 正如你可能猜想到的，流水线功能可以实际地加速一连串命令的处理。\n事务（Transactions） link每一个Redis命令都具有原子性，包括那些一次处理多项事情的命令。此外，对于使用多个命令，Redis支持事务功能。\n你可能不知道，但Redis实际上是单线程运行的，这就是为什么每一个Redis命令都能够保证具有原子性。当一个命令在执行时，没有其他命令会运行（我们会在往后的章节里简略谈论一下Scaling）。在你考虑到一些命令去做多项事情时，这会特别的有用。例如：\nincr命令实际上就是一个get命令然后紧随一个set命令。\ngetset命令设置一个新的值然后返回原始值。\nsetnx命令首先测试关键字是否存在，只有当关键字不存在时才设置值\n虽然这些都很有用，但在实际开发时，往往会需要运行具有原子性的一组命令。若要这样做，首先要执行multi命令，紧随其后的是所有你想要执行的命令（作为事务的一部分），最后执行exec命令去实际执行命令，或者使用discard命令放弃执行命令。Redis的事务功能保证了什么？\n事务中的命令将会按顺序地被执行\n事务中的命令将会如单个原子操作般被执行（没有其它的客户端命令会在中途被执行）\n事务中的命令要么全部被执行，要么不会执行\n你可以（也应该）在命令行界面对事务功能进行一下测试。还有一点要注意到，没有什么理由不能结合流水线功能和事务功能。\nmulti hincrby groups:1percent balance -9000000000 hincrby groups:99percent balance 9000000000 exec 最后，Redis能让你指定一个关键字（或多个关键字），当关键字有改变时，可以查看或者有条件地应用一个事务。这是用于当你需要获取值，且待运行的命令基于那些值时，所有都在一个事务里。对于上面展示的代码，我们不能去实现自己的incr命令，因为一旦exec命令被调用，他们会全部被执行在一块。我们不能这么做：\nredis.multi() current = redis.get('powerlevel') redis.set('powerlevel', current + 1) redis.exec() （译注：虽然Redis是单线程运行的，但是我们可以同时运行多个Redis客户端进程，常见的并发问题还是会出现。像上面的代码，在get运行之后，set运行之前，powerlevel的值可能会被另一个Redis客户端给改变，从而造成错误。）\n这些不是Redis的事务功能的工作。但是，如果我们增加一个watch到powerlevel，我们可以这样做：\nredis.watch('powerlevel') current = redis.get('powerlevel') redis.multi() redis.set('powerlevel', current + 1) redis.exec() 在我们调用watch后，如果另一个客户端改变了powerlevel的值，我们的事务将会运行失败。如果没有客户端改变powerlevel的值，那么事务会继续工作。我们可以在一个循环里运行这些代码，直到其能正常工作。\n关键字反模式（Keys Anti-Pattern） link在下一章中，我们将会谈论那些没有确切关联到数据结构的命令，其中的一些是管理或调试工具。然而有一个命令我想特别地在这里进行谈论：keys命令。这个命令需要一个模式，然后查找所有匹配的关键字。这个命令看起来很适合一些任务，但这不应该用在实际的产品代码里。为什么？因为这个命令通过线性扫描所有的关键字来进行匹配。或者，简单地说，这个命令太慢了。\n人们会如此去使用这个命令？一般会用来构建一个本地的Bug追踪服务。每一个帐号都有一个id，你可能会通过一个看起来像bug:account_id:bug_id的关键字，把每一个Bug存储到一个字符串数据结构值中去。如果你在任何时候需要查询一个帐号的Bug（显示它们，或者当用户删除了帐号时删除掉这些Bugs），你可能会尝试去使用keys命令：\nkeys bug:1233:* 更好的解决方法应该使用一个散列数据结构，就像我们可以使用散列数据结构来提供一种方法去展示二级索引，因此我们可以使用域来组织数据：\nhset bugs:1233 1 \"{id:1, account: 1233, subject: '...'}\" hset bugs:1233 2 \"{id:2, account: 1233, subject: '...'}\" 从一个帐号里获取所有的Bug标识，可以简单地调用hkeys bugs:1233。去删除一个指定的Bug，可以调用hdel bugs:1233 2。如果要删除了一个帐号，可以通过del bugs:1233把关键字删除掉。\n小结 link结合这一章以及前一章，希望能让你得到一些洞察力，了解如何使用Redis去支持（Power）实际项目。还有其他的模式可以让你去构建各种类型的东西，但真正的关键是要理解基本的数据结构。你将能领悟到，这些数据结构是如何能够实现你最初视角之外的东西。\n\\clearpage\n第4章 超越数据结构 link5种数据结构组成了Redis的基础，其他没有关联特定数据结构的命令也有很多。我们已经看过一些这样的命令：info, select, flushdb, multi, exec, discard, watch和keys 。这一章将看看其他的一些重要命令。\n使用期限（Expiration） linkRedis允许你标记一个关键字的使用期限。你可以给予一个Unix时间戳形式（自1970年1月1日起）的绝对时间，或者一个基于秒的存活时间。这是一个基于关键字的命令，因此其不在乎关键字表示的是哪种类型的数据结构。\nexpire pages:about 30 expireat pages:about 1356933600 第一个命令将会在30秒后删除掉关键字（包括其关联的值）。第二个命令则会在2012年12月31日上午12点删除掉关键字。\n这让Redis能成为一个理想的缓冲引擎。通过ttl命令，你可以知道一个关键字还能够存活多久。而通过persist命令，你可以把一个关键字的使用期限删除掉。\nttl pages:about persist pages:about 最后，有个特殊的字符串命令，setex命令让你可以在一个单独的原子命令里设置一个字符串值，同时里指定一个生存期（这比任何事情都要方便）。\nsetex pages:about 30 'about us....' 发布和订阅（Publication and Subscriptions） linkRedis的列表数据结构有blpop和brpop命令，能从列表里返回且删除第一个（或最后一个）元素，或者被堵塞，直到有一个元素可供操作。这可以用来实现一个简单的队列。\n（译注：对于blpop和brpop命令，如果列表里没有关键字可供操作，连接将被堵塞，直到有另外的Redis客户端使用lpush或rpush命令推入关键字为止。）\n此外，Redis对于消息发布和频道订阅有着一流的支持。你可以打开第二个redis-cli窗口，去尝试一下这些功能。在第一个窗口里订阅一个频道（我们会称它为warnings）：\nsubscribe warnings 其将会答复你订阅的信息。现在，在另一个窗口，发布一条消息到warnings频道：\npublish warnings \"it's over 9000!\" 如果你回到第一个窗口，你应该已经接收到warnings频道发来的消息。\n你可以订阅多个频道（subscribe channel1 channel2 ...），订阅一组基于模式的频道（psubscribe warnings:*），以及使用unsubscribe和punsubscribe命令停止监听一个或多个频道，或一个频道模式。\n最后，可以注意到publish命令的返回值是1，这指出了接收到消息的客户端数量。\n监控和延迟日志（Monitor and Slow Log） linkmonitor命令可以让你查看Redis正在做什么。这是一个优秀的调试工具，能让你了解你的程序如何与Redis进行交互。在两个redis-cli窗口中选一个（如果其中一个还处于订阅状态，你可以使用unsubscribe命令退订，或者直接关掉窗口再重新打开一个新窗口）键入monitor命令。在另一个窗口，执行任何其他类型的命令（例如get或set命令）。在第一个窗口里，你应该可以看到这些命令，包括他们的参数。\n在实际生产环境里，你应该谨慎运行monitor命令，这真的仅仅就是一个很有用的调试和开发工具。除此之外，没有更多要说的了。\n随同monitor命令一起，Redis拥有一个slowlog命令，这是一个优秀的性能剖析工具。其会记录执行时间超过一定数量微秒的命令。在下一章节，我们会简略地涉及如何配置Redis，现在你可以按下面的输入配置Redis去记录所有的命令：\nconfig set slowlog-log-slower-than 0 然后，执行一些命令。最后，你可以检索到所有日志，或者检索最近的那些日志：\nslowlog get slowlog get 10 通过键入slowlog len，你可以获取延迟日志里的日志数量。\n对于每个被你键入的命令，你应该查看4个参数：\n一个自动递增的id\n一个Unix时间戳，表示命令开始运行的时间\n一个微妙级的时间，显示命令运行的总时间\n该命令以及所带参数\n延迟日志保存在存储器中，因此在生产环境中运行（即使有一个低阀值）也应该不是一个问题。默认情况下，它将会追踪最近的1024个日志。\n排序（Sort） linksort命令是Redis最强大的命令之一。它让你可以在一个列表、集合或者分类集合里对值进行排序（分类集合是通过标记来进行排序，而不是集合里的成员）。下面是一个sort命令的简单用例：\nrpush users:leto:guesses 5 9 10 2 4 10 19 2 sort users:leto:guesses 这将返回进行升序排序后的值。这里有一个更高级的例子：\nsadd friends:ghanima leto paul chani jessica alia duncan sort friends:ghanima limit 0 3 desc alpha 上面的命令向我们展示了，如何对已排序的记录进行分页（通过limit），如何返回降序排序的结果（通过desc），以及如何用字典序排序代替数值序排序（通过alpha）。\nsort命令的真正力量是其基于引用对象来进行排序的能力。早先的时候，我们说明了列表、集合和分类集合很常被用于引用其他的Redis对象，sort命令能够解引用这些关系，而且通过潜在值来进行排序。例如，假设我们有一个Bug追踪器能让用户看到各类已存在问题。我们可能使用一个集合数据结构去追踪正在被监视的问题：\nsadd watch:leto 12339 1382 338 9338 你可能会有强烈的感觉，想要通过id来排序这些问题（默认的排序就是这样的），但是，我们更可能是通过问题的严重性来对这些问题进行排序。为此，我们要告诉Redis将使用什么模式来进行排序。首先，为了可以看到一个有意义的结果，让我们添加多一点数据：\nset severity:12339 3 set severity:1382 2 set severity:338 5 set severity:9338 4 要通过问题的严重性来降序排序这些Bug，你可以这样做：\nsort watch:leto by severity:* desc Redis将会用存储在列表（集合或分类集合）中的值去替代模式中的*（通过by）。这会创建出关键字名字，Redis将通过查询其实际值来排序。\n在Redis里，虽然你可以有成千上万个关键字，类似上面展示的关系还是会引起一些混乱。幸好，sort命令也可以工作在散列数据结构及其相关域里。相对于拥有大量的高层次关键字，你可以利用散列：\nhset bug:12339 severity 3 hset bug:12339 priority 1 hset bug:12339 details \"{id: 12339, ....}\" hset bug:1382 severity 2 hset bug:1382 priority 2 hset bug:1382 details \"{id: 1382, ....}\" hset bug:338 severity 5 hset bug:338 priority 3 hset bug:338 details \"{id: 338, ....}\" hset bug:9338 severity 4 hset bug:9338 priority 2 hset bug:9338 details \"{id: 9338, ....}\" 所有的事情不仅变得更为容易管理，而且我们能通过severity或priority来进行排序，还可以告诉sort命令具体要检索出哪一个域的数据：\nsort watch:leto by bug:*-\u003epriority get bug:*-\u003edetails 相同的值替代出现了，但Redis还能识别-\u003e符号，用它来查看散列中指定的域。里面还包括了get参数，这里也会进行值替代和域查看，从而检索出Bug的细节（details域的数据）。\n对于太大的集合，sort命令的执行可能会变得很慢。好消息是，sort命令的输出可以被存储起来：\nsort watch:leto by bug:*-\u003epriority get bug:*-\u003edetails store watch_by_priority:leto 使用我们已经看过的expiration命令，再结合sort命令的store能力，这是一个美妙的组合。\n小结 link这一章主要关注那些非特定数据结构关联的命令。和其他事情一样，它们的使用依情况而定。构建一个程序或特性时，可能不会用到使用期限、发布和订阅或者排序等功能。但知道这些功能的存在是很好的。而且，我们也只接触到了一些命令。还有更多的命令，当你消化理解完这本书后，非常值得去浏览一下完整的命令列表。\n\\clearpage\n第5章 - 管理 link在最后一章里，我们将集中谈论Redis运行中的一些管理方面内容。这是一个不完整的Redis管理指南，我们将会回答一些基本的问题，初接触Redis的新用户可能会很感兴趣。\n配置（Configuration） link当你第一次运行Redis的服务器，它会向你显示一个警告，指redis.conf文件没有被找到。这个文件可以被用来配置Redis的各个方面。一个充分定义（well-documented）的redis.conf文件对各个版本的Redis都有效。范例文件包含了默认的配置选项，因此，对于想要了解设置在干什么，或默认设置是什么，都会很有用。你可以在https://github.com/antirez/redis/raw/2.4.6/redis.conf找到这个文件。\n这个配置文件针对的是Redis 2.4.6，你应该用你的版本号替代上面URL里的\"2.4.6\"。运行info命令，其显示的第一个值就是Redis的版本号。\n因为这个文件已经是充分定义（well-documented），我们就不去再进行设置了。\n除了通过redis.conf文件来配置Redis，config set命令可以用来对个别值进行设置。实际上，在将slowlog-log-slower-than设置为0时，我们就已经使用过这个命令了。\n还有一个config get命令能显示一个设置值。这个命令支持模式匹配，因此如果我们想要显示关联于日志（logging）的所有设置，我们可以这样做：\nconfig get *log* 验证（Authentication） link通过设置requirepass（使用config set命令或redis.conf文件），可以让Redis需要一个密码验证。当requirepass被设置了一个值（就是待用的密码），客户端将需要执行一个auth password命令。\n一旦一个客户端通过了验证，就可以在任意数据库里执行任何一条命令，包括flushall命令，这将会清除掉每一个数据库里的所有关键字。通过配置，你可以重命名一些重要命令为混乱的字符串，从而获得一些安全性。\nrename-command CONFIG 5ec4db169f9d4dddacbfb0c26ea7e5ef rename-command FLUSHALL 1041285018a942a4922cbf76623b741e 或者，你可以将新名字设置为一个空字符串，从而禁用掉一个命令。\n大小限制（Size Limitations） link当你开始使用Redis，你可能会想知道，我能使用多少个关键字？还可能想知道，一个散列数据结构能有多少个域（尤其是当你用它来组织数据时），或者是，一个列表数据结构或集合数据结构能有多少个元素？对于每一个实例，实际限制都能达到亿万级别（hundreds of millions）。\n复制（Replication） linkRedis支持复制功能，这意味着当你向一个Redis实例（Master）进行写入时，一个或多个其他实例（Slaves）能通过Master实例来保持更新。可以在配置文件里设置slaveof，或使用slaveof命令来配置一个Slave实例。对于那些没有进行这些设置的Redis实例，就可能一个Master实例。\n为了更好保护你的数据，复制功能拷贝数据到不同的服务器。复制功能还能用于改善性能，因为读取请求可以被发送到Slave实例。他们可能会返回一些稍微滞后的数据，但对于大多数程序来说，这是一个值得做的折衷。\n遗憾的是，Redis的复制功能还没有提供自动故障恢复。如果Master实例崩溃了，一个Slave实例需要手动的进行升级。如果你想使用Redis去达到某种高可用性，对于使用心跳监控（heartbeat monitoring）和脚本自动开关（scripts to automate the switch）的传统高可用性工具来说，现在还是一个棘手的难题。\n备份文件（Backups） link备份Redis非常简单，你可以将Redis的快照（snapshot）拷贝到任何地方，包括S3、FTP等。默认情况下，Redis会把快照存储为一个名为dump.rdb的文件。在任何时候，你都可以对这个文件执行scp、ftp或cp等常用命令。\n有一种常见情况，在Master实例上会停用快照以及单一附加文件（aof），然后让一个Slave实例去处理备份事宜。这可以帮助减少Master实例的载荷。在不损害整体系统响应性的情况下，你还可以在Slave实例上设置更多主动存储的参数。\n缩放和Redis集群（Scaling and Redis Cluster） link复制功能（Replication）是一个成长中的网站可以利用的第一个工具。有一些命令会比另外一些来的昂贵（例如sort命令），将这些运行载荷转移到一个Slave实例里，可以保持整体系统对于查询的快速响应。\n此外，通过分发你的关键字到多个Redis实例里，可以达到真正的缩放Redis（记住，Redis是单线程的，这些可以运行在同一个逻辑框里）。随着时间的推移，你将需要特别注意这些事情（尽管许多的Redis载体都提供了consistent-hashing算法）。对于数据水平分布（horizontal distribution）的考虑不在这本书所讨论的范围内。这些东西你也很可能不需要去担心，但是，无论你使用哪一种解决方案，有一些事情你还是必须意识到。\n好消息是，这些工作都可在Redis集群下进行。不仅提供水平缩放（包括均衡），为了高可用性，还提供了自动故障恢复。\n高可用性和缩放是可以达到的，只要你愿意为此付出时间和精力，Redis集群也使事情变得简单多了。\n小结 link在过去的一段时间里，已经有许多的计划和网站使用了Redis，毫无疑问，Redis已经可以应用于实际生产中了。然而，一些工具还是不够成熟，尤其是一些安全性和可用性相关的工具。对于Redis集群，我们希望很快就能看到其实现，这应该能为一些现有的管理挑战提供处理帮忙。\n\\clearpage\n总结 link在许多方面，Redis体现了一种简易的数据处理方式，其剥离掉了大部分的复杂性和抽象，并可有效的在不同系统里运行。不少情况下，选择Redis不是最佳的选择。在另一些情况里，Redis就像是为你的数据提供了特别定制的解决方案。\n最终，回到我最开始所说的：Redis很容易学习。现在有许多的新技术，很难弄清楚哪些才真正值得我们花时间去学习。如果你从实际好处来考虑，Redis提供了他的简单性。我坚信，对于你和你的团队，学习Redis是最好的技术投资之一。\n"
            }
        );
    index.add(
            {
                id:  5 ,
                href: "\/TechDocs\/docs\/c-guide\/",
                title: "笨方法学C",
                description: "",
                content: ""
            }
        );
    index.add(
            {
                id:  6 ,
                href: "\/TechDocs\/docs\/c-guide\/summary\/",
                title: "",
                description: " 笨办法学C 中文版 前言 导言：C的笛卡尔之梦 练习0：准备 练习1：启用编译器 练习2：用Make来代替Python 练习3：格式化输出 练习4：Valgrind 介绍 练习5：一个C程序的结构 练习6：变量类型 练习7：更多变量和一些算术 练习8：大小和数组 练习9：数组和字符串 练习10：字符串数组和循环 练习11：While循环和布尔表达式 练习12：If，Else If，Else 练习13：Switch语句 练习14：编写并使用函数 练习15：指针，可怕的指针 练习16：结构体和指向它们的指针 练习17：堆和栈的内存分配 练习18：函数指针 练习19：一个简单的对象系统 练习20：Zed的强大的调试宏 练习21：高级数据类型和控制结构 练习22：栈、作用域和全局 练习23：认识达夫设备 练习24：输入输出和文件 练习25：变参函数 练习26：编写第一个真正的程序 练习27：创造性和防御性编程 练习28：Makefile 进阶 练习29：库和链接 练习30：自动化测试 练习31：代码调试 练习32：双向链表 练习33：链表算法 练习34：动态数组 练习35：排序和搜索 练习36：更安全的字符串 练习37：哈希表 练习38：哈希算法 练习39：字符串算法 练习40：二叉搜索树 练习41：将 Cachegrind 和 Callgrind 用于性能调优 练习42：栈和队列 练习43：一个简单的统计引擎 练习44：环形缓冲区 练习45：一个简单的TCP/IP客户端 练习46：三叉搜索树 练习47：一个快速的URL路由 后记：“解构 K\u0026R C” 已死 捐赠名单 ",
                content: " 笨办法学C 中文版 前言 导言：C的笛卡尔之梦 练习0：准备 练习1：启用编译器 练习2：用Make来代替Python 练习3：格式化输出 练习4：Valgrind 介绍 练习5：一个C程序的结构 练习6：变量类型 练习7：更多变量和一些算术 练习8：大小和数组 练习9：数组和字符串 练习10：字符串数组和循环 练习11：While循环和布尔表达式 练习12：If，Else If，Else 练习13：Switch语句 练习14：编写并使用函数 练习15：指针，可怕的指针 练习16：结构体和指向它们的指针 练习17：堆和栈的内存分配 练习18：函数指针 练习19：一个简单的对象系统 练习20：Zed的强大的调试宏 练习21：高级数据类型和控制结构 练习22：栈、作用域和全局 练习23：认识达夫设备 练习24：输入输出和文件 练习25：变参函数 练习26：编写第一个真正的程序 练习27：创造性和防御性编程 练习28：Makefile 进阶 练习29：库和链接 练习30：自动化测试 练习31：代码调试 练习32：双向链表 练习33：链表算法 练习34：动态数组 练习35：排序和搜索 练习36：更安全的字符串 练习37：哈希表 练习38：哈希算法 练习39：字符串算法 练习40：二叉搜索树 练习41：将 Cachegrind 和 Callgrind 用于性能调优 练习42：栈和队列 练习43：一个简单的统计引擎 练习44：环形缓冲区 练习45：一个简单的TCP/IP客户端 练习46：三叉搜索树 练习47：一个快速的URL路由 后记：“解构 K\u0026R C” 已死 捐赠名单 "
            }
        );
    index.add(
            {
                id:  7 ,
                href: "\/TechDocs\/docs\/c-guide\/readme\/",
                title: "笨办法学C 中文版",
                description: "来源：Learn C The Hard Way\n作者：Zed A. Shaw\n译者：飞龙\n自豪地采用谷歌翻译\n一句 MMP 送给在座的各位程序正义垃圾。\n在线阅读 PDF格式 EPUB格式 MOBI格式 Github 赞助我 link 协议 link此版本遵循CC BY-NC-SA 4.0协议，原版无此约束。",
                content: "来源：Learn C The Hard Way\n作者：Zed A. Shaw\n译者：飞龙\n自豪地采用谷歌翻译\n一句 MMP 送给在座的各位程序正义垃圾。\n在线阅读 PDF格式 EPUB格式 MOBI格式 Github 赞助我 link 协议 link此版本遵循CC BY-NC-SA 4.0协议，原版无此约束。\n"
            }
        );
    index.add(
            {
                id:  8 ,
                href: "\/TechDocs\/docs\/c-guide\/preface\/",
                title: "前言",
                description: "原文：Preface\n译者：飞龙\n这是本书创作中的转储版本，所用的措辞可能不是很好，也可能缺失了一些章节，但是你可以看到我编写这本书的过程，以及我的做事风格。\n你也可以随时发送邮件到help@learncodethehardway.org来向我寻求帮助，我通常会在1~2天之内答复。\n这个列表是一个讨论列表，并不只允许发布公告，它用于讨论本书和询问问题。\n最后，不要忘了我之前写过笨办法学Python，如果你还不会编程，你应该先读完它。LCTHW并不面向初学者，而是面向至少读完LPTHW或者已经懂得一门其它编程语言的人。\n常见问题 link这门课程需要多少时间？\n你应该花一些时间直到你掌握它，并且每天都要坚持编写代码。一些人花了大约三个月，其它人花了六个月，还有一些人只用了一个星期。\n我需要准备什么样的电脑？\n你需要OSX或者Linux来完成这本书。",
                content: " 原文：Preface\n译者：飞龙\n这是本书创作中的转储版本，所用的措辞可能不是很好，也可能缺失了一些章节，但是你可以看到我编写这本书的过程，以及我的做事风格。\n你也可以随时发送邮件到help@learncodethehardway.org来向我寻求帮助，我通常会在1~2天之内答复。\n这个列表是一个讨论列表，并不只允许发布公告，它用于讨论本书和询问问题。\n最后，不要忘了我之前写过笨办法学Python，如果你还不会编程，你应该先读完它。LCTHW并不面向初学者，而是面向至少读完LPTHW或者已经懂得一门其它编程语言的人。\n常见问题 link这门课程需要多少时间？\n你应该花一些时间直到你掌握它，并且每天都要坚持编写代码。一些人花了大约三个月，其它人花了六个月，还有一些人只用了一个星期。\n我需要准备什么样的电脑？\n你需要OSX或者Linux来完成这本书。\n"
            }
        );
    index.add(
            {
                id:  9 ,
                href: "\/TechDocs\/docs\/c-guide\/introduction\/",
                title: "导言：C的笛卡尔之梦",
                description: "原文：Introduction: The Cartesian Dream Of C\n译者：飞龙\n‍\n直到现在，凡是我当作最真实、最可靠而接受的东西，都是从感官或通过感官得来的。不过，我有时觉得这些感官是骗人的，并且为了小心谨慎起见，对于一经骗过我们的东西就决不完全加以信任。\n勒内·笛卡尔，《第一哲学沉思录》\n如果有一段引述用来描述C语言编程的话，那就是它了。对于大多数程序员，C是极其可怕而且邪恶的。他就像是恶魔、撒旦，或者一个使用指针的花言巧语和对机器的直接访问来破坏你生产力的骗子洛基。于是，一旦这位计算界的路西法将你缠住，他就会使用邪恶的“段错误”来毁掉你的世界，并且揭露出与你交易中的骗局而嘲笑你。\n然而，C并不应由于这些事实而受到责备。你的电脑和控制它的操作系统才是真正的骗子，而不是朋友。它们通过密谋来向你隐藏它们的真实执行逻辑，使你永远都不真正知道背后发生了什么。C编程语言的失败之处只是向你提供接触背后真正工作原理的途径，并且告诉了你一些难以接受的事实。C会向你展示痛苦的真像（红色药丸），它将幕布拉开来向你展示一些神奇的原理。C即是真理。\n既然C如此危险，为什么还要使用它？因为C给了你力量来穿越抽象的假象，并且将你从愚昧中解放出来。\n你会学到什么 link这本书的目的是让你足够熟悉C语言，并能够使用它编写自己的软件，或者修改其他人的代码。这本书的最后，我们会从一本叫做“K\u0026R C”的名著中选取实际的代码，并且用你学过的知识来做代码审查。你需要学习下面这些东西来达到这一阶段：\nC的基本语法和编写习惯。 编译，make文件和链接。 寻找和预防bug。 防御性编程实践。 使C的代码崩溃。 编写基本的Unix系统软件。 截至最后一章，你将会有足够的工具来解决基本的系统软件、库和其它小项目。\n如何阅读本书 link这本书为那些已经掌握至少一门编程语言的人而设计。如果你还没有接触过编程，我推荐你先学习笨办法学Python，这本书适用于真正的新手并且适合作为第一本编程书。一旦你学会了Python，你可以返回来开始学习这本书。\n对于那些已经学会编程的人，这本书的开头可能有些奇怪。它不像其它书一样，那些书中你会阅读一段段的文字然后编写一些代码。相反，这本书中我会让你立即开始编程，之后我会解释你做了什么。这样更有效果，因为你已经经历过的事情解释起来更加容易。\n由于采用了这样的结构，下面是本书中你必须遵守的规则：\n手动输入所有代码。不要复制粘贴！ 正确地输入所有代码，也包括注释。 运行代码并保证产生相同的输出。 如果出现了bug则修正它。 做附加题时，如果你做不出某道题，马上跳过。 在寻求帮助之前首先试着自己弄懂。 如果你遵守了这些规则，完成了本书的每一件事，并且还不会编程C代码的话，你至少尝试过了。它并不适用于每个人，但是尝试的过程会让你成为一个更好的程序员。\n核心能力 link我假设你之前使用为“弱者”设计的语言。这些“易用的”语言之一是Python或者Ruby，它们带给了你草率的思维和半吊子的黑魔法。或者，你可能使用类似Lisp的语言，它假设计算机是纯函数式的奇幻大陆，带有一些为婴儿准备的充气墙。再或者你可能学过Prolog，于是你认为整个世界都是一个数据库，你可以从中寻找线索。甚至更糟糕的是，我假设你一直都在用IDE，所以你的大脑布满了内存漏洞，并且你每打三个字符都要按CTRL+空格来打出函数的整个名字。\n无论你的背景如何，你都可能不擅长下面四个技能：\n阅读和编写\n如果你使用IDE这会尤其正确。但是总体上我发现程序员做了很多“略读”，并且在理解上存在问题。它们会略读需要详细理解的代码，并且觉得他们已经理解了但事实上没有。其它语言提供了可以让他们避免实际编写任何代码的工具，所以面对一种类似C的语言时，他们就玩完了。你需要知道每个人都有这个问题，并且你可以通过强迫自己慢下来并且仔细对待阅读和编写代码来改正它。一开始你可能感到痛苦和无聊，但是这样的次数多了它也就变得容易了。\n专注细节\n每个人都不擅长这方面，它也是劣质软件的罪魁祸首。其它语言让你不会集中注意力，但是C要求你集中全部注意力，因为它直接在机器上运行，并且机器比较挑剔。C中没有“相似的类型”或者“足够接近”，所以你需要注意，再三检查你的代码，并假设你写的任何代码都是错的，直到你能证明它是对的。\n定位差异\n其它语言程序员的一个关键问题就是他们的大脑被训练来指出那个语言的差异，而不是C。当你对比你的代码和我练习中的代码时，你的眼睛会跳过你认为不重要或者不熟悉的字符。我会给你一些策略来强制你观察你的错误，但是要记住如果你的代码并不完全像书中的代码，它就是错的。\n规划和调试\n我喜欢其它较简单的语言，因为我可以想怎么写就怎么写。我将已有的想法输入进解释器，然后可以立即看到结果。你可以把你的想法试验出来，但是要注意，如果你仍然打算“试验代码使其能够工作”，它就行不通了。C对于你来说稍困难，因为你需要规划好首先创建什么。的确，你也可以进行试验，但是比起其他语言，你必须在C中更早地严肃对待代码。我会教给你在编程之前规划程序核心部分的方法，这对于使你成为更好的程序员十分有帮助。即使一个很小的规划，都会使接下来的事情变得顺利。\n学习C语言会使你变成更好的程序员，因为会强制你更早、更频繁地解决这些问题。你不会再草率地编写半吊子的代码，代码也会能够正常工作。C的优势是，它是一个简单的语言，你可以自己来弄清楚，这使得它成为用于学习机器，以及提升程序员核心技能的最佳语言。\nC比其它语言都要难，而这是由于C并不对你隐藏细节，它们在其它语言中都试图并且未能被掩盖。\n协议 link原书在完稿之后可以自由分发，并且能在亚马逊上购买。该中译版本遵循CC BY-NC-SA 4.0协议，你可以在保留署名和出处的前提下以非商业目的自由转载。",
                content: " 原文：Introduction: The Cartesian Dream Of C\n译者：飞龙\n‍\n直到现在，凡是我当作最真实、最可靠而接受的东西，都是从感官或通过感官得来的。不过，我有时觉得这些感官是骗人的，并且为了小心谨慎起见，对于一经骗过我们的东西就决不完全加以信任。\n勒内·笛卡尔，《第一哲学沉思录》\n如果有一段引述用来描述C语言编程的话，那就是它了。对于大多数程序员，C是极其可怕而且邪恶的。他就像是恶魔、撒旦，或者一个使用指针的花言巧语和对机器的直接访问来破坏你生产力的骗子洛基。于是，一旦这位计算界的路西法将你缠住，他就会使用邪恶的“段错误”来毁掉你的世界，并且揭露出与你交易中的骗局而嘲笑你。\n然而，C并不应由于这些事实而受到责备。你的电脑和控制它的操作系统才是真正的骗子，而不是朋友。它们通过密谋来向你隐藏它们的真实执行逻辑，使你永远都不真正知道背后发生了什么。C编程语言的失败之处只是向你提供接触背后真正工作原理的途径，并且告诉了你一些难以接受的事实。C会向你展示痛苦的真像（红色药丸），它将幕布拉开来向你展示一些神奇的原理。C即是真理。\n既然C如此危险，为什么还要使用它？因为C给了你力量来穿越抽象的假象，并且将你从愚昧中解放出来。\n你会学到什么 link这本书的目的是让你足够熟悉C语言，并能够使用它编写自己的软件，或者修改其他人的代码。这本书的最后，我们会从一本叫做“K\u0026R C”的名著中选取实际的代码，并且用你学过的知识来做代码审查。你需要学习下面这些东西来达到这一阶段：\nC的基本语法和编写习惯。 编译，make文件和链接。 寻找和预防bug。 防御性编程实践。 使C的代码崩溃。 编写基本的Unix系统软件。 截至最后一章，你将会有足够的工具来解决基本的系统软件、库和其它小项目。\n如何阅读本书 link这本书为那些已经掌握至少一门编程语言的人而设计。如果你还没有接触过编程，我推荐你先学习笨办法学Python，这本书适用于真正的新手并且适合作为第一本编程书。一旦你学会了Python，你可以返回来开始学习这本书。\n对于那些已经学会编程的人，这本书的开头可能有些奇怪。它不像其它书一样，那些书中你会阅读一段段的文字然后编写一些代码。相反，这本书中我会让你立即开始编程，之后我会解释你做了什么。这样更有效果，因为你已经经历过的事情解释起来更加容易。\n由于采用了这样的结构，下面是本书中你必须遵守的规则：\n手动输入所有代码。不要复制粘贴！ 正确地输入所有代码，也包括注释。 运行代码并保证产生相同的输出。 如果出现了bug则修正它。 做附加题时，如果你做不出某道题，马上跳过。 在寻求帮助之前首先试着自己弄懂。 如果你遵守了这些规则，完成了本书的每一件事，并且还不会编程C代码的话，你至少尝试过了。它并不适用于每个人，但是尝试的过程会让你成为一个更好的程序员。\n核心能力 link我假设你之前使用为“弱者”设计的语言。这些“易用的”语言之一是Python或者Ruby，它们带给了你草率的思维和半吊子的黑魔法。或者，你可能使用类似Lisp的语言，它假设计算机是纯函数式的奇幻大陆，带有一些为婴儿准备的充气墙。再或者你可能学过Prolog，于是你认为整个世界都是一个数据库，你可以从中寻找线索。甚至更糟糕的是，我假设你一直都在用IDE，所以你的大脑布满了内存漏洞，并且你每打三个字符都要按CTRL+空格来打出函数的整个名字。\n无论你的背景如何，你都可能不擅长下面四个技能：\n阅读和编写\n如果你使用IDE这会尤其正确。但是总体上我发现程序员做了很多“略读”，并且在理解上存在问题。它们会略读需要详细理解的代码，并且觉得他们已经理解了但事实上没有。其它语言提供了可以让他们避免实际编写任何代码的工具，所以面对一种类似C的语言时，他们就玩完了。你需要知道每个人都有这个问题，并且你可以通过强迫自己慢下来并且仔细对待阅读和编写代码来改正它。一开始你可能感到痛苦和无聊，但是这样的次数多了它也就变得容易了。\n专注细节\n每个人都不擅长这方面，它也是劣质软件的罪魁祸首。其它语言让你不会集中注意力，但是C要求你集中全部注意力，因为它直接在机器上运行，并且机器比较挑剔。C中没有“相似的类型”或者“足够接近”，所以你需要注意，再三检查你的代码，并假设你写的任何代码都是错的，直到你能证明它是对的。\n定位差异\n其它语言程序员的一个关键问题就是他们的大脑被训练来指出那个语言的差异，而不是C。当你对比你的代码和我练习中的代码时，你的眼睛会跳过你认为不重要或者不熟悉的字符。我会给你一些策略来强制你观察你的错误，但是要记住如果你的代码并不完全像书中的代码，它就是错的。\n规划和调试\n我喜欢其它较简单的语言，因为我可以想怎么写就怎么写。我将已有的想法输入进解释器，然后可以立即看到结果。你可以把你的想法试验出来，但是要注意，如果你仍然打算“试验代码使其能够工作”，它就行不通了。C对于你来说稍困难，因为你需要规划好首先创建什么。的确，你也可以进行试验，但是比起其他语言，你必须在C中更早地严肃对待代码。我会教给你在编程之前规划程序核心部分的方法，这对于使你成为更好的程序员十分有帮助。即使一个很小的规划，都会使接下来的事情变得顺利。\n学习C语言会使你变成更好的程序员，因为会强制你更早、更频繁地解决这些问题。你不会再草率地编写半吊子的代码，代码也会能够正常工作。C的优势是，它是一个简单的语言，你可以自己来弄清楚，这使得它成为用于学习机器，以及提升程序员核心技能的最佳语言。\nC比其它语言都要难，而这是由于C并不对你隐藏细节，它们在其它语言中都试图并且未能被掩盖。\n协议 link原书在完稿之后可以自由分发，并且能在亚马逊上购买。该中译版本遵循CC BY-NC-SA 4.0协议，你可以在保留署名和出处的前提下以非商业目的自由转载。\n"
            }
        );
    index.add(
            {
                id:  10 ,
                href: "\/TechDocs\/docs\/c-guide\/ex0\/",
                title: "练习0：准备",
                description: "原文：Exercise 0: The Setup\n译者：飞龙\n在这一章中，你将为C语言编程配置好你的系统。一个好消息是对于所有使用Linux或者Mac的人，你的系统是为C语言编程而设计的。C语言的创造者也对Unix操作系统的创造做出了贡献，并且Linux和OSX都是基于Unix的。事实上，安装工作会非常简单。\n对于Windows上的用户，我有一个坏消息：在Windows上学习C非常痛苦。你可以在Windows上编写C代码，这并不是问题。问题是所有的库、函数和工具都和其它的C语言环境有些差异。C来自于Unix，并且和Unix平台配合得比较好。恐怕这是一个你并不能接受的事实。\n然而你并不需要为此恐慌。我并不是说要完全避免Windows。然而我说的是，如果你打算以最短的时间来学习C，你需要接触Unix并适应它。这同时也对你有帮助，因为懂得一些Unix的知识，也会让你懂得一些C编程的习惯，以及扩充你的技能。\n这也意味着每个人都需要使用命令行。嗯，就是这样。你将会进入命令行并且键入一些命令。不要为此感到害怕，因为我会告诉你要键入什么，以及结果应该是什么样子，所以你实际上会学到很多东西，同时扩充自己的技能。\nLinux link在多数Linux系统上你都需要安装一些包。对于基于Debian的系统，例如Ubuntu你需要使用下列命令来安装一些东西：\n$ sudo apt-get install build-essential 上面是命令行提示符的一个示例。你需要接触到能输入它的地方，找到你的“终端”程序并且运行它。接着，你会看到一个类似于$的Shell提示符，并且你可以在里面键入命令。不要键入$，而是它后面的东西。\n下面是在基于RPM的Linux系统，例如Fedora中执行相同安装工作的方法：\n$ su -c \"yum groupinstall development-tools\" 一旦你运行了它，它会正常工作，你应该能够做本书的第一个练习。如果不能请告诉我。\nMac OSX link在 Mac OSX上，安装工作会更简单。首先，你需要从苹果官网下载最新的XCode，或者找到你的安装DVD并从中安装。需要下载的文件很大，要花费很长时间，所以我推荐你从DVD安装。同时，上网搜索“安装xcode”来指导你来安装它。\n一旦你安装完XCode，可能需要重启你的电脑。你可以找到你的终端程序并且将它放到快捷启动栏中。在本书中你会经常用到终端，所以最好将它放到顺手的区域。\nWindows link对于Windows用户，你需要在虚拟机中安装并运行一个基本的Ubuntu Linux系统，来做本书的练习，并且避免任何Windows中安装的问题。\n译者注：如果你的Windows版本是Win10 14316及之后的版本，可以开启Ubuntu子系统来获取Linux环境。\n文本编辑器 link对于程序员来说，文本编辑器的选择有些困难。对于初学者我推荐他们使用Gedit，因为它很简单，并且可以用于编写代码。然而，它在特定的国际化环境中并不能正常工作。如果你已经是老司机的话，你可以选用你最喜欢的编辑器。\n出于这种考虑，我打算让你尝试一些你所在平台上的标准的用于编程的文本编辑器，并且长期使用其中你最喜欢的一个。如果你已经用了Gedit并且很喜欢他，那么就一致用下去。如果你打算尝试一些不同的编辑器，则赶快尝试并选择一个。\n最重要的事情是，不要纠结于寻找最完美的编辑器。文本编辑器几乎都很奇怪，你只需要选择一个并熟悉它，如果你发现喜欢别的编辑器可以切换到它。不要在挑选它和把它变得更好上面花很多时间。\n这是亦可以尝试的一些编辑器：\nLinux和OSX上的Gedit。 OSX上的TextWrangler。 可以在终端中运行并几乎在任何地方工作的Nano。 Emacs和Emacs OSX。需要学习一些东西。 Vim和Mac Vim。 每个人都可能选择一款不同的编辑器，这些只是一部分人所选择的开源编辑器。在找到你最喜欢的那个之前，尝试其中的一些，甚至是一些商业编辑器。\n警告：不要使用IDE linkIDE，或者“集成开发工具”，会使你变笨。如果你想要成为一个好的程序员，它会是最糟糕的工具，因为它隐藏了背后的细节，你的工作是弄清楚背后发生了什么。如果你试着完成一些事情，并且所在平台根据特定的IDE而设计，它们非常有用，但是对于学习C编程（以及许多其它语言），它们没有意义。\n注\n如果你玩过吉他，你应该知道TAB是什么。但是对于其它人，让我对其做个解释。在音乐中有一种乐谱叫做“五线谱”。它是通用、非常古老的乐谱，以一种通用的方法来记下其它人应该在乐器上弹奏的音符。如果你弹过钢琴，这种乐谱非常易于使用，因为它几乎就是为钢琴和交响乐发明的。\n然而吉他是一种奇怪的乐器，它并不能很好地适用这种乐谱。所以吉他手通常使用一种叫做TAB（tablature）的乐谱。它所做的不是告诉你该弹奏哪个音符，而是在当时应该拨哪根弦。你完全可以在不知道所弹奏的单个音符的情况下学习整首乐曲，许多人也都是这么做的，但是如果你想知道你弹的是什么，TAB是毫无意义的。\n传统的乐谱可能比TAB更难一些，但是会告诉你如何演奏音乐，而不是如果玩吉他。通过传统的乐谱我可以在钢琴上，或者在贝斯上弹奏相同的曲子。我也可以将它放到电脑中，为它设计全部的曲谱。但是通过TAB我只能在吉他上弹奏。\nIDE就像是TAB，你可以用它非常快速地编程，但是你只能够用一种语言在一个平台上编程。这就是公司喜欢将它卖给你的原因。它们知道你比较懒，并且由于它只适用于它们自己的平台，他们就将你锁定在了那个平台上。\n打破这一循环的办法就是不用IDE学习编程。一个普通的文本编辑器，或者一个程序员使用的文本编辑器，例如Vim或者Emacs，能让你更熟悉代码。这有一点点困难，但是终结果是你将会熟悉任何代码，在任何计算机上，以任何语言，并且懂得背后的原理。",
                content: " 原文：Exercise 0: The Setup\n译者：飞龙\n在这一章中，你将为C语言编程配置好你的系统。一个好消息是对于所有使用Linux或者Mac的人，你的系统是为C语言编程而设计的。C语言的创造者也对Unix操作系统的创造做出了贡献，并且Linux和OSX都是基于Unix的。事实上，安装工作会非常简单。\n对于Windows上的用户，我有一个坏消息：在Windows上学习C非常痛苦。你可以在Windows上编写C代码，这并不是问题。问题是所有的库、函数和工具都和其它的C语言环境有些差异。C来自于Unix，并且和Unix平台配合得比较好。恐怕这是一个你并不能接受的事实。\n然而你并不需要为此恐慌。我并不是说要完全避免Windows。然而我说的是，如果你打算以最短的时间来学习C，你需要接触Unix并适应它。这同时也对你有帮助，因为懂得一些Unix的知识，也会让你懂得一些C编程的习惯，以及扩充你的技能。\n这也意味着每个人都需要使用命令行。嗯，就是这样。你将会进入命令行并且键入一些命令。不要为此感到害怕，因为我会告诉你要键入什么，以及结果应该是什么样子，所以你实际上会学到很多东西，同时扩充自己的技能。\nLinux link在多数Linux系统上你都需要安装一些包。对于基于Debian的系统，例如Ubuntu你需要使用下列命令来安装一些东西：\n$ sudo apt-get install build-essential 上面是命令行提示符的一个示例。你需要接触到能输入它的地方，找到你的“终端”程序并且运行它。接着，你会看到一个类似于$的Shell提示符，并且你可以在里面键入命令。不要键入$，而是它后面的东西。\n下面是在基于RPM的Linux系统，例如Fedora中执行相同安装工作的方法：\n$ su -c \"yum groupinstall development-tools\" 一旦你运行了它，它会正常工作，你应该能够做本书的第一个练习。如果不能请告诉我。\nMac OSX link在 Mac OSX上，安装工作会更简单。首先，你需要从苹果官网下载最新的XCode，或者找到你的安装DVD并从中安装。需要下载的文件很大，要花费很长时间，所以我推荐你从DVD安装。同时，上网搜索“安装xcode”来指导你来安装它。\n一旦你安装完XCode，可能需要重启你的电脑。你可以找到你的终端程序并且将它放到快捷启动栏中。在本书中你会经常用到终端，所以最好将它放到顺手的区域。\nWindows link对于Windows用户，你需要在虚拟机中安装并运行一个基本的Ubuntu Linux系统，来做本书的练习，并且避免任何Windows中安装的问题。\n译者注：如果你的Windows版本是Win10 14316及之后的版本，可以开启Ubuntu子系统来获取Linux环境。\n文本编辑器 link对于程序员来说，文本编辑器的选择有些困难。对于初学者我推荐他们使用Gedit，因为它很简单，并且可以用于编写代码。然而，它在特定的国际化环境中并不能正常工作。如果你已经是老司机的话，你可以选用你最喜欢的编辑器。\n出于这种考虑，我打算让你尝试一些你所在平台上的标准的用于编程的文本编辑器，并且长期使用其中你最喜欢的一个。如果你已经用了Gedit并且很喜欢他，那么就一致用下去。如果你打算尝试一些不同的编辑器，则赶快尝试并选择一个。\n最重要的事情是，不要纠结于寻找最完美的编辑器。文本编辑器几乎都很奇怪，你只需要选择一个并熟悉它，如果你发现喜欢别的编辑器可以切换到它。不要在挑选它和把它变得更好上面花很多时间。\n这是亦可以尝试的一些编辑器：\nLinux和OSX上的Gedit。 OSX上的TextWrangler。 可以在终端中运行并几乎在任何地方工作的Nano。 Emacs和Emacs OSX。需要学习一些东西。 Vim和Mac Vim。 每个人都可能选择一款不同的编辑器，这些只是一部分人所选择的开源编辑器。在找到你最喜欢的那个之前，尝试其中的一些，甚至是一些商业编辑器。\n警告：不要使用IDE linkIDE，或者“集成开发工具”，会使你变笨。如果你想要成为一个好的程序员，它会是最糟糕的工具，因为它隐藏了背后的细节，你的工作是弄清楚背后发生了什么。如果你试着完成一些事情，并且所在平台根据特定的IDE而设计，它们非常有用，但是对于学习C编程（以及许多其它语言），它们没有意义。\n注\n如果你玩过吉他，你应该知道TAB是什么。但是对于其它人，让我对其做个解释。在音乐中有一种乐谱叫做“五线谱”。它是通用、非常古老的乐谱，以一种通用的方法来记下其它人应该在乐器上弹奏的音符。如果你弹过钢琴，这种乐谱非常易于使用，因为它几乎就是为钢琴和交响乐发明的。\n然而吉他是一种奇怪的乐器，它并不能很好地适用这种乐谱。所以吉他手通常使用一种叫做TAB（tablature）的乐谱。它所做的不是告诉你该弹奏哪个音符，而是在当时应该拨哪根弦。你完全可以在不知道所弹奏的单个音符的情况下学习整首乐曲，许多人也都是这么做的，但是如果你想知道你弹的是什么，TAB是毫无意义的。\n传统的乐谱可能比TAB更难一些，但是会告诉你如何演奏音乐，而不是如果玩吉他。通过传统的乐谱我可以在钢琴上，或者在贝斯上弹奏相同的曲子。我也可以将它放到电脑中，为它设计全部的曲谱。但是通过TAB我只能在吉他上弹奏。\nIDE就像是TAB，你可以用它非常快速地编程，但是你只能够用一种语言在一个平台上编程。这就是公司喜欢将它卖给你的原因。它们知道你比较懒，并且由于它只适用于它们自己的平台，他们就将你锁定在了那个平台上。\n打破这一循环的办法就是不用IDE学习编程。一个普通的文本编辑器，或者一个程序员使用的文本编辑器，例如Vim或者Emacs，能让你更熟悉代码。这有一点点困难，但是终结果是你将会熟悉任何代码，在任何计算机上，以任何语言，并且懂得背后的原理。\n"
            }
        );
    index.add(
            {
                id:  11 ,
                href: "\/TechDocs\/docs\/c-guide\/ex1\/",
                title: "练习1：启用编译器",
                description: "原文：Exercise 1: Dust Off That Compiler\n译者：飞龙\n这是你用C写的第一个简单的程序：\nint main(int argc, char *argv[]) { puts(\"Hello world.\"); return 0; } 把它写进 ex1.c 并输入：\n$ make ex1 cc ex1.c -o ex1 你的编译器可能会使用一个有些不同的命令，但是最后应该会产生一个名为ex1的文件，并且你可以运行它。\n你会看到什么 link现在你可以运行程序并看到输出。\n$ ./ex1 Hello world. 如果没有，则需要返回去修复它。\n如何使它崩溃 link在这本书中我会添加一个小节，关于如何使程序崩溃。我会让你对程序做一些奇怪的事情，以奇怪的方式运行，或者修改代码，以便让你看到崩溃和编译器错误。\n对于这个程序，打开所有编译警告重新构建它：\n$ rm ex1 $ CFLAGS=\"-Wall\" make ex1 cc -Wall ex1.c -o ex1 ex1.c: In function 'main': ex1.c:3: warning: implicit declaration of function 'puts' $ ./ex1 Hello world. $ 现在你会得到一个警告，说puts函数是隐式声明的。C语言的编译器很智能，它能够理解你想要什么。但是如果可以的话，你应该去除所有编译器警告。把下面一行添加到ex1.c文件的最上面，之后重新编译来去除它：",
                content: " 原文：Exercise 1: Dust Off That Compiler\n译者：飞龙\n这是你用C写的第一个简单的程序：\nint main(int argc, char *argv[]) { puts(\"Hello world.\"); return 0; } 把它写进 ex1.c 并输入：\n$ make ex1 cc ex1.c -o ex1 你的编译器可能会使用一个有些不同的命令，但是最后应该会产生一个名为ex1的文件，并且你可以运行它。\n你会看到什么 link现在你可以运行程序并看到输出。\n$ ./ex1 Hello world. 如果没有，则需要返回去修复它。\n如何使它崩溃 link在这本书中我会添加一个小节，关于如何使程序崩溃。我会让你对程序做一些奇怪的事情，以奇怪的方式运行，或者修改代码，以便让你看到崩溃和编译器错误。\n对于这个程序，打开所有编译警告重新构建它：\n$ rm ex1 $ CFLAGS=\"-Wall\" make ex1 cc -Wall ex1.c -o ex1 ex1.c: In function 'main': ex1.c:3: warning: implicit declaration of function 'puts' $ ./ex1 Hello world. $ 现在你会得到一个警告，说puts函数是隐式声明的。C语言的编译器很智能，它能够理解你想要什么。但是如果可以的话，你应该去除所有编译器警告。把下面一行添加到ex1.c文件的最上面，之后重新编译来去除它：\n#include 现在像刚才一样重新执行make命令，你会看到所有警告都消失了。\n附加题 link 在你的文本编辑器中打开ex1文件，随机修改或删除一部分，之后运行它看看发生了什么。 再多打印5行文本或者其它比\"Hello world.\"更复杂的东西。 执行man 3 puts来阅读这个函数和其它函数的文档。 "
            }
        );
    index.add(
            {
                id:  12 ,
                href: "\/TechDocs\/docs\/c-guide\/ex2\/",
                title: "练习2：用Make来代替Python",
                description: "原文：Exercise 2: Make Is Your Python Now\n译者：飞龙\n在Python中，你仅仅需要输入python，就可以运行你想要运行的代码。Python的解释器会运行它们，并且在运行中导入它所需的库和其它东西。C是完全不同的东西，你需要事先编译你的源文件，并且手动将它们整合为一个可以自己运行的二进制文件。手动来做这些事情很痛苦，在上一个练习中只需要运行make就能完成。\n这个练习是GNU make 的速成课，由于你在学C语言，所以你就必须掌握它。Make 将贯穿剩下的课程，等效于Python（命令）。它会构建源码，执行测试，设置一些选项以及为你做所有Python通常会做的事情。\n有所不同的是，我会向你展示一些更智能化的Makefile魔法，你不需要指出你的C程序的每一个愚蠢的细节来构建它。我不会在练习中那样做，但是你需要先用一段时间的“低级 make”，我才能向你演示“大师级的make”。\n使用 Make link使用make的第一阶段就是用它已知的方式来构建程序。Make预置了一些知识，来从其它文件构建多种文件。上一个练习中，你已经使用像下面的命令来这样做了：\n$ make ex1 $ CFLAGS=\"-Wall\" make ex1 第一个命令中你告诉make，“我想创建名为ex1的文件”。于是Make执行下面的动作：\n文件ex1存在吗？ 没有。好的，有没有其他文件以ex1开头？ 有，叫做ex1.c。我知道如何构建.c文件吗？ 是的，我会运行命令cc ex1.c -o ex1来构建它。 我将使用cc从ex1.c文件来为你构建ex1。 上面列出的第二条命令是一种向make命令传递“修改器”的途径。如果你不熟悉Unix shell如何工作，你可以创建这些“环境变量”，它们会在程序运行时生效。有时你会用一条类似于export CFLAGS=\"-Wall\"的命令来执行相同的事情，取决于你所用的shell。然而你可以仅仅把它们放到你想执行的命令前面，于是环境变量只会在程序运行时有效。\n在这个例子中我执行了CFLAGS=\"-Wall\" make ex1，所以它会给make通常使用的cc命令添加-Wall选项。这行命令告诉cc编译器要报告所有的警告（然而实际上不可能报告所有警告）。\n实际上你可以深入探索使用make的上述方法，但是先让我们来看看Makefile，以便让你对make了解得更多一点。首先，创建文件并写入以下内容：\nCFLAGS=-Wall -g clean: rm -f ex1 将文件在你的当前文件夹上保存为Makefile。Make会自动假设当前文件夹中有一个叫做Makefile的文件，并且会执行它。此外，一定要注意：确保你只输入了 TAB 字符，而不是空格和 TAB 的混合。\n译者注：上述代码中第四行rm前面是一个 TAB ，而不是多个等量的空格。\nMakefile向你展示了make的一些新功能。首先我们在文件中设置CFLAGS，所以之后就不用再设置了。并且，我们添加了-g标识来获取调试信息。接着我们写了一个叫做clean的部分，它告诉make如何清理我们的小项目。\n确保它和你的ex1.c文件在相同的目录中，之后运行以下命令：\n$ make clean $ make ex1 你会看到什么 link如果代码能正常工作，你应该看到这些：\n$ make clean rm -f ex1 $ make ex1 cc -Wall -g ex1.",
                content: " 原文：Exercise 2: Make Is Your Python Now\n译者：飞龙\n在Python中，你仅仅需要输入python，就可以运行你想要运行的代码。Python的解释器会运行它们，并且在运行中导入它所需的库和其它东西。C是完全不同的东西，你需要事先编译你的源文件，并且手动将它们整合为一个可以自己运行的二进制文件。手动来做这些事情很痛苦，在上一个练习中只需要运行make就能完成。\n这个练习是GNU make 的速成课，由于你在学C语言，所以你就必须掌握它。Make 将贯穿剩下的课程，等效于Python（命令）。它会构建源码，执行测试，设置一些选项以及为你做所有Python通常会做的事情。\n有所不同的是，我会向你展示一些更智能化的Makefile魔法，你不需要指出你的C程序的每一个愚蠢的细节来构建它。我不会在练习中那样做，但是你需要先用一段时间的“低级 make”，我才能向你演示“大师级的make”。\n使用 Make link使用make的第一阶段就是用它已知的方式来构建程序。Make预置了一些知识，来从其它文件构建多种文件。上一个练习中，你已经使用像下面的命令来这样做了：\n$ make ex1 $ CFLAGS=\"-Wall\" make ex1 第一个命令中你告诉make，“我想创建名为ex1的文件”。于是Make执行下面的动作：\n文件ex1存在吗？ 没有。好的，有没有其他文件以ex1开头？ 有，叫做ex1.c。我知道如何构建.c文件吗？ 是的，我会运行命令cc ex1.c -o ex1来构建它。 我将使用cc从ex1.c文件来为你构建ex1。 上面列出的第二条命令是一种向make命令传递“修改器”的途径。如果你不熟悉Unix shell如何工作，你可以创建这些“环境变量”，它们会在程序运行时生效。有时你会用一条类似于export CFLAGS=\"-Wall\"的命令来执行相同的事情，取决于你所用的shell。然而你可以仅仅把它们放到你想执行的命令前面，于是环境变量只会在程序运行时有效。\n在这个例子中我执行了CFLAGS=\"-Wall\" make ex1，所以它会给make通常使用的cc命令添加-Wall选项。这行命令告诉cc编译器要报告所有的警告（然而实际上不可能报告所有警告）。\n实际上你可以深入探索使用make的上述方法，但是先让我们来看看Makefile，以便让你对make了解得更多一点。首先，创建文件并写入以下内容：\nCFLAGS=-Wall -g clean: rm -f ex1 将文件在你的当前文件夹上保存为Makefile。Make会自动假设当前文件夹中有一个叫做Makefile的文件，并且会执行它。此外，一定要注意：确保你只输入了 TAB 字符，而不是空格和 TAB 的混合。\n译者注：上述代码中第四行rm前面是一个 TAB ，而不是多个等量的空格。\nMakefile向你展示了make的一些新功能。首先我们在文件中设置CFLAGS，所以之后就不用再设置了。并且，我们添加了-g标识来获取调试信息。接着我们写了一个叫做clean的部分，它告诉make如何清理我们的小项目。\n确保它和你的ex1.c文件在相同的目录中，之后运行以下命令：\n$ make clean $ make ex1 你会看到什么 link如果代码能正常工作，你应该看到这些：\n$ make clean rm -f ex1 $ make ex1 cc -Wall -g ex1.c -o ex1 ex1.c: In function 'main': ex1.c:3: warning: implicit declaration of function 'puts' $ 你可以看出来我执行了make clean，它告诉make执行我们的clean目标。再去看一眼Makefile，之后你会看到在它的下面，我缩进并且输入了一些想要make为我运行的shell命令。你可以在此处输入任意多的命令，所以它是一个非常棒的自动化工具。\n注\n如果你修改了ex1.c，添加了#include，输出中的关于puts的警告就会消失（这其实应该算作一个错误）。我这里有警告是因为我并没有去掉它。\n同时也要注意，即使我们在Makefile中并没有提到ex1，make仍然会知道如何构建它，以及使用我们指定的设置。\n如何使它崩溃 link上面那些已经足够让你起步了，但是让我们以一种特定的方式来破坏make文件，以便你可以看到发生了什么。找到rm -f ex1的那一行并去掉缩进（让它左移），之后你可以看到发生了什么。再次运行make clean，你就会得到下面的信息：\n$ make clean Makefile:4: *** missing separator. Stop. 永远记住要缩进，以及如果你得到了像这种奇奇怪怪的错误，应该复查你是否都使用了 TAB 字符，由于一些make的变种十分挑剔。\n附加题 link 创建目标all:ex1，可以以单个命令make构建ex1。 阅读man make来了解关于如何执行它的更多信息。 阅读man cc来了解关于-Wall和-g行为的更多信息。 在互联网上搜索Makefile文件，看看你是否能改进你的文件。 在另一个C语言项目中找到Makefile文件，并且尝试理解它做了什么。 "
            }
        );
    index.add(
            {
                id:  13 ,
                href: "\/TechDocs\/docs\/c-guide\/ex3\/",
                title: "练习3：格式化输出",
                description: "原文：Exercise 3: Formatted Printing 译者：飞龙 不要删除Makefile，因为它可以帮你指出错误，以及当我们需要自动化处理一些事情时，可以向它添加新的东西。 许多编程语言都使用了C风格的格式化输出，所以让我们尝试一下： #include int main() { int age = 10; int height = 72; printf(\"I am %d years old.\\n\", age); printf(\"I am %d inches tall.\\n\", height); return 0; } 写完之后，执行通常的make ex3命令来构建并运行它。一定要确保你处理了所有的警告。 这个练习的代码量很小，但是信息量很大，所以让我们逐行分析一下： 首先你包含了另一个头文件叫做stdio.h。这告诉了编译器你要使用“标准的输入/输出函数”。它们之一就是printf。 然后你使用了一个叫age的变量并且将它设置为10。 接着你使用了一个叫height的变量并且设置为72。 再然后你使用printf函数来打印这个星球上最高的十岁的人的年龄和高度。 在printf中你会注意到你传入了一个字符串，这就是格式字符串，和其它语言中一样。 在格式字符串之后，你传入了一些变量，它们应该被printf“替换”进格式字符串中。 这些语句的结果就是你用printf处理了一些变量，并且它会构造出一个新的字符串，之后将它打印在终端上。 你会看到什么 link当你做完上面的整个步骤，你应该看到这些东西： $ make ex3 cc -Wall -g ex3.c -o ex3 $ ./ex3 I am 10 years old. I am 72 inches tall. $ 不久之后我会停下来让你运行make，并且告诉你构建过程是什么样子的。所以请确保你正确得到了这些信息并且能正常执行。",
                content: " 原文：Exercise 3: Formatted Printing\n译者：飞龙\n不要删除Makefile，因为它可以帮你指出错误，以及当我们需要自动化处理一些事情时，可以向它添加新的东西。\n许多编程语言都使用了C风格的格式化输出，所以让我们尝试一下：\n#include int main() { int age = 10; int height = 72; printf(\"I am %d years old.\\n\", age); printf(\"I am %d inches tall.\\n\", height); return 0; } 写完之后，执行通常的make ex3命令来构建并运行它。一定要确保你处理了所有的警告。\n这个练习的代码量很小，但是信息量很大，所以让我们逐行分析一下：\n首先你包含了另一个头文件叫做stdio.h。这告诉了编译器你要使用“标准的输入/输出函数”。它们之一就是printf。 然后你使用了一个叫age的变量并且将它设置为10。 接着你使用了一个叫height的变量并且设置为72。 再然后你使用printf函数来打印这个星球上最高的十岁的人的年龄和高度。 在printf中你会注意到你传入了一个字符串，这就是格式字符串，和其它语言中一样。 在格式字符串之后，你传入了一些变量，它们应该被printf“替换”进格式字符串中。 这些语句的结果就是你用printf处理了一些变量，并且它会构造出一个新的字符串，之后将它打印在终端上。\n你会看到什么 link当你做完上面的整个步骤，你应该看到这些东西：\n$ make ex3 cc -Wall -g ex3.c -o ex3 $ ./ex3 I am 10 years old. I am 72 inches tall. $ 不久之后我会停下来让你运行make，并且告诉你构建过程是什么样子的。所以请确保你正确得到了这些信息并且能正常执行。\n外部研究 link在附加题一节我可能会让你自己查找一些资料，并且弄明白它们。这对于一个自我学习的程序员来说相当重要。如果你一直在自己尝试了解问题之前去问其它人，你永远都不会学到独立解决问题。这会让你永远都不会在自己的技能上建立信心，并且总是依赖别人去完成你的工作。\n打破你这一习惯的方法就是强迫你自己先试着自己回答问题，并且确认你的回答是正确的。你可以通过打破一些事情，用实验验证可能的答案，以及自己进行研究来完成它。\n对于这个练习，我想让你上网搜索printf的所有格式化占位符和转义序列。转义序列类似\\n或者\\r，可以让你分别打印新的一行或者 tab 。格式化占位符类似%s或者%d，可以让你打印字符串或整数。找到所有的这些东西，以及如何修改它们，和可设置的“精度”和宽度的种类。\n从现在开始，这些任务会放到附加题里面，你应该去完成它们。\n如何使它崩溃 link尝试下面的一些东西来使你的程序崩溃，在你的电脑上它们可能会崩溃，也可能不会。\n从第一个printf中去掉age并重新编译，你应该会得到一大串的警告。 运行新的程序，它会崩溃，或者打印出奇怪的年龄。 将printf恢复原样，并且去掉age的初值，将那一行改为int age;，之后重新构建并运行。 $ make ex3 cc -Wall -g ex3.c -o ex3 ex3.c: In function 'main': ex3.c:8: warning: too few arguments for format ex3.c:5: warning: unused variable 'age' $ ./ex3 I am -919092456 years old. I am 72 inches tall. $ make ex3 cc -Wall -g ex3.c -o ex3 ex3.c: In function 'main': ex3.c:8: warning: 'age' is used uninitialized in this function $ ./ex3 I am 0 years old. I am 72 inches tall. $ 附加题 link 找到尽可能多的方法使ex3崩溃。 执行man 3 printf来阅读其它可用的’%‘格式化占位符。如果你在其它语言中使用过它们，应该看着非常熟悉（它们来源于printf）。 将ex3添加到你的Makefile的all列表中。到目前为止，可以使用make clean all来构建你所有的练习。 将ex3添加到你的Makefile的clean列表中。当你需要的时候使用make clean可以删除它。 "
            }
        );
    index.add(
            {
                id:  14 ,
                href: "\/TechDocs\/docs\/c-guide\/ex4\/",
                title: "练习4：Valgrind 介绍",
                description: "原文：Exercise 4: Introducing Valgrind 译者：飞龙 现在是介绍另一个工具的时间了，在你学习C的过程中，你会时时刻刻用到它，它就是 Valgrind。我现在就向你介绍 Valgrind，是因为从现在开始你将会在“如何使它崩溃”一节中用到它。Valgrind是一个运行你的程序的程序，并且随后会报告所有你犯下的可怕错误。它是一款相当棒的自由软件，我在编写C代码时一直使用它。 回忆一下在上一章中，我让你移除printf的一个参数，来使你的代码崩溃。它打印出了一些奇怪的结果，但我并没有告诉你为什么它会这样打印。这个练习中我们要使用Valgrind来搞清楚为什么。 注 这本书的前几章讲解了一小段代码，同时掺杂了一些必要的工具，它们在本书的剩余章节会用到。这样做的原因是，阅读这本书的大多数人都不熟悉编译语言，也必然不熟悉自动化的辅助工具。通过先让你懂得如何使用make和Valgrind，我可以在后面使用它们更快地教你C语言，以及帮助你尽早找出所有的bug。 这一章之后我就不再介绍更多的工具了，每章的内容大部分是代码，以及少量的语法。然而，我也会提及少量工具，我们可以用它来真正了解发生了什么，以及更好地了解常见的错误和问题。 安装 Valgrind link你可以用OS上的包管理器来安装Valgrind，但是我想让你学习如何从源码安装程序。这涉及到下面几个步骤： 下载源码的归档文件来获得源码 解压归档文件，将文件提取到你的电脑上 运行./configure来建立构建所需的配置 运行make来构建源码，就像之前所做的那样 运行sudo make install来将它安装到你的电脑 下面是执行以上步骤的脚本，我想让你复制它： curl -O http://valgrind.org/downloads/valgrind-3.6.1.tar.bz2 md5sum valgrind-3.6.1.tar.bz2 tar -xjvf valgrind-3.6.1.tar.bz2 cd valgrind-3.6.1 ./configure make sudo make install 按照这份脚本，但是如果 Valgrind 有新的版本请更新它。如果它不能正常执行，也请试着深入研究原因。 使用 Valgrind link使用 Valgrind 十分简单，只要执行valgrind theprogram，它就会运行你的程序，随后打印出你的程序运行时出现的所有错误。在这个练习中，我们会崩溃在一个错误输出上，然后会修复它。 首先，这里有一个ex3.c的故意出错的版本，叫做ex4.c。出于练习目的，将它再次输入到文件中： #include /* Warning: This program is wrong on purpose. */ int main() { int age = 10; int height; printf(\"I am %d years old.",
                content: " 原文：Exercise 4: Introducing Valgrind\n译者：飞龙\n现在是介绍另一个工具的时间了，在你学习C的过程中，你会时时刻刻用到它，它就是 Valgrind。我现在就向你介绍 Valgrind，是因为从现在开始你将会在“如何使它崩溃”一节中用到它。Valgrind是一个运行你的程序的程序，并且随后会报告所有你犯下的可怕错误。它是一款相当棒的自由软件，我在编写C代码时一直使用它。\n回忆一下在上一章中，我让你移除printf的一个参数，来使你的代码崩溃。它打印出了一些奇怪的结果，但我并没有告诉你为什么它会这样打印。这个练习中我们要使用Valgrind来搞清楚为什么。\n注\n这本书的前几章讲解了一小段代码，同时掺杂了一些必要的工具，它们在本书的剩余章节会用到。这样做的原因是，阅读这本书的大多数人都不熟悉编译语言，也必然不熟悉自动化的辅助工具。通过先让你懂得如何使用make和Valgrind，我可以在后面使用它们更快地教你C语言，以及帮助你尽早找出所有的bug。\n这一章之后我就不再介绍更多的工具了，每章的内容大部分是代码，以及少量的语法。然而，我也会提及少量工具，我们可以用它来真正了解发生了什么，以及更好地了解常见的错误和问题。\n安装 Valgrind link你可以用OS上的包管理器来安装Valgrind，但是我想让你学习如何从源码安装程序。这涉及到下面几个步骤：\n下载源码的归档文件来获得源码 解压归档文件，将文件提取到你的电脑上 运行./configure来建立构建所需的配置 运行make来构建源码，就像之前所做的那样 运行sudo make install来将它安装到你的电脑 下面是执行以上步骤的脚本，我想让你复制它：\ncurl -O http://valgrind.org/downloads/valgrind-3.6.1.tar.bz2 md5sum valgrind-3.6.1.tar.bz2 tar -xjvf valgrind-3.6.1.tar.bz2 cd valgrind-3.6.1 ./configure make sudo make install 按照这份脚本，但是如果 Valgrind 有新的版本请更新它。如果它不能正常执行，也请试着深入研究原因。\n使用 Valgrind link使用 Valgrind 十分简单，只要执行valgrind theprogram，它就会运行你的程序，随后打印出你的程序运行时出现的所有错误。在这个练习中，我们会崩溃在一个错误输出上，然后会修复它。\n首先，这里有一个ex3.c的故意出错的版本，叫做ex4.c。出于练习目的，将它再次输入到文件中：\n#include /* Warning: This program is wrong on purpose. */ int main() { int age = 10; int height; printf(\"I am %d years old.\\n\"); printf(\"I am %d inches tall.\\n\", height); return 0; } 你会发现，除了两个经典的错误外，其余部分都相同：\n没有初始化height变量 没有将age变量传入第一个printf函数 你会看到什么 link现在我们像通常一样构建它，但是不要直接运行，而是使用Valgrind来运行它（见源码：“使用Valgrind构建并运行 ex4.c”）：\n$ make ex4 cc -Wall -g ex4.c -o ex4 ex4.c: In function 'main': ex4.c:10: warning: too few arguments for format ex4.c:7: warning: unused variable 'age' ex4.c:11: warning: 'height' is used uninitialized in this function $ valgrind ./ex4 ==3082== Memcheck, a memory error detector ==3082== Copyright (C) 2002-2010, and GNU GPL'd, by Julian Seward et al. ==3082== Using Valgrind-3.6.0.SVN-Debian and LibVEX; rerun with -h for copyright info ==3082== Command: ./ex4 ==3082== I am -16775432 years old. ==3082== Use of uninitialised value of size 8 ==3082== at 0x4E730EB: _itoa_word (_itoa.c:195) ==3082== by 0x4E743D8: vfprintf (vfprintf.c:1613) ==3082== by 0x4E7E6F9: printf (printf.c:35) ==3082== by 0x40052B: main (ex4.c:11) ==3082== ==3082== Conditional jump or move depends on uninitialised value(s) ==3082== at 0x4E730F5: _itoa_word (_itoa.c:195) ==3082== by 0x4E743D8: vfprintf (vfprintf.c:1613) ==3082== by 0x4E7E6F9: printf (printf.c:35) ==3082== by 0x40052B: main (ex4.c:11) ==3082== ==3082== Conditional jump or move depends on uninitialised value(s) ==3082== at 0x4E7633B: vfprintf (vfprintf.c:1613) ==3082== by 0x4E7E6F9: printf (printf.c:35) ==3082== by 0x40052B: main (ex4.c:11) ==3082== ==3082== Conditional jump or move depends on uninitialised value(s) ==3082== at 0x4E744C6: vfprintf (vfprintf.c:1613) ==3082== by 0x4E7E6F9: printf (printf.c:35) ==3082== by 0x40052B: main (ex4.c:11) ==3082== I am 0 inches tall. ==3082== ==3082== HEAP SUMMARY: ==3082== in use at exit: 0 bytes in 0 blocks ==3082== total heap usage: 0 allocs, 0 frees, 0 bytes allocated ==3082== ==3082== All heap blocks were freed -- no leaks are possible ==3082== ==3082== For counts of detected and suppressed errors, rerun with: -v ==3082== Use --track-origins=yes to see where uninitialised values come from ==3082== ERROR SUMMARY: 4 errors from 4 contexts (suppressed: 4 from 4) $ 注\n如果你运行了Valgrind，它显示一些类似于by 0x4052112: (below main) (libc-start.c:226)的东西，而不是main.c中的行号，你需要使用valgrind --track-origins=yes ./ex4命令来运行你的Valgrind。由于某些原因，valgrind的Debian和Ubuntu上的版本会这样，但是其它的不会。\n上面那段输出非常长，因为Valgrind在明确地告诉你程序中的每个错误都在哪儿。让我们从开头逐行分析一下（行号在左边，你可以参照）：\n1\n你执行了通常的make ex4来构建它。确保你看到的cc命令和它一样，并且带有-g选项，否则Valgrind的输出不会带上行号。\n2~6\n要注意编译器也会向你报告源码的错误，它警告你“向格式化函数传入了过少的变量”，因为你忘记包含age变量。\n7\n然后使用valgrind ./ex4来运行程序。\n8\n之后Valgrind变得十分奇怪，并向你报错：\n14~18\n在main (ex4.c:11)（意思是文件ex4.c的main函数的第11行）的那行中，有“大小为8的未初始化的值”。你通过查看错误找到了它，并且在它下面看到了“栈踪迹”。最开始看到的那行(ex4.c:11)在最下面，如果你不明白哪里出错了，你可以向上看，比如printf.c:35。通常最下面的一行最重要（这个例子中是第18行）。\n20~24\n下一个错误位于 main 函数中的 ex4.c:11。Valgrind不喜欢这一行，它说的是一些 if 语句或者 while 循环基于一个未初始化的值，在这个例子中是height。\n25~35\n剩下的错误都大同小异，因为这个值还在继续使用。\n37~46\n最后程序退出了，Valgrind显示出一份摘要，告诉你程序有多烂。\n这段信息读起来会相当多，下面是你的处理方法：\n无论什么时候你运行C程序并且使它工作，都应该使用Valgrind重新运行它来检查。 对于得到的每个错误，找到“源码:行数”提示的位置，然后修复它。你可以上网搜索错误信息，来弄清楚它的意思。 一旦你的程序在Valgrind下不出现任何错误信息，应该就好了。你可能学会了如何编写代码的一些技巧。 在这个练习中我并不期待你马上完全掌握Valgrind，但是你应该安装并且学会如何快速使用它，以便我们将它用于后面的练习。\n附加题 link 按照上面的指导，使用Valgrind和编译器修复这个程序。 在互联网上查询Valgrind相关的资料。 下载另一个程序并手动构建它。尝试一些你已经使用，但从来没有手动构建的程序。 看看Valgrind的源码是如何在目录下组织的，并且阅读它的Makefile文件。不要担心，这对我来说没有任何意义。 "
            }
        );
    index.add(
            {
                id:  15 ,
                href: "\/TechDocs\/docs\/c-guide\/ex5\/",
                title: "练习5：一个C程序的结构",
                description: "原文：Exercise 5: The Structure Of A C Program 译者：飞龙 你已经知道了如何使用printf，也有了可以随意使用的一些工具，现在让我们逐行分析一个简单的C程序，以便你了解它是如何组织的。在这个程序里你会编写一些不是很熟悉的东西，我会轻松地把它们拆开。之后在后面的几章我们将会处理这些概念。 #include /* This is a comment. */ int main(int argc, char *argv[]) { int distance = 100; // this is also a comment printf(\"You are %d miles away.\\n\", distance); return 0; } 手动输入这段代码并运行它，之后确保在Valgrind下不出现任何错误。你可能不会这样做，但你得习惯它。 你会看到什么 link这真是一段无聊的输出，但是这个练习的目的是让你分析代码： $ make ex5 cc -Wall -g ex5.c -o ex5 $ ./ex5 You are 100 miles away. $ 分解代码 link当你输出这段代码时，可能你只弄清楚了这段代码中的一小部分C语言特性。让我们快速地逐行分解它，之后我们可以做一些练习来更好地了解每一部分： ex5.c:1 这是一个include，它是将一个文件的内容导入到这个文件的方式。C具有使用.h扩展名作为头文件的惯例。头文件中拥有一些函数的列表，这些都是你想在程序中使用的函数。 ex5.c:3 这是多行注释，你可以在/*和*/之间放置任意多行。",
                content: " 原文：Exercise 5: The Structure Of A C Program\n译者：飞龙\n你已经知道了如何使用printf，也有了可以随意使用的一些工具，现在让我们逐行分析一个简单的C程序，以便你了解它是如何组织的。在这个程序里你会编写一些不是很熟悉的东西，我会轻松地把它们拆开。之后在后面的几章我们将会处理这些概念。\n#include /* This is a comment. */ int main(int argc, char *argv[]) { int distance = 100; // this is also a comment printf(\"You are %d miles away.\\n\", distance); return 0; } 手动输入这段代码并运行它，之后确保在Valgrind下不出现任何错误。你可能不会这样做，但你得习惯它。\n你会看到什么 link这真是一段无聊的输出，但是这个练习的目的是让你分析代码：\n$ make ex5 cc -Wall -g ex5.c -o ex5 $ ./ex5 You are 100 miles away. $ 分解代码 link当你输出这段代码时，可能你只弄清楚了这段代码中的一小部分C语言特性。让我们快速地逐行分解它，之后我们可以做一些练习来更好地了解每一部分：\nex5.c:1\n这是一个include，它是将一个文件的内容导入到这个文件的方式。C具有使用.h扩展名作为头文件的惯例。头文件中拥有一些函数的列表，这些都是你想在程序中使用的函数。\nex5.c:3\n这是多行注释，你可以在/*和*/之间放置任意多行。\nex5.c:4\n这是一个你遇到的更复杂的 main 函数。操作系统加载完你的程序，之后会运行叫做main的函数，这是C程序的工作方式。这个函数只需要返回int，并接受两个参数，一个是int作为命令行参数的数量，另一个是char*字符串的数组作为命令行参数。这是不是让人难以理解？不用担心，我们稍后会讲解它。\nex5.c:5\n任何函数都以{字符开始，它表示“程序块”的开始。在Python中用一个:来表示。在其它语言中，可能需要用begin或者do来表示。\nex5.c:6\n一个变量的声明和同时的赋值。你可以使用语法type name = value;来创建变量。在C的语句中，除了逻辑语句，都以一个;（分号）来结尾。\nex5.c:8\n注释的另一种形式，它就像Python或Ruby的注释。它以//开头，直到行末结束。\nex5.c:9\n调用了我们的老朋友printf。就像许多语言中的函数调用，使用语法name(arg1, arg2);。函数可以不带任何参数，也可以拥有任何数量的参数。printf函数是一类特别的函数，可以带可变数量的参数。我们会在之后说明。\nex5.c:11\n一个main函数的返回语句，它会向OS提供退出值。你可能不熟悉Unix软件的返回代码，所以这个也放到后面去讲。\nex5.c:12\n最后，我们以一个闭合的}花括号来结束了main函数。它就是整个程序的结尾了。\n在这次分解中有大量的信息，所以你应该逐行来学习，并且确保至少掌握了背后发生了什么。你不一定了解所有东西，但是在我们继续之前，你可以猜猜它们的意思。\n附加题 link 对于每一行，写出你不理解的符号，并且看看是否能猜出它们的意思。在纸上写下你的猜测，你可以在以后检查它，看看是否正确。 回头去看之前几个练习的源代码，并且像这样分解代码，来看看你是否了解它们。写下你不了解和不能自己解释的东西。 "
            }
        );
    index.add(
            {
                id:  16 ,
                href: "\/TechDocs\/docs\/c-guide\/ex6\/",
                title: "练习6：变量类型",
                description: "原文：Exercise 6: Types Of Variables 译者：飞龙 你应该掌握了一个简单的C程序的结构，所以让我们执行下一步简单的操作，声明不同类型的变量。 include int main(int argc, char *argv[]) { int distance = 100; float power = 2.345f; double super_power = 56789.4532; char initial = 'A'; char first_name[] = \"Zed\"; char last_name[] = \"Shaw\"; printf(\"You are %d miles away.\\n\", distance); printf(\"You have %f levels of power.\\n\", power); printf(\"You have %f awesome super powers.\\n\", super_power); printf(\"I have an initial %c.\\n\", initial); printf(\"I have a first name %s.",
                content: " 原文：Exercise 6: Types Of Variables\n译者：飞龙\n你应该掌握了一个简单的C程序的结构，所以让我们执行下一步简单的操作，声明不同类型的变量。\ninclude int main(int argc, char *argv[]) { int distance = 100; float power = 2.345f; double super_power = 56789.4532; char initial = 'A'; char first_name[] = \"Zed\"; char last_name[] = \"Shaw\"; printf(\"You are %d miles away.\\n\", distance); printf(\"You have %f levels of power.\\n\", power); printf(\"You have %f awesome super powers.\\n\", super_power); printf(\"I have an initial %c.\\n\", initial); printf(\"I have a first name %s.\\n\", first_name); printf(\"I have a last name %s.\\n\", last_name); printf(\"My whole name is %s %c. %s.\\n\", first_name, initial, last_name); return 0; } 在这个程序中我们声明了不同类型的变量，并且使用了不同的printf格式化字符串来打印它们。\n你会看到什么 link你的输出应该和我的类似，你可以看到C的格式化字符串相似于Python或其它语言，很长一段时间中都是这样。\n$ make ex6 cc -Wall -g ex6.c -o ex6 $ ./ex6 You are 100 miles away. You have 2.345000 levels of power. You have 56789.453200 awesome super powers. I have an initial A. I have a first name Zed. I have a last name Shaw. My whole name is Zed A. Shaw. $ 你可以看到我们拥有一系列的“类型”，它们告诉编译器变量应该表示成什么，之后格式化字符串会匹配不同的类型。下面解释了它们如何匹配：\n整数\n使用int声明，使用%d来打印。\n浮点\n使用float或double声明，使用%f来打印。\n字符\n使用char来声明，以周围带有'（单引号）的单个字符来表示，使用%c来打印。\n字符串（字符数组）\n使用char name[]来声明，以周围带有\"的一些字符来表示，使用%s来打印。\n你会注意到C语言中区分单引号的char和双引号的char[]或字符串。\n注\n当我提及C语言类型时，我通常会使用char[]来代替整个的char SOMENAME[]。这不是有效的C语言代码，只是一个用于讨论类型的一个简化表达方式。\n如何使它崩溃 link你可以通过向printf传递错误的参数来轻易使这个程序崩溃。例如，如果你找到打印我的名字的那行，把initial放到first_name前面，你就制造了一个bug。执行上述修改编译器就会向你报错，之后运行的时候你可能会得到一个“段错误”，就像这样：\n$ make ex6 cc -Wall -g ex6.c -o ex6 ex6.c: In function 'main': ex6.c:19: warning: format '%s' expects type 'char *', but argument 2 has type 'int' ex6.c:19: warning: format '%c' expects type 'int', but argument 3 has type 'char *' $ ./ex6 You are 100 miles away. You have 2.345000 levels of power. You have 56789.453125 awesome super powers. I have an initial A. I have a first name Zed. I have a last name Shaw. Segmentation fault $ 在Valgrind下运行修改后的程序，来观察它会告诉你什么关于错误“Invalid read of size 1”的事情。\n附加题 link 寻找其他通过修改printf使这段C代码崩溃的方法。 搜索“printf格式化”，试着使用一些高级的占位符。 研究可以用几种方法打印数字。尝试以八进制或十六进制打印，或者其它你找到的方法。 试着打印空字符串，即\"\"。 "
            }
        );
    index.add(
            {
                id:  17 ,
                href: "\/TechDocs\/docs\/c-guide\/ex7\/",
                title: "练习7：更多变量和一些算术",
                description: "原文：Exercise 7: More Variables, Some Math\n译者：飞龙\n你可以通过声明int，float，char和double类型的变量，来对它们做更多的事情，让我们来熟悉它们吧。接下来我们会在各种数学表达式中使用它们，所以我会向你介绍C的基本算术操作。\nint main(int argc, char *argv[]) { int bugs = 100; double bug_rate = 1.2; printf(\"You have %d bugs at the imaginary rate of %f.\\n\", bugs, bug_rate); long universe_of_defects = 1L * 1024L * 1024L * 1024L; printf(\"The entire universe has %ld bugs.\\n\", universe_of_defects); double expected_bugs = bugs * bug_rate; printf(\"You are expected to have %f bugs.\\n\", expected_bugs); double part_of_universe = expected_bugs / universe_of_defects; printf(\"That is only a %e portion of the universe.",
                content: " 原文：Exercise 7: More Variables, Some Math\n译者：飞龙\n你可以通过声明int，float，char和double类型的变量，来对它们做更多的事情，让我们来熟悉它们吧。接下来我们会在各种数学表达式中使用它们，所以我会向你介绍C的基本算术操作。\nint main(int argc, char *argv[]) { int bugs = 100; double bug_rate = 1.2; printf(\"You have %d bugs at the imaginary rate of %f.\\n\", bugs, bug_rate); long universe_of_defects = 1L * 1024L * 1024L * 1024L; printf(\"The entire universe has %ld bugs.\\n\", universe_of_defects); double expected_bugs = bugs * bug_rate; printf(\"You are expected to have %f bugs.\\n\", expected_bugs); double part_of_universe = expected_bugs / universe_of_defects; printf(\"That is only a %e portion of the universe.\\n\", part_of_universe); // this makes no sense, just a demo of something weird char nul_byte = '\\0'; int care_percentage = bugs * nul_byte; printf(\"Which means you should care %d%%.\\n\", care_percentage); return 0; } 下面是这一小段无意义代码背后发生的事情：\nex7.c:1-4\nC程序的通常开始。\nex7.c:5-6\n为一些伪造的bug数据声明了一个int和一个double变量。\nex7.c:8-9\n打印这两个变量，没有什么新东西。\nex7.c:11\n使用了一个新的类型long来声明一个大的数值，它可以储存比较大的数。\nex7.c:12-13\n使用%ld打印出这个变量，我们添加了个修饰符到%d上面。添加的\"l\"表示将它当作长整形打印。\nex7.c:15-17\n只是更多的算术运算和打印。\nex7.c:19-21\n编撰了一段你的bug率的描述，这里的计算非常不精确。结果非常小，所以我们要使用%e以科学记数法的形式打印它。\nex7.c:24\n以特殊的语法'\\0'声明了一个字符。这样创建了一个“空字节”字符，实际上是数字0。\nex7.c:25\n使用这个字符乘上bug的数量，它产生了0，作为“有多少是你需要关心的”的结果。这条语句展示了你有时会碰到的丑陋做法。\nex7.c:26-27\n将它打印出来，注意我使用了%%（两个百分号）来打印一个%字符。\nex7.c:28-30\nmain函数的结尾。\n这一段代码只是个练习，它演示了许多算术运算。在最后，它也展示了许多你能在C中看到，但是其它语言中没有的技巧。对于C来说，一个“字符”同时也是一个整数，虽然它很小，但的确如此。这意味着你可以对它做算术运算，无论是好是坏，许多软件中也是这样做的。\n在最后一部分中，你第一次见到C语言是如何直接访问机器的。我们会在后面的章节中深入。\n你会看到什么 link通常，你应该看到如下输出：\n$ make ex7 cc -Wall -g ex7.c -o ex7 $ ./ex7 You have 100 bugs at the imaginary rate of 1.200000. The entire universe has 1073741824 bugs. You are expected to have 120.000000 bugs. That is only a 1.117587e-07 portion of the universe. Which means you should care 0%. $ 如何使它崩溃 link像之前一样，向printf传入错误的参数来使它崩溃。对比%c，看看当你使用%s来打印nul_byte变量时会发生什么。做完这些之后，在Valgrind下运行它看看关于你的这次尝试会输出什么。\n附加题 link 把为universe_of_defects赋值的数改为不同的大小，观察编译器的警告。 这些巨大的数字实际上打印成了什么？ 将long改为unsigned long，并试着找到对它来说太大的数字。 上网搜索unsigned做了什么。 试着自己解释（在下个练习之前）为什么char可以和int相乘。 "
            }
        );
    index.add(
            {
                id:  18 ,
                href: "\/TechDocs\/docs\/c-guide\/ex8\/",
                title: "练习8：大小和数组",
                description: "原文：Exercise 8: Sizes And Arrays 译者：飞龙 在上一个练习中你做了一些算术运算，并且使用了'\\0'（空）字符。这对于其它语言来说非常奇怪，因为它们把“字符串”和“字节数组”看做不同的东西。但是C中的字符串就是字节数组，并且只有不同的打印函数才知道它们的不同。 在我真正解释其重要性之前，我先要介绍一些概念：sizeof和数组。下面是我们将要讨论的一段代码： #include int main(int argc, char *argv[]) { int areas[] = {10, 12, 13, 14, 20}; char name[] = \"Zed\"; char full_name[] = { 'Z', 'e', 'd', ' ', 'A', '.', ' ', 'S', 'h', 'a', 'w', '\\0' }; // WARNING: On some systems you may have to change the // %ld in this code to a %u since it will use unsigned ints printf(\"The size of an int: %ld\\n\", sizeof(int)); printf(\"The size of areas (int[]): %ld\\n\", sizeof(areas)); printf(\"The number of ints in areas: %ld\\n\", sizeof(areas) / sizeof(int)); printf(\"The first area is %d, the 2nd %d.",
                content: " 原文：Exercise 8: Sizes And Arrays\n译者：飞龙\n在上一个练习中你做了一些算术运算，并且使用了'\\0'（空）字符。这对于其它语言来说非常奇怪，因为它们把“字符串”和“字节数组”看做不同的东西。但是C中的字符串就是字节数组，并且只有不同的打印函数才知道它们的不同。\n在我真正解释其重要性之前，我先要介绍一些概念：sizeof和数组。下面是我们将要讨论的一段代码：\n#include int main(int argc, char *argv[]) { int areas[] = {10, 12, 13, 14, 20}; char name[] = \"Zed\"; char full_name[] = { 'Z', 'e', 'd', ' ', 'A', '.', ' ', 'S', 'h', 'a', 'w', '\\0' }; // WARNING: On some systems you may have to change the // %ld in this code to a %u since it will use unsigned ints printf(\"The size of an int: %ld\\n\", sizeof(int)); printf(\"The size of areas (int[]): %ld\\n\", sizeof(areas)); printf(\"The number of ints in areas: %ld\\n\", sizeof(areas) / sizeof(int)); printf(\"The first area is %d, the 2nd %d.\\n\", areas[0], areas[1]); printf(\"The size of a char: %ld\\n\", sizeof(char)); printf(\"The size of name (char[]): %ld\\n\", sizeof(name)); printf(\"The number of chars: %ld\\n\", sizeof(name) / sizeof(char)); printf(\"The size of full_name (char[]): %ld\\n\", sizeof(full_name)); printf(\"The number of chars: %ld\\n\", sizeof(full_name) / sizeof(char)); printf(\"name=\\\"%s\\\" and full_name=\\\"%s\\\"\\n\", name, full_name); return 0; } 这段代码中我们创建了一些不同数据类型的数组。由于数组是C语言工作机制的核心，有大量的方法可以用来创建数组。我们暂且使用type name[] = {initializer};语法，之后我们会深入研究。这个语法的意思是，“我想要那个类型的数组并且初始化为{..}”。C语言看到它时，会做这些事情：\n查看它的类型，以第一个数组为例，它是int。 查看[]，看到了没有提供长度。 查看初始化表达式{10, 12, 13, 14, 20}，并且了解你想在数组中存放这5个整数。 在电脑中开辟出一块空间，可以依次存放这5个整数。 将数组命名为areas，也就是你想要的名字，并且在当前位置给元素赋值。 在areas的例子中，我们创建了一个含有5个整数的数组来存放那些数字。当它看到char name[] = \"Zed\";时，它会执行相同的步骤。我们先假设它创建了一个含有3个字符的数组，并且把字符赋值给name。我们创建的最后一个数组是full_name，但是我们用了一个比较麻烦的语法，每次用一个字符将其拼写出来。对C来说，name和full_name的方法都可以创建字符数组。\n在文件的剩余部分，我们使用了sizeof关键字来问C语言这些东西占多少个字节。C语言无非是内存块的大小和地址以及在上面执行的操作。它向你提供了sizeof便于你理解它们，所以你在使用一个东西之前可以先询问它占多少空间。\n这是比较麻烦的地方，所以我们先运行它，之后再解释。\n你会看到什么 link $ make ex8 cc -Wall -g ex8.c -o ex8 $ ./ex8 The size of an int: 4 The size of areas (int[]): 20 The number of ints in areas: 5 The first area is 10, the 2nd 12. The size of a char: 1 The size of name (char[]): 4 The number of chars: 4 The size of full_name (char[]): 12 The number of chars: 12 name=\"Zed\" and full_name=\"Zed A. Shaw\" $ 现在你可以看到这些不同printf调用的输出，并且瞥见C语言是如何工作的。你的输出实际上可能会跟我的完全不同，因为你电脑上的整数大小可能会不一样。下面我会过一遍我的输出：\n译者注：16位机器上的int是16位的，不过现在16位机很少见了吧。\n5\n我的电脑认为int的大小是4个字节。你的电脑上根据位数不同可能会使用不同的大小。\n6\nareas中含有5个整数，所以我的电脑自然就需要20个字节来储存它。\n7\n如果我们把areas的大小与int的大小相除，我们就会得到元素数量为5。这也符合我们在初始化语句中所写的东西。\n8\n接着我们访问了数组，读出areas[0]和areas[1]，这也意味着C语言的数组下标是0开头的，像Python和Ruby一样。\n9~11\n我们对name数组执行同样的操作，但是注意到数组的大小有些奇怪，它占4个字节，但是我们用了三个字符来打出\"Zed\"。那么第四个字符是哪儿来的呢？\n12~13\n我们对full_name数组执行了相同的操作，但它是正常的。\n13\n最后我们打印出name和full_name，根据printf证明它们实际上就是“字符串”。\n确保你理解了上面这些东西，并且知道这些输出对应哪些创建的变量。后面我们会在它的基础上探索更多关于数组和存储空间的事情。\n如何使它崩溃 link使这个程序崩溃非常容易，只需要尝试下面这些事情：\n将full_name最后的'\\0'去掉，并重新运行它，在valgrind下再运行一遍。现在将full_name的定义从main函数中移到它的上面，尝试在Valgrind下运行它来看看是否能得到一些新的错误。有些情况下，你会足够幸运，不会得到任何错误。 将areas[0]改为areas[10]并打印，来看看Valgrind会输出什么。 尝试上述操作的不同变式，也对name和full_name执行一遍。 附加题 link 尝试使用areas[0] = 100;以及相似的操作对areas的元素赋值。 尝试对name和full_name的元素赋值。 尝试将areas的一个元素赋值为name中的字符。 上网搜索在不同的CPU上整数所占的不同大小。 "
            }
        );
    index.add(
            {
                id:  19 ,
                href: "\/TechDocs\/docs\/c-guide\/ex9\/",
                title: "练习9：数组和字符串",
                description: "原文：Exercise 9: Arrays And Strings 译者：飞龙 上一个练习中，我们学习了如何创建基本的数组，以及数组如何映射为字符串。这个练习中我们会更加全面地展示数组和字符串的相似之处，并且深入了解更多内存布局的知识。 这个练习向你展示了C只是简单地将字符串储存为字符数组，并且在结尾加上'\\0'（空字符）。你可能在上个练习中得到了暗示，因为我们手动这样做了。下面我会通过将它与数字数组比较，用另一种方法更清楚地实现它。 #include int main(int argc, char *argv[]) { int numbers[4] = {0}; char name[4] = {'a'}; // first, print them out raw printf(\"numbers: %d %d %d %d\\n\", numbers[0], numbers[1], numbers[2], numbers[3]); printf(\"name each: %c %c %c %c\\n\", name[0], name[1], name[2], name[3]); printf(\"name: %s\\n\", name); // setup the numbers numbers[0] = 1; numbers[1] = 2; numbers[2] = 3; numbers[3] = 4; // setup the name name[0] = 'Z'; name[1] = 'e'; name[2] = 'd'; name[3] = '\\0'; // then print them out initialized printf(\"numbers: %d %d %d %d\\n\", numbers[0], numbers[1], numbers[2], numbers[3]); printf(\"name each: %c %c %c %c\\n\", name[0], name[1], name[2], name[3]); // print the name like a string printf(\"name: %s\\n\", name); // another way to use name char *another = \"Zed\"; printf(\"another: %s\\n\", another); printf(\"another each: %c %c %c %c\\n\", another[0], another[1], another[2], another[3]); return 0; } 在这段代码中，我们创建了一些数组，并对数组元素赋值。在numbers中我们设置了一些数字，然而在names中我们实际上手动构造了一个字符串。",
                content: " 原文：Exercise 9: Arrays And Strings\n译者：飞龙\n上一个练习中，我们学习了如何创建基本的数组，以及数组如何映射为字符串。这个练习中我们会更加全面地展示数组和字符串的相似之处，并且深入了解更多内存布局的知识。\n这个练习向你展示了C只是简单地将字符串储存为字符数组，并且在结尾加上'\\0'（空字符）。你可能在上个练习中得到了暗示，因为我们手动这样做了。下面我会通过将它与数字数组比较，用另一种方法更清楚地实现它。\n#include int main(int argc, char *argv[]) { int numbers[4] = {0}; char name[4] = {'a'}; // first, print them out raw printf(\"numbers: %d %d %d %d\\n\", numbers[0], numbers[1], numbers[2], numbers[3]); printf(\"name each: %c %c %c %c\\n\", name[0], name[1], name[2], name[3]); printf(\"name: %s\\n\", name); // setup the numbers numbers[0] = 1; numbers[1] = 2; numbers[2] = 3; numbers[3] = 4; // setup the name name[0] = 'Z'; name[1] = 'e'; name[2] = 'd'; name[3] = '\\0'; // then print them out initialized printf(\"numbers: %d %d %d %d\\n\", numbers[0], numbers[1], numbers[2], numbers[3]); printf(\"name each: %c %c %c %c\\n\", name[0], name[1], name[2], name[3]); // print the name like a string printf(\"name: %s\\n\", name); // another way to use name char *another = \"Zed\"; printf(\"another: %s\\n\", another); printf(\"another each: %c %c %c %c\\n\", another[0], another[1], another[2], another[3]); return 0; } 在这段代码中，我们创建了一些数组，并对数组元素赋值。在numbers中我们设置了一些数字，然而在names中我们实际上手动构造了一个字符串。\n你会看到什么 link当你运行这段代码的时候，你应该首先看到所打印的数组的内容初始化为0值，之后打印初始化后的内容：\n$ make ex9 cc -Wall -g ex9.c -o ex9 $ ./ex9 numbers: 0 0 0 0 name each: a name: a numbers: 1 2 3 4 name each: Z e d name: Zed another: Zed another each: Z e d $ 你会注意到这个程序中有一些很有趣的事情：\n我并没有提供全部的4个参数来初始化它。这是C的一个简写，如果你只提供了一个元素，剩下的都会为0。 numbers的每个元素被打印时，它们都输出0。 names的每个元素被打印时，只显示了第一个元素'a'，因为'\\0'是特殊字符而不会显示。 然后我们首次打印names，打印出了\"a\"，因为在初始化表达式中，'a'字符之后的空间都用'\\0'填充，是以'\\0'结尾的有效字符串。 我们接着通过手动为每个元素赋值来建立数组，并且再次把它打印出来。看看他们发生了什么改变。现在numbers已经设置好了，看看names字符串如何正确打印出我的名字。 创建一个字符串也有两种语法：第六行的char name[4] = {'a'}，或者第44行的char *another = \"name\"。前者不怎么常用，你应该将后者用于字符串字面值。 注意我使用了相同的语法和代码风格来和整数数组和字符数组交互，但是printf认为name是个字符串。再次强调，这是因为对C语言来说，字符数组和字符串没有什么不同。\n最后，当你使用字符串字面值时你应该用char *another = \"Literal\"语法，它会产生相同的东西，但是更加符合语言习惯，也更省事。\n如何使它崩溃 linkC中所有bug的大多数来源都是忘了预留出足够的空间，或者忘了在字符串末尾加上一个'\\0'。事实上，这些bug是非常普遍并且难以改正的，大部分优秀的C代码都不会使用C风格字符串。下一个练习中我们会学到如何彻底避免C风格字符串。\n使这个程序崩溃的的关键就是拿掉字符串结尾的'\\0'。下面是实现它的一些途径：\n删掉name的初始化表达式。 无意中设置name[3] = 'A'，于是它就没有终止字符了。 将初始化表达式设置为{'a','a','a','a'}，于是就有过多的'a'字符，没有办法给'\\0'留出位置。 试着想出一些其它的办法让它崩溃，并且在Valgrind下像往常一样运行这个程序，你可以看到具体发生了什么，以及错误叫什么名字。有时Valgrind并不能发现你犯的错误，则需要移动声明这些变量的地方看看是否能找出错误。这是C的黑魔法的一部分，有时变量的位置会改变bug。\n附加题 link 将一些字符赋给numbers的元素，之后用printf一次打印一个字符，你会得到什么编译器警告？ 对names执行上述的相反操作，把names当成int数组，并一次打印一个int，Valgrind会提示什么？ 有多少种其它的方式可以用来打印它？ 如果一个字符数组占四个字节，一个整数也占4个字节，你可以像整数一样使用整个name吗？你如何用黑魔法实现它？ 拿出一张纸，将每个数组画成一排方框，之后在纸上画出代码中的操作，看看是否正确。 将name转换成another的形式，看看代码是否能正常工作。 "
            }
        );
    index.add(
            {
                id:  20 ,
                href: "\/TechDocs\/docs\/c-guide\/ex10\/",
                title: "练习10：字符串数组和循环",
                description: "原文：Exercise 10: Arrays Of Strings, Looping 译者：飞龙 你现在可以创建不同类型的数组，并且也知道了“字符串”和“字节数组”是相同的东西。接下来，我们要更进一步，创建一个包含字符串的数组。我也会介绍第一个循环结构，for循环来帮我们打印出这一新的数据结构。 这一章的有趣之处就是你的程序中已经有一个现成的字符串数组，main函数参数中的char *argv[]。下面这段代码打印出了所有你传入的命令行参数： #include int main(int argc, char *argv[]) { int i = 0; // go through each string in argv // why am I skipping argv[0]? for(i = 1; i \u003c argc; i++) { printf(\"arg %d: %s\\n\", i, argv[i]); } // let's make our own array of strings char *states[] = { \"California\", \"Oregon\", \"Washington\", \"Texas\" }; int num_states = 4; for(i = 0; i \u003c num_states; i++) { printf(\"state %d: %s\\n\", i, states[i]); } return 0; } for循环的格式是这样的：",
                content: " 原文：Exercise 10: Arrays Of Strings, Looping\n译者：飞龙\n你现在可以创建不同类型的数组，并且也知道了“字符串”和“字节数组”是相同的东西。接下来，我们要更进一步，创建一个包含字符串的数组。我也会介绍第一个循环结构，for循环来帮我们打印出这一新的数据结构。\n这一章的有趣之处就是你的程序中已经有一个现成的字符串数组，main函数参数中的char *argv[]。下面这段代码打印出了所有你传入的命令行参数：\n#include int main(int argc, char *argv[]) { int i = 0; // go through each string in argv // why am I skipping argv[0]? for(i = 1; i \u003c argc; i++) { printf(\"arg %d: %s\\n\", i, argv[i]); } // let's make our own array of strings char *states[] = { \"California\", \"Oregon\", \"Washington\", \"Texas\" }; int num_states = 4; for(i = 0; i \u003c num_states; i++) { printf(\"state %d: %s\\n\", i, states[i]); } return 0; } for循环的格式是这样的：\nfor(INITIALIZER; TEST; INCREMENTER) { CODE; } 下面是for循环的工作机制：\nINITIALIZER中是用来初始化循环的代码，这个例子中它是i = 0。 接下来会检查TEST布尔表达式，如果为false（0）则跳过CODE，不做任何事情。 执行CODE，做它要做的任何事情。 在CODE执行之后会执行INCREMENTER部分，通常情况会增加一些东西，比如这个例子是i++。 然后跳到第二步继续执行，直到TEST为false（0）为止。 例子中的for循环使用argc和argv，遍历了命令行参数，像这样：\nOS将每个命令行参数作为字符串传入argv数组，程序名称./ex10在下标为0的位置，剩余的参数紧随其后。 OS将argc置为argv数组中参数的数量，所以你可以遍历它们而不会越界。要记住如果你提供了一个参数，程序名称是第一个，参数应该在第二个。 接下来程序使用i \u003c argc测试i是否使用argc，由于最开始1 \u003c 2，测试通过。 之后它会执行代码，输出i，并且将i用做argv的下标。 然后使用i++来运行自增语句，它是i = i + 1的便捷形式。 程序一直重复上面的步骤，直到i \u003c argc值为false（0），这时退出循环但程序仍然继续执行。 你会看到什么 link你需要用两种方法运行它来玩转这个程序。第一种方法是向命令行参数传递一些东西来设置argc和argv。第二种是不传入任何参数，于是你可以看到第一次的for循环没有被执行，由于i \u003c argc值为false。\n理解字符串数组 link你应该可以从这个练习中弄明白，你在C语言中通过混合char *str = \"blah\"和char str[] = {'b','l','a','h'}语法构建二维数组来构建字符串数组。第十四行的char *states[] = {...}语法就是这样的二维混合结构，其中每个字符串都是数组的一个元素，字符串的每个字符又是字符串的一个元素。\n感到困惑吗？多维的概念是很多人从来都不会去想的，所以你应该在纸上构建这一字符串数组：\n在纸的左边为每个字符串画一个小方格，带有它们的下标。 然后在方格上方写上每个字符的下标。 接着将字符串中的字符填充到方格内。 画完之后，在纸上模拟代码的执行过程。 理解它的另一种方法是在你熟悉的语言，比如Python或Ruby中构建相同的结构。\n如何使它崩溃 link 使用你喜欢的另一种语言，来写这个程序。传入尽可能多的命令行参数，看看是否能通过传入过多参数使其崩溃。 将i初始化为0看看会发生什么。是否也需要改动argc，不改动的话它能正常工作吗？为什么下标从0开始可以正常工作？ 将num_states改为错误的值使它变大，来看看会发生什么。 附加题 link 弄清楚在for循环的每一部分你都可以放置什么样的代码。 查询如何使用','（逗号）字符来在for循环的每一部分中，';'（分号）之间分隔多条语句。 查询NULL是什么东西，尝试将它用做states的一个元素，看看它会打印出什么。 看看你是否能在打印之前将states的一个元素赋值给argv中的元素，再试试相反的操作。 "
            }
        );
    index.add(
            {
                id:  21 ,
                href: "\/TechDocs\/docs\/c-guide\/ex11\/",
                title: "练习11：While循环和布尔表达式",
                description: "原文：Exercise 11: While-Loop And Boolean Expressions 译者：飞龙 你已经初步了解C语言如何处理循环，但是你可能不是很清楚布尔表达式i \u003c argc是什么。在学习while循环之前，让我先来对布尔表达式做一些解释。 在C语言中，实际上没有真正的“布尔”类型，而是用一个整数来代替，0代表false，其它值代表true。上一个练习中表达式i \u003c argc实际上值为1或者0，并不像Python是显式的Ture或者False。这是C语言更接近计算机工作方式的另一个例子，因为计算机只把值当成数字。 现在用while循环来实现和上一个练习相同的函数。这会让你使用两种循环，来观察两种循环是什么关系。 #include int main(int argc, char *argv[]) { // go through each string in argv int i = 0; while(i \u003c argc) { printf(\"arg %d: %s\\n\", i, argv[i]); i++; } // let's make our own array of strings char *states[] = { \"California\", \"Oregon\", \"Washington\", \"Texas\" }; int num_states = 4; i = 0; // watch for this while(i \u003c num_states) { printf(\"state %d: %s\\n\", i, states[i]); i++; } return 0; } 你可以看到while循环的语法更加简单：",
                content: " 原文：Exercise 11: While-Loop And Boolean Expressions\n译者：飞龙\n你已经初步了解C语言如何处理循环，但是你可能不是很清楚布尔表达式i \u003c argc是什么。在学习while循环之前，让我先来对布尔表达式做一些解释。\n在C语言中，实际上没有真正的“布尔”类型，而是用一个整数来代替，0代表false，其它值代表true。上一个练习中表达式i \u003c argc实际上值为1或者0，并不像Python是显式的Ture或者False。这是C语言更接近计算机工作方式的另一个例子，因为计算机只把值当成数字。\n现在用while循环来实现和上一个练习相同的函数。这会让你使用两种循环，来观察两种循环是什么关系。\n#include int main(int argc, char *argv[]) { // go through each string in argv int i = 0; while(i \u003c argc) { printf(\"arg %d: %s\\n\", i, argv[i]); i++; } // let's make our own array of strings char *states[] = { \"California\", \"Oregon\", \"Washington\", \"Texas\" }; int num_states = 4; i = 0; // watch for this while(i \u003c num_states) { printf(\"state %d: %s\\n\", i, states[i]); i++; } return 0; } 你可以看到while循环的语法更加简单：\nwhile(TEST) { CODE; } 只要TEST为true（非0），就会一直运行CODE中的代码。这意味着如果要达到和for循环同样的效果，我们需要自己写初始化语句，以及自己来使i增加。\n你会看到什么 link输出基本相同，所以我做了一点修改，使你可以看到它运行的另一种方式。\n$ make ex11 cc -Wall -g ex11.c -o ex11 $ ./ex11 arg 0: ./ex11 state 0: California state 1: Oregon state 2: Washington state 3: Texas $ $ ./ex11 test it arg 0: ./ex11 arg 1: test arg 2: it state 0: California state 1: Oregon state 2: Washington state 3: Texas $ 如何使它崩溃 link在你自己的代码中，应优先选择for循环而不是while循环，因为for循环不容易崩溃。下面是几点普遍的原因：\n忘记初始化int i，使循环发生错误。 忘记初始化第二个循环的i，于是i还保留着第一个循环结束时的值。你的第二个循环可能执行也可能不会执行。 忘记在最后执行i++自增，你会得到一个“死循环”，它是在你开始编程的第一个或前两个十年中，最可怕的问题之一。 附加题 link 让这些循环倒序执行，通过使用i--从argc开始递减直到0。你可能需要做一些算数操作让数组的下标正常工作。 使用while循环将argv中的值复制到states。 让这个复制循环不会执行失败，即使argv之中有很多元素也不会全部放进states。 研究你是否真正复制了这些字符串。答案可能会让你感到意外和困惑。 "
            }
        );
    index.add(
            {
                id:  22 ,
                href: "\/TechDocs\/docs\/c-guide\/ex12\/",
                title: "练习12：If，Else If，Else",
                description: "原文：Exercise 12: If, Else-If, Else 译者：飞龙 if语句是每个编程语言中共有的特性，包括C语言。下面是一段代码，使用了if语句来确保只传入了一个或两个命令行参数： #include int main(int argc, char *argv[]) { int i = 0; if(argc == 1) { printf(\"You only have one argument. You suck.\\n\"); } else if(argc \u003e 1 \u0026\u0026 argc \u003c 4) { printf(\"Here's your arguments:\\n\"); for(i = 0; i \u003c argc; i++) { printf(\"%s \", argv[i]); } printf(\"\\n\"); } else { printf(\"You have too many arguments. You suck.\\n\"); } return 0; } if语句的格式为：",
                content: " 原文：Exercise 12: If, Else-If, Else\n译者：飞龙\nif语句是每个编程语言中共有的特性，包括C语言。下面是一段代码，使用了if语句来确保只传入了一个或两个命令行参数：\n#include int main(int argc, char *argv[]) { int i = 0; if(argc == 1) { printf(\"You only have one argument. You suck.\\n\"); } else if(argc \u003e 1 \u0026\u0026 argc \u003c 4) { printf(\"Here's your arguments:\\n\"); for(i = 0; i \u003c argc; i++) { printf(\"%s \", argv[i]); } printf(\"\\n\"); } else { printf(\"You have too many arguments. You suck.\\n\"); } return 0; } if语句的格式为：\nif(TEST) { CODE; } else if(TEST) { CODE; } else { CODE; } 下面是其它语言和C的差异：\n像之前提到的那样，TEST表达式值为0时为false，其它情况为true。 你需要在TEST周围写上圆括号，其它语言可能不用。 （只有单条语句时）你并不需要使用花括号{}来闭合代码，但是这是一种非常不好的格式，不要这么写。花括号让一个分支的代码的开始和结束变得清晰。如果你不把代码写在里面会出现错误。 除了上面那些，就和其它语言一样了。else if或者else的部分并不必须出现。\n你会看到什么 link这段代码非常易于运行和尝试：\n$ make ex12 cc -Wall -g ex12.c -o ex12 $ ./ex12 You only have one argument. You suck. $ ./ex12 one Here's your arguments: ./ex12 one $ ./ex12 one two Here's your arguments: ./ex12 one two $ ./ex12 one two three You have too many arguments. You suck. $ 如何使它崩溃 link使这段代码崩溃并不容易，因为它太简单了。尝试把if语句的测试表达式搞乱：\n移除else部分，使它不能处理边界情况。 将\u0026\u0026改为||，于是你会把“与”操作变成“或”操作，并且看看会发生什么。 附加题 link 我已经向你简短地介绍了\u0026\u0026，它执行“与”操作。上网搜索与之不同的“布尔运算符”。 为这个程序编写更多的测试用例，看看你会写出什么。 回到练习10和11，使用if语句使循环提前退出。你需要break语句来实现它，搜索它的有关资料。 第一个判断所输出的话真的正确吗？由于你的“第一个参数”不是用户输入的第一个参数，把它改正。 "
            }
        );
    index.add(
            {
                id:  23 ,
                href: "\/TechDocs\/docs\/c-guide\/ex13\/",
                title: "练习13：Switch语句",
                description: "原文：Exercise 13: Switch Statement 译者：飞龙 在其它类似Ruby的语言中，switch语句可以处理任意类型的表达式。一些语言比如Python没有switch语句，因为带有布尔表达式的if语句可以做相同的事情。对于这些语言，switch语句比if语句更加灵活，然而内部的机制是一样的。 C中的switch语句与它们不同，实际上是一个“跳转表”。你只能够放置结果为整数的表达式，而不是一些随机的布尔表达式，这些整数用于计算从swicth顶部到匹配部分的跳转。下面有一段代码，我要分解它来让你理解“跳转表”的概念： #include int main(int argc, char *argv[]) { if(argc != 2) { printf(\"ERROR: You need one argument.\\n\"); // this is how you abort a program return 1; } int i = 0; for(i = 0; argv[1][i] != '\\0'; i++) { char letter = argv[1][i]; switch(letter) { case 'a': case 'A': printf(\"%d: 'A'\\n\", i); break; case 'e': case 'E': printf(\"%d: 'E'\\n\", i); break; case 'i': case 'I': printf(\"%d: 'I'\\n\", i); break; case 'o': case 'O': printf(\"%d: 'O'\\n\", i); break; case 'u': case 'U': printf(\"%d: 'U'\\n\", i); break; case 'y': case 'Y': if(i \u003e 2) { // it's only sometimes Y printf(\"%d: 'Y'\\n\", i); } break; default: printf(\"%d: %c is not a vowel\\n\", i, letter); } } return 0; } 在这个程序中我们接受了单一的命令行参数，并且用一种极其复杂的方式打印出所有原因，来向你演示switch语句。下面是swicth语句的工作原理：",
                content: " 原文：Exercise 13: Switch Statement\n译者：飞龙\n在其它类似Ruby的语言中，switch语句可以处理任意类型的表达式。一些语言比如Python没有switch语句，因为带有布尔表达式的if语句可以做相同的事情。对于这些语言，switch语句比if语句更加灵活，然而内部的机制是一样的。\nC中的switch语句与它们不同，实际上是一个“跳转表”。你只能够放置结果为整数的表达式，而不是一些随机的布尔表达式，这些整数用于计算从swicth顶部到匹配部分的跳转。下面有一段代码，我要分解它来让你理解“跳转表”的概念：\n#include int main(int argc, char *argv[]) { if(argc != 2) { printf(\"ERROR: You need one argument.\\n\"); // this is how you abort a program return 1; } int i = 0; for(i = 0; argv[1][i] != '\\0'; i++) { char letter = argv[1][i]; switch(letter) { case 'a': case 'A': printf(\"%d: 'A'\\n\", i); break; case 'e': case 'E': printf(\"%d: 'E'\\n\", i); break; case 'i': case 'I': printf(\"%d: 'I'\\n\", i); break; case 'o': case 'O': printf(\"%d: 'O'\\n\", i); break; case 'u': case 'U': printf(\"%d: 'U'\\n\", i); break; case 'y': case 'Y': if(i \u003e 2) { // it's only sometimes Y printf(\"%d: 'Y'\\n\", i); } break; default: printf(\"%d: %c is not a vowel\\n\", i, letter); } } return 0; } 在这个程序中我们接受了单一的命令行参数，并且用一种极其复杂的方式打印出所有原因，来向你演示switch语句。下面是swicth语句的工作原理：\n编译器会标记swicth语句的顶端，我们先把它记为地址Y。 接着对switch中的表达式求值，产生一个数字。在上面的例子中，数字为argv[1]中字母的原始的ASCLL码。 编译器也会把每个类似case 'A'的case代码块翻译成这个程序中距离语句顶端的地址，所以case 'A'就在Y + 'A'处。 接着计算是否Y+letter位于switch语句中，如果距离太远则会将其调整为Y+Default。 一旦计算出了地址，程序就会“跳”到代码的那个位置并继续执行。这就是一些case代码块中有break而另外一些没有的原因。 如果输出了'a'，那它就会跳到case 'a'，它里面没有break语句，所以它会贯穿执行底下带有代码和break的case 'A'。 最后它执行这段代码，执行break完全跳出switch语句块。 译者注：更常见的情况是，gcc会在空白处单独构建一张跳转表，各个偏移处存放对应的case语句的地址。Y不是switch语句的起始地址，而是这张表的起始地址。程序会跳转到*(Y + 'A')而不是Y + 'A'处。\n这是对swicth语句工作原理的一个深究，然而实际操作中你只需要记住下面几条简单的原则：\n总是要包含一个default:分支，可以让你接住被忽略的输入。 不要允许“贯穿”执行，除非你真的想这么做，这种情况下最好添加一个//fallthrough的注释。 一定要先编写case和break，再编写其中的代码。 如果能够简化的话，用if语句代替。 你会看到什么 link下面是我运行它的一个例子，也演示了传入命令行参数的不同方法：\n$ make ex13 cc -Wall -g ex13.c -o ex13 $ ./ex13 ERROR: You need one argument. $ $ ./ex13 Zed 0: Z is not a vowel 1: 'E' 2: d is not a vowel $ $ ./ex13 Zed Shaw ERROR: You need one argument. $ $ ./ex13 \"Zed Shaw\" 0: Z is not a vowel 1: 'E' 2: d is not a vowel 3: is not a vowel 4: S is not a vowel 5: h is not a vowel 6: 'A' 7: w is not a vowel $ 记住在代码的开始有个if语句，当没有提供足够的参数时使用return 1返回。返回非0是你提示操作系统程序出错的办法。任何大于0的值都可以在脚本中测试，其它程序会由此知道发生了什么。\n如何使它崩溃 link破坏一个switch语句块太容易了。下面是一些方法，你可以挑一个来用：\n忘记写break，程序就会运行两个或多个代码块，这些都是你不想运行的。 忘记写default，程序会在静默中忽略你所忘记的值。 无意中将一些带有预料之外的值的变量放入switch中，比如带有奇怪的值的int。 在switch中是否未初始化的值。 你也可以使用一些别的方法使这个程序崩溃。试着看你能不能自己做到它。\n附加题 link 编写另一个程序，在字母上做算术运算将它们转换为小写，并且在switch中移除所有额外的大写字母。 使用','（逗号）在for循环中初始化letter。 使用另一个for循环来让它处理你传入的所有命令行参数。 将这个switch语句转为if语句，你更喜欢哪个呢？ 在“Y”的例子中，我在if代码块外面写了个break。这样会产生什么效果？如果把它移进if代码块，会发生什么？自己试着解答它，并证明你是正确的。 "
            }
        );
    index.add(
            {
                id:  24 ,
                href: "\/TechDocs\/docs\/c-guide\/ex14\/",
                title: "练习14：编写并使用函数",
                description: "原文：Exercise 14: Writing And Using Functions 译者：飞龙 到现在为止，你只使用了作为stdio.h头文件一部分的函数。在这个练习中你将要编写并使用自己的函数。 #include #include // forward declarations int can_print_it(char ch); void print_letters(char arg[]); void print_arguments(int argc, char *argv[]) { int i = 0; for(i = 0; i \u003c argc; i++) { print_letters(argv[i]); } } void print_letters(char arg[]) { int i = 0; for(i = 0; arg[i] != '\\0'; i++) { char ch = arg[i]; if(can_print_it(ch)) { printf(\"'%c' == %d \", ch, ch); } } printf(\"\\n\"); } int can_print_it(char ch) { return isalpha(ch) || isblank(ch); } int main(int argc, char *argv[]) { print_arguments(argc, argv); return 0; } 在这个例子中你创建了函数来打印任何属于“字母”和“空白”的字符。下面是一个分解：",
                content: " 原文：Exercise 14: Writing And Using Functions\n译者：飞龙\n到现在为止，你只使用了作为stdio.h头文件一部分的函数。在这个练习中你将要编写并使用自己的函数。\n#include #include // forward declarations int can_print_it(char ch); void print_letters(char arg[]); void print_arguments(int argc, char *argv[]) { int i = 0; for(i = 0; i \u003c argc; i++) { print_letters(argv[i]); } } void print_letters(char arg[]) { int i = 0; for(i = 0; arg[i] != '\\0'; i++) { char ch = arg[i]; if(can_print_it(ch)) { printf(\"'%c' == %d \", ch, ch); } } printf(\"\\n\"); } int can_print_it(char ch) { return isalpha(ch) || isblank(ch); } int main(int argc, char *argv[]) { print_arguments(argc, argv); return 0; } 在这个例子中你创建了函数来打印任何属于“字母”和“空白”的字符。下面是一个分解：\nex14.c:2\n包含了新的头文件，所以你可以访问isalpha和isblank。\nex14.c:5-6\n告诉C语言你稍后会在你的程序中使用一些函数，它们实际上并没有被定义。这叫做“前向声明”，它解决了要想使用函数先要定义的鸡和蛋的问题。\nex14.c:8-15\n定义print_arguments，它知道如何打印通常由main函数获得的相同字符串数组。\nex14.c:17-30\n定义了can_print_it，它只是简单地将isalpha(ch) || isblank(ch)的真值（0或1）返回给它的调用者print_letters。\nex14.c:38-42\n最后main函数简单地调用print_arguments，来启动整个函数链。\n我不应该描述每个函数里都有什么，因为这些都是你之前遇到过的东西。你应该看到的是，我只是像你定义main函数一样来定义其它函数。唯一的不同就是如果你打算使用当前文件中没有碰到过的函数，你应该事先告诉C。这就是代码顶部的“前向声明”的作用。\n你会看到什么 link向这个程序传入不同的命令行参数来玩转它，这样会遍历你函数中的所有路径。这里演示了我和它的交互：\n$ make ex14 cc -Wall -g ex14.c -o ex14 $ ./ex14 'e' == 101 'x' == 120 $ ./ex14 hi this is cool 'e' == 101 'x' == 120 'h' == 104 'i' == 105 't' == 116 'h' == 104 'i' == 105 's' == 115 'i' == 105 's' == 115 'c' == 99 'o' == 111 'o' == 111 'l' == 108 $ ./ex14 \"I go 3 spaces\" 'e' == 101 'x' == 120 'I' == 73 ' ' == 32 'g' == 103 'o' == 111 ' ' == 32 ' ' == 32 's' == 115 'p' == 112 'a' == 97 'c' == 99 'e' == 101 's' == 115 $ isalpha和isblank做了检查提供的字符是否是字母或者空白字符的所有工作。当我最后一次运行时，它打印出除了'3'之外的任何东西，因为它是一个数字。\n如何使它崩溃 link下面是使它崩溃的两种不同的方法：\n通过移除前向声明来把编译器搞晕。它会报告can_print_it 和 print_letters的错误。 当你在main中调用print_arguments时，试着使argc加1，于是它会越过argv数组的最后一个元素。 附加题 link 重新编写这些函数，使它们的数量减少。比如，你真的需要can_print_it吗？ 使用strlen函数，让print_arguments知道每个字符串参数都有多长，之后将长度传入print_letters。然后重写print_letters，让它只处理固定的长度，不按照'\\0'终止符。你需要#include 来实现它。 使用man来查询isalpha和isblank的信息。使用其它相似的函数来只打印出数字或者其它字符。 上网浏览不同的人喜欢什么样的函数格式。永远不要使用“K\u0026R”语法，因为它过时了，而且容易使人混乱，但是当你碰到一些人使用这种格式时，要理解代码做了什么。 "
            }
        );
    index.add(
            {
                id:  25 ,
                href: "\/TechDocs\/docs\/c-guide\/ex15\/",
                title: "练习15：指针，可怕的指针",
                description: "原文：Exercise 15: Pointers Dreaded Pointers 译者：飞龙 指针是C中的一个著名的谜之特性，我会试着通过教授你一些用于处理它们的词汇，使之去神秘化。指针实际上并不复杂，只不过它们经常以一些奇怪的方式被滥用，这样使它们变得难以使用。如果你避免这些愚蠢的方法来使用指针，你会发现它们难以置信的简单。 要想以一种我们可以谈论的方式来讲解指针，我会编写一个无意义的程序，它以三种方式打印了一组人的年龄： #include int main(int argc, char *argv[]) { // create two arrays we care about int ages[] = {23, 43, 12, 89, 2}; char *names[] = { \"Alan\", \"Frank\", \"Mary\", \"John\", \"Lisa\" }; // safely get the size of ages int count = sizeof(ages) / sizeof(int); int i = 0; // first way using indexing for(i = 0; i \u003c count; i++) { printf(\"%s has %d years alive.",
                content: " 原文：Exercise 15: Pointers Dreaded Pointers\n译者：飞龙\n指针是C中的一个著名的谜之特性，我会试着通过教授你一些用于处理它们的词汇，使之去神秘化。指针实际上并不复杂，只不过它们经常以一些奇怪的方式被滥用，这样使它们变得难以使用。如果你避免这些愚蠢的方法来使用指针，你会发现它们难以置信的简单。\n要想以一种我们可以谈论的方式来讲解指针，我会编写一个无意义的程序，它以三种方式打印了一组人的年龄：\n#include int main(int argc, char *argv[]) { // create two arrays we care about int ages[] = {23, 43, 12, 89, 2}; char *names[] = { \"Alan\", \"Frank\", \"Mary\", \"John\", \"Lisa\" }; // safely get the size of ages int count = sizeof(ages) / sizeof(int); int i = 0; // first way using indexing for(i = 0; i \u003c count; i++) { printf(\"%s has %d years alive.\\n\", names[i], ages[i]); } printf(\"---\\n\"); // setup the pointers to the start of the arrays int *cur_age = ages; char **cur_name = names; // second way using pointers for(i = 0; i \u003c count; i++) { printf(\"%s is %d years old.\\n\", *(cur_name+i), *(cur_age+i)); } printf(\"---\\n\"); // third way, pointers are just arrays for(i = 0; i \u003c count; i++) { printf(\"%s is %d years old again.\\n\", cur_name[i], cur_age[i]); } printf(\"---\\n\"); // fourth way with pointers in a stupid complex way for(cur_name = names, cur_age = ages; (cur_age - ages) \u003c count; cur_name++, cur_age++) { printf(\"%s lived %d years so far.\\n\", *cur_name, *cur_age); } return 0; } 在解释指针如何工作之前，让我们逐行分解这个程序，这样你可以对发生了什么有所了解。当你浏览这个详细说明时，试着自己在纸上回答问题，之后看看你猜测的结果符合我对指针的描述。\nex15.c:6-10\n创建了两个数组，ages储存了一些int数据，names储存了一个字符串数组。\nex15.c:12-13\n为之后的for循环创建了一些变量。\nex15.c:16-19\n你知道这只是遍历了两个数组，并且打印出每个人的年龄。它使用了i来对数组索引。\nex15.c:24\n创建了一个指向ages的指针。注意int *创建“指向整数的指针”的指针类型的用法。它很像char *，意义是“指向字符的指针”，而且字符串是字符的数组。是不是很相似呢？\nex15.c:25\n创建了指向names的指针。char *已经是“指向char的指针”了，所以它只是个字符串。你需要两个层级，因为names是二维的，也就是说你需要char **作为“指向‘指向字符的指针’的指针”。把它学会，并且自己解释它。\nex15.c:28-31\n遍历ages和names，但是使用“指针加偏移i”。*(cur_name+i)和name[i]是一样的，你应该把它读作“‘cur_name指针加i’的值”。\nex15.c:35-39\n这里展示了访问数组元素的语法和指针是相同的。\nex15.c:44-50\n另一个十分愚蠢的循环和其它两个循环做着相同的事情，但是它用了各种指针算术运算来代替：\nex15.c:44\n通过将cur_name和cur_age置为names和age数组的起始位置来初始化for循环。\nex15.c:45\nfor循环的测试部分比较cur_age指针和ages起始位置的距离，为什么可以这样写呢？\nex15.c:46\nfor循环的增加部分增加了cur_name和cur_age的值，这样它们可以只想names和ages的下一个元素。\nex15.c:48-49\ncur_name和cur_age的值现在指向了相应数组中的一个元素，我们我可以通过*cur_name和*cur_age来打印它们，这里的意思是“cur_name和cur_age指向的值”。\n这个看似简单的程序却包含了大量的信息，其目的是在我向你讲解之前尝试让你自己弄清楚指针。直到你写下你认为指针做了什么之前，不要往下阅读。\n你会看到什么 link在你运行这个程序之后，尝试根据打印出的每一行追溯到代码中产生它们的那一行。在必要情况下，修改printf调用来确认你得到了正确的行号：\n$ make ex15 cc -Wall -g ex15.c -o ex15 $ ./ex15 Alan has 23 years alive. Frank has 43 years alive. Mary has 12 years alive. John has 89 years alive. Lisa has 2 years alive. --- Alan is 23 years old. Frank is 43 years old. Mary is 12 years old. John is 89 years old. Lisa is 2 years old. --- Alan is 23 years old again. Frank is 43 years old again. Mary is 12 years old again. John is 89 years old again. Lisa is 2 years old again. --- Alan lived 23 years so far. Frank lived 43 years so far. Mary lived 12 years so far. John lived 89 years so far. Lisa lived 2 years so far. $ 解释指针 link当你写下一些类似ages[i]的东西时，你实际上在用i中的数字来索引ages。如果i的值为0，那么就等同于写下ages[0]。我们把i叫做下标，因为它是ages中的一个位置。它也能称为地址，这是“我想要ages位于地址i处的整数”中的说法。\n如果i是个下标，那么ages又是什么？对C来说ages是在计算机中那些整数的起始位置。当然它也是个地址，C编译器会把任何你键入ages的地方替换为数组中第一个整数的地址。另一个理解它的办法就是把ages当作“数组内部第一个整数的地址”，但是它是整个计算机中的地址，而不是像i一样的ages中的地址。ages数组的名字在计算机中实际上是个地址。\n这就产生了一种特定的实现：C把你的计算机看成一个庞大的字节数组。显然这样不会有什么用处，于是C就在它的基础上构建出类型和大小的概念。你已经在前面的练习中看到了它是如何工作的，但现在你可以开始了解C对你的数组做了下面一些事情：\n在你的计算机中开辟一块内存。 将ages这个名字“指向”它的起始位置。 通过选取ages作为基址，并且获取位置为i的元素，来对内存块进行索引。 将ages+i处的元素转换成大小正确的有效的int，这样就返回了你想要的结果：下标i处的int。 如果你可以选取ages作为基址，之后加上比如i的另一个地址，你是否就能随时构造出指向这一地址的指针呢？是的，这种东西就叫做指针。这也是cur_age和cur_name所做的事情，它们是指向计算机中这一位置的变量，ages和names就处于这一位置。之后，示例程序移动它们，或者做了一些算数运算，来从内存中获取值。在其中一个实例中，只是简单地将cur_age加上i，这样等同于array[i]。在最后一个for循环中，这两个指针在没有i辅助的情况下自己移动，被当做数组基址和整数偏移合并到一起的组合。\n指针仅仅是指向计算机中的某个地址，并带有类型限定符，所以你可以通过它得到正确大小的数据。它类似于将ages和i组合为一个数据类型的东西。C了解指针指向什么地方，所指向的数据类型，这些类型的大小，以及如何为你获取数据。你可以像i一样增加它们，减少它们，对他们做加减运算。然而它们也像是ages，你可以通过它获取值，放入新的值，或执行全部的数组操作。\n指针的用途就是让你手动对内存块进行索引，一些情况下数组并不能做到。绝大多数情况中，你可能打算使用数组，但是一些处理原始内存块的情况，是指针的用武之地。指针向你提供了原始的、直接的内存块访问途径，让你能够处理它们。\n在这一阶段需要掌握的最后一件事，就是你可以对数组和指针操作混用它们绝大多数的语法。你可以对一个指针使用数组的语法来访问指向的东西，也可以对数组的名字做指针的算数运算。\n实用的指针用法 link你可以用指针做下面四个最基本的操作：\n向OS申请一块内存，并且用指针处理它。这包括字符串，和一些你从来没见过的东西，比如结构体。 通过指针向函数传递大块的内存（比如很大的结构体），这样不必把全部数据都传递进去。 获取函数的地址用于动态调用。 对一块内存做复杂的搜索，比如，转换网络套接字中的字节，或者解析文件。 对于你看到的其它所有情况，实际上应当使用数组。在早期，由于编译器不擅长优化数组，人们使用指针来加速它们的程序。然而，现在访问数组和指针的语法都会翻译成相同的机器码，并且表现一致。由此，你应该每次尽可能使用数组，并且按需将指针用作提升性能的手段。\n指针词库 link现在我打算向你提供一个词库，用于读写指针。当你遇到复杂的指针语句时，试着参考它并且逐字拆分语句（或者不要使用这个语句，因为有可能并不好）：\ntype *ptr\ntype类型的指针，名为ptr。\n*ptr\nptr所指向位置的值。\n*(ptr + i)\n（ptr所指向位置加上i）的值。\n译者注：以字节为单位的话，应该是ptr所指向的位置再加上sizeof(type) * i。\n\u0026thing\nthing的地址。\ntype *ptr = \u0026thing\n名为ptr，type类型的指针，值设置为thing的地址。\nptr++\n自增ptr指向的位置。\n我们将会使用这份简单的词库来拆解这本书中所有的指针用例。\n指针并不是数组 link无论怎么样，你都不应该把指针和数组混为一谈。它们并不是相同的东西，即使C让你以一些相同的方法来使用它们。例如，如果你访问上面代码中的sizeof(cur_age)，你会得到指针的大小，而不是它指向数组的大小。如果你想得到整个数组的大小，你应该使用数组的名称age，就像第12行那样。\n译者注，除了sizeof、\u0026操作和声明之外，数组名称都会被编译器推导为指向其首个元素的指针。对于这些情况，不要用“是”这个词，而是要用“推导”。\n如何使它崩溃 link你可以通过将指针指向错误的位置来使程序崩溃：\n试着将cur_age指向names。可以需要C风格转换来强制执行，试着查阅相关资料把它弄明白。 在最后的for循环中，用一些古怪的方式使计算发生错误。 试着重写循环，让它们从数组的最后一个元素开始遍历到首个元素。这比看上去要困难。 附加题 link 使用访问指针的方式重写所有使用数组的地方。 使用访问数组的方式重写所有使用指针的地方。 在其它程序中使用指针来代替数组访问。 使用指针来处理命令行参数，就像处理names那样。 将获取值和获取地址组合到一起。 在程序末尾添加一个for循环，打印出这些指针所指向的地址。你需要在printf中使用%p。 对于每一种打印数组的方法，使用函数来重写程序。试着向函数传递指针来处理数据。记住你可以声明接受指针的函数，但是可以像数组那样用它。 将for循环改为while循环，并且观察对于每种指针用法哪种循环更方便。 "
            }
        );
    index.add(
            {
                id:  26 ,
                href: "\/TechDocs\/docs\/c-guide\/ex16\/",
                title: "练习16：结构体和指向它们的指针",
                description: "原文：Exercise 16: Structs And Pointers To Them 译者：飞龙 在这个练习中你将会学到如何创建struct，将一个指针指向它们，以及使用它们来理解内存的内部结构。我也会借助上一节课中的指针知识，并且让你使用malloc从原始内存中构造这些结构体。 像往常一样，下面是我们将要讨论的程序，你应该把它打下来并且使它正常工作： #include #include #include #include struct Person { char *name; int age; int height; int weight; }; struct Person *Person_create(char *name, int age, int height, int weight) { struct Person *who = malloc(sizeof(struct Person)); assert(who != NULL); who-\u003ename = strdup(name); who-\u003eage = age; who-\u003eheight = height; who-\u003eweight = weight; return who; } void Person_destroy(struct Person *who) { assert(who !",
                content: " 原文：Exercise 16: Structs And Pointers To Them\n译者：飞龙\n在这个练习中你将会学到如何创建struct，将一个指针指向它们，以及使用它们来理解内存的内部结构。我也会借助上一节课中的指针知识，并且让你使用malloc从原始内存中构造这些结构体。\n像往常一样，下面是我们将要讨论的程序，你应该把它打下来并且使它正常工作：\n#include #include #include #include struct Person { char *name; int age; int height; int weight; }; struct Person *Person_create(char *name, int age, int height, int weight) { struct Person *who = malloc(sizeof(struct Person)); assert(who != NULL); who-\u003ename = strdup(name); who-\u003eage = age; who-\u003eheight = height; who-\u003eweight = weight; return who; } void Person_destroy(struct Person *who) { assert(who != NULL); free(who-\u003ename); free(who); } void Person_print(struct Person *who) { printf(\"Name: %s\\n\", who-\u003ename); printf(\"\\tAge: %d\\n\", who-\u003eage); printf(\"\\tHeight: %d\\n\", who-\u003eheight); printf(\"\\tWeight: %d\\n\", who-\u003eweight); } int main(int argc, char *argv[]) { // make two people structures struct Person *joe = Person_create( \"Joe Alex\", 32, 64, 140); struct Person *frank = Person_create( \"Frank Blank\", 20, 72, 180); // print them out and where they are in memory printf(\"Joe is at memory location %p:\\n\", joe); Person_print(joe); printf(\"Frank is at memory location %p:\\n\", frank); Person_print(frank); // make everyone age 20 years and print them again joe-\u003eage += 20; joe-\u003eheight -= 2; joe-\u003eweight += 40; Person_print(joe); frank-\u003eage += 20; frank-\u003eweight += 20; Person_print(frank); // destroy them both so we clean up Person_destroy(joe); Person_destroy(frank); return 0; } 我打算使用一种和之前不一样的方法来描述这段程序。我并不会对程序做逐行的拆分，而是由你自己写出来。我会基于程序所包含的部分来给你提示，你的任务就是写出每行是干什么的。\n包含（include）\n我包含了一些新的头文件，来访问一些新的函数。每个头文件都提供了什么东西？\nstruct Person\n这就是我创建结构体的地方了，结构体含有四个成员来描述一个人。最后我们得到了一个复合类型，让我们通过一个名字来整体引用这些成员，或它们的每一个。这就像数据库表中的一行或者OOP语言中的一个类那样。\nPearson_create 函数\n我需要一个方法来创建这些结构体，于是我定义了一个函数来实现。下面是这个函数做的几件重要的事情：\n使用用于内存分配的malloc来向OS申请一块原始的内存。 向malloc传递sizeof(struct Person)参数，它计算结构体的大小，包含其中的所有成员。 使用了assert来确保从malloc得到一块有效的内存。有一个特殊的常量叫做NULL，表示“未设置或无效的指针”。这个assert大致检查了malloc是否会返回NULL。 使用x-\u003ey语法来初始化struct Person的每个成员，它指明了所初始化的成员。 使用strdup来复制字符串name，是为了确保结构体真正拥有它。strdup的行为实际上类似malloc但是它同时会将原来的字符串复制到新创建的内存。 译者注：x-\u003ey是(*x).y的简写。\nPerson_destroy 函数\n如果定义了创建函数，那么一定需要一个销毁函数，它会销毁Person结构体。我再一次使用了assert来确保不会得到错误的输入。接着我使用了free函数来交还通过malloc和strdup得到的内存。如果你不这么做则会出现“内存泄露”。\n译者注：不想显式释放内存又能避免内存泄露的办法是引入libGC库。你需要把所有的malloc换成GC_malloc，然后把所有的free删掉。\nPerson_print 函数\n接下来我需要一个方法来打印出人们的信息，这就是这个函数所做的事情。它用了相同的x-\u003ey语法从结构体中获取成员来打印。\nmain 函数\n我在main函数中使用了所有前面的函数和struct Person来执行下面的事情：\n创建了两个人：joe和frank。 把它们打印出来，注意我用了%p占位符，所以你可以看到程序实际上把结构体放到了哪里。 把它们的年龄增加20岁，同时增加它们的体重。 之后打印出每个人。 最后销毁结构体，以正确的方式清理它们。 请仔细阅读上面的描述，然后做下面的事情：\n查询每个你不了解的函数或头文件。记住你通常可以使用man 2 function或者man 3 function来让它告诉你。你也可以上网搜索资料。 在每一行上方编写注释，写下这一行代码做了什么。 跟踪每一个函数调用和变量，你会知道它在程序中是在哪里出现的。 同时也查询你不清楚的任何符号。 你会看到什么 link在你使用描述性注释扩展程序之后，要确保它实际上能够运行，并且产生下面的输出：\n$ make ex16 cc -Wall -g ex16.c -o ex16 $ ./ex16 Joe is at memory location 0xeba010: Name: Joe Alex Age: 32 Height: 64 Weight: 140 Frank is at memory location 0xeba050: Name: Frank Blank Age: 20 Height: 72 Weight: 180 Name: Joe Alex Age: 52 Height: 62 Weight: 180 Name: Frank Blank Age: 40 Height: 72 Weight: 200 解释结构体 link如果你完成了我要求的任务，你应该理解了结构体。不过让我来做一个明确的解释，确保你真正理解了它。\nC中的结构体是其它数据类型（变量）的一个集合，它们储存在一块内存中，然而你可以通过独立的名字来访问每个变量。它们就类似于数据库表中的一行记录，或者面向对象语言中的一个非常简单的类。让我们以这种方式来理解它：\n在上面的代码中，你创建了一个结构体，它们的成员用于描述一个人：名称、年龄、体重、身高。 每个成员都有一个类型，比如是int。 C会将它们打包到一起，于是它们可以用单个的结构体来存放。 struct Person是一个复合类型，这意味着你可以在同种表达式中将其引用为其它的数据类型。 你可以将这一紧密的组合传递给其它函数，就像Person_print那样。 如果结构体是指针的形式，接着你可以使用x-\u003ey通过它们的名字来访问结构体中独立的部分。 还有一种创建结构体的方法，不需要指针，通过x.y来访问。你将会在附加题里面见到它。 如果你不使用结构体，则需要自己计算出大小、打包以及定位出指定内容的内存片位置。实际上，在大多数早期（甚至现在的一些）的汇编代码中，这就是唯一的方式。在C中你就可以让C来处理这些复合数据类型的内存构造，并且专注于和它们交互。\n如何使它崩溃 link使这个程序崩溃的办法涉及到使用指针和malloc系统的方法：\n试着传递NULL给Person_destroy来看看会发生什么。如果它没有崩溃，你必须移除Makefile的CFLAGS中的-g选项。 在结尾处忘记调用Person_destroy，在Valgrind下运行程序，你会看到它报告出你忘记释放内存。弄清楚你应该向valgrind传递什么参数来让它向你报告内存如何泄露。 忘记在Person_destroy中释放who-\u003ename，并且对比两次的输出。同时，使用正确的选项来让Valgrind告诉你哪里错了。 这一次，向Person_print传递NULL，并且观察Valgrind会输出什么。 你应该明白了NULL是个使程序崩溃的快速方法。 附加题 link在这个练习的附加题中我想让你尝试一些有难度的东西：将这个程序改为不用指针和malloc的版本。这可能很困难，所以你需要研究下面这些东西：\n如何在栈上创建结构体，就像你创建任何其它变量那样。 如何使用x.y而不是x-\u003ey来初始化结构体。 如何不使用指针来将结构体传给其它函数。 "
            }
        );
    index.add(
            {
                id:  27 ,
                href: "\/TechDocs\/docs\/c-guide\/ex17\/",
                title: "练习17：堆和栈的内存分配",
                description: "原文：Exercise 17: Heap And Stack Memory Allocation 译者：飞龙 在这个练习中，你会在难度上做一个大的跳跃，并且创建出用于管理数据库的完整的小型系统。这个数据库并不实用也存储不了太多东西，然而它展示了大多数到目前为止你学到的东西。它也以更加正规的方法介绍了内存分配，以及带领你熟悉文件处理。我们使用了一些文件IO函数，但是我并不想过多解释它们，你可以先试着自己理解。 像通常一样，输入下面整个程序，并且使之正常工作，之后我们会进行讨论： #include #include #include #include #include #define MAX_DATA 512 #define MAX_ROWS 100 struct Address { int id; int set; char name[MAX_DATA]; char email[MAX_DATA]; }; struct Database { struct Address rows[MAX_ROWS]; }; struct Connection { FILE *file; struct Database *db; }; void die(const char *message) { if(errno) { perror(message); } else { printf(\"ERROR: %s\\n\", message); } exit(1); } void Address_print(struct Address *addr) { printf(\"%d %s %s\\n\", addr-\u003eid, addr-\u003ename, addr-\u003eemail); } void Database_load(struct Connection *conn) { int rc = fread(conn-\u003edb, sizeof(struct Database), 1, conn-\u003efile); if(rc !",
                content: " 原文：Exercise 17: Heap And Stack Memory Allocation\n译者：飞龙\n在这个练习中，你会在难度上做一个大的跳跃，并且创建出用于管理数据库的完整的小型系统。这个数据库并不实用也存储不了太多东西，然而它展示了大多数到目前为止你学到的东西。它也以更加正规的方法介绍了内存分配，以及带领你熟悉文件处理。我们使用了一些文件IO函数，但是我并不想过多解释它们，你可以先试着自己理解。\n像通常一样，输入下面整个程序，并且使之正常工作，之后我们会进行讨论：\n#include #include #include #include #include #define MAX_DATA 512 #define MAX_ROWS 100 struct Address { int id; int set; char name[MAX_DATA]; char email[MAX_DATA]; }; struct Database { struct Address rows[MAX_ROWS]; }; struct Connection { FILE *file; struct Database *db; }; void die(const char *message) { if(errno) { perror(message); } else { printf(\"ERROR: %s\\n\", message); } exit(1); } void Address_print(struct Address *addr) { printf(\"%d %s %s\\n\", addr-\u003eid, addr-\u003ename, addr-\u003eemail); } void Database_load(struct Connection *conn) { int rc = fread(conn-\u003edb, sizeof(struct Database), 1, conn-\u003efile); if(rc != 1) die(\"Failed to load database.\"); } struct Connection *Database_open(const char *filename, char mode) { struct Connection *conn = malloc(sizeof(struct Connection)); if(!conn) die(\"Memory error\"); conn-\u003edb = malloc(sizeof(struct Database)); if(!conn-\u003edb) die(\"Memory error\"); if(mode == 'c') { conn-\u003efile = fopen(filename, \"w\"); } else { conn-\u003efile = fopen(filename, \"r+\"); if(conn-\u003efile) { Database_load(conn); } } if(!conn-\u003efile) die(\"Failed to open the file\"); return conn; } void Database_close(struct Connection *conn) { if(conn) { if(conn-\u003efile) fclose(conn-\u003efile); if(conn-\u003edb) free(conn-\u003edb); free(conn); } } void Database_write(struct Connection *conn) { rewind(conn-\u003efile); int rc = fwrite(conn-\u003edb, sizeof(struct Database), 1, conn-\u003efile); if(rc != 1) die(\"Failed to write database.\"); rc = fflush(conn-\u003efile); if(rc == -1) die(\"Cannot flush database.\"); } void Database_create(struct Connection *conn) { int i = 0; for(i = 0; i \u003c MAX_ROWS; i++) { // make a prototype to initialize it struct Address addr = {.id = i, .set = 0}; // then just assign it conn-\u003edb-\u003erows[i] = addr; } } void Database_set(struct Connection *conn, int id, const char *name, const char *email) { struct Address *addr = \u0026conn-\u003edb-\u003erows[id]; if(addr-\u003eset) die(\"Already set, delete it first\"); addr-\u003eset = 1; // WARNING: bug, read the \"How To Break It\" and fix this char *res = strncpy(addr-\u003ename, name, MAX_DATA); // demonstrate the strncpy bug if(!res) die(\"Name copy failed\"); res = strncpy(addr-\u003eemail, email, MAX_DATA); if(!res) die(\"Email copy failed\"); } void Database_get(struct Connection *conn, int id) { struct Address *addr = \u0026conn-\u003edb-\u003erows[id]; if(addr-\u003eset) { Address_print(addr); } else { die(\"ID is not set\"); } } void Database_delete(struct Connection *conn, int id) { struct Address addr = {.id = id, .set = 0}; conn-\u003edb-\u003erows[id] = addr; } void Database_list(struct Connection *conn) { int i = 0; struct Database *db = conn-\u003edb; for(i = 0; i \u003c MAX_ROWS; i++) { struct Address *cur = \u0026db-\u003erows[i]; if(cur-\u003eset) { Address_print(cur); } } } int main(int argc, char *argv[]) { if(argc \u003c 3) die(\"USAGE: ex17 [action params]\"); char *filename = argv[1]; char action = argv[2][0]; struct Connection *conn = Database_open(filename, action); int id = 0; if(argc \u003e 3) id = atoi(argv[3]); if(id \u003e= MAX_ROWS) die(\"There's not that many records.\"); switch(action) { case 'c': (conn); Database_write(conn); break; case 'g': if(argc != 4) die(\"Need an id to get\"); Database_get(conn, id); break; case 's': if(argc != 6) die(\"Need id, name, email to set\"); Database_set(conn, id, argv[4], argv[5]); Database_write(conn); break; case 'd': if(argc != 4) die(\"Need id to delete\"); Database_delete(conn, id); Database_write(conn); break; case 'l': Database_list(conn); break; default: die(\"Invalid action, only: c=create, g=get, s=set, d=del, l=list\"); } Database_close(conn); return 0; } 在这个程序中我使用了一系列的结构来创建用于地址薄的小型数据库。其中，我是用了一些你从来没见过的东西，所以你应该逐行浏览这段代码，解释每一行做了什么，并且查询你不认识的任何函数。下面是你需要注意的几个关键部分：\n#define 常量\n我使用了“C预处理器”的另外一部分，来创建MAX_DATA和MAX_ROWS的设置常量。我之后会更多地讲解预处理器的功能，不过这是一个创建可靠的常量的简易方法。除此之外还有另一种方法，但是在特定场景下并不适用。\n定长结构体\nAddress结构体接着使用这些常量来创建数据，这些数据是定长的，它们并不高效，但是便于存储和读取。Database结构体也是定长的，因为它有一个定长的Address结构体数组。这样你就可以稍后把整个数据一步写到磁盘。\n出现错误时终止的die函数\n在像这样的小型程序中，你可以编写一个单个函数在出现错误时杀掉程序。我把它叫做die。而且在任何失败的函数调用，或错误输出之后，它会调用exit带着错误退出程序。\n用于错误报告的 errno和perror\n当函数返回了一个错误时，它通常设置一个叫做errno的“外部”变量，来描述发生了什么错误。它们只是数字，所以你可以使用perror来“打印出错误信息”。\n文件函数\n我使用了一些新的函数，比如fopen，fread，fclose，和rewind来处理文件。这些函数中每个都作用于FILE结构体上，就像你的结构体似的，但是它由C标准库定义。\n嵌套结构体指针\n你应该学习这里的嵌套结构器和获取数组元素地址的用法，它读作“读取db中的conn中的rows的第i个元素，并返回地址（\u0026）”。\n译者注：这里有个更简便的写法是db-\u003econn-\u003erow + i。\n结构体原型的复制\n它在Database_delete中体现得最清楚，你可以看到我是用了临时的局部Address变量，初始化了它的id和set字段，接着通过把它赋值给rows数组中的元素，简单地复制到数组中。这个小技巧确保了所有除了set和id的字段都初始化为0，而且很容易编写。顺便说一句，你不应该在这种数组复制操作中使用memcpy。现代C语言中你可以只是将一个赋值给另一个，它会自动帮你处理复制。\n处理复杂参数\n我执行了一些更复杂的参数解析，但是这不是处理它们的最好方法。在这本书的后面我们将会了解一些用于解析的更好方法。\n将字符串转换为整数\n我使用了atoi函数在命令行中接受作为id的字符串并把它转换为int id变量。去查询这个函数以及相似的函数。\n在堆上分配大块数据\n这个程序的要点就是在我创建Database的时候，我使用了malloc来向OS请求一块大容量的内存。稍后我会讲得更细致一些。\nNULL就是0，所以可转成布尔值\n在许多检查中，我简单地通过if(!ptr) die(\"fail!\")检测了一个指针是不是NULL。这是有效的，因为NULL会被计算成假。在一些少见的系统中，NULL会储存在计算机中，并且表示为一些不是0的东西。但在C标准中，你可以把它当成0来编写代码。到目前为止，当我说“NULL就是0”的时候，我都是对一些迂腐的人说的。\n你会看到什么 link你应该为此花费大量时间，知道你可以测试它能正常工作了。并且你应当用Valgrind来确保你在所有地方都正确使用内存。下面是我的测试记录，并且随后使用了Valgrind来检查操作：\n$ make ex17 cc -Wall -g ex17.c -o ex17 $ ./ex17 db.dat c $ ./ex17 db.dat s 1 zed zed@zedshaw.com $ ./ex17 db.dat s 2 frank frank@zedshaw.com $ ./ex17 db.dat s 3 joe joe@zedshaw.com $ $ ./ex17 db.dat l 1 zed zed@zedshaw.com 2 frank frank@zedshaw.com 3 joe joe@zedshaw.com $ ./ex17 db.dat d 3 $ ./ex17 db.dat l 1 zed zed@zedshaw.com 2 frank frank@zedshaw.com $ ./ex17 db.dat g 2 2 frank frank@zedshaw.com $ $ valgrind --leak-check=yes ./ex17 db.dat g 2 $ Valgrind实际的输出没有显式，因为你应该能够发现它。\n注\nVagrind可以报告出你泄露的小块内存，但是它有时会过度报告OSX内部的API。如果你发现它显示了不属于你代码中的泄露，可以忽略它们。\n堆和栈的内存分配 link对于现在你们这些年轻人来说，编程简直太容易了。如果你玩玩Ruby或者Python的话，只要创建对象或变量就好了，不用管它们存放在哪里。你并不关心它们是否存放在栈上或堆上。你的编程语言甚至完全不会把变量放在栈上，它们都在堆上，并且你也不知道是否是这样。\n然而C完全不一样，因为它使用了CPU真实的机制来完成工作，这涉及到RAM中的一块叫做栈的区域，以及另外一块叫做堆的区域。它们的差异取决于取得储存空间的位置。\n堆更容易解释，因为它就是你电脑中的剩余内存，你可以通过malloc访问它来获取更多内存，OS会使用内部函数为你注册一块内存区域，并且返回指向它的指针。当你使用完这片区域时，你应该使用free把它交还给OS，使之能被其它程序复用。如果你不这样做就会导致程序“泄露”内存，但是Valgrind会帮你监测这些内存泄露。\n栈是一个特殊的内存区域，它储存了每个函数的创建的临时变量，它们对于该函数为局部变量。它的工作机制是，函数的每个函数都会“压入”栈中，并且可在函数内部使用。它是一个真正的栈数据结构，所以是后进先出的。这对于main中所有类似char section和int id的局部变量也是相同的。使用栈的优点是，当函数退出时C编译器会从栈中“弹出”所有变量来清理。这非常简单，也防止了栈上变量的内存泄露。\n理清内存的最简单的方式是遵守这条原则：如果你的变量并不是从malloc中获取的，也不是从一个从malloc获取的函数中获取的，那么它在栈上。\n下面是三个值得关注的关于栈和堆的主要问题：\n如果你从malloc获取了一块内存，并且把指针放在了栈上，那么当函数退出时，指针会被弹出而丢失。 如果你在栈上存放了大量数据（比如大结构体和数组），那么会产生“栈溢出”并且程序会中止。这种情况下应该通过malloc放在堆上。 如果你获取了指向栈上变量的指针，并且将它用于传参或从函数返回，接收它的函数会产生“段错误”。因为实际的数据被弹出而消失，指针也会指向被释放的内存。 这就是我在程序中使用Database_open来分配内存或退出的原因，相应的Database_close用于释放内存。如果你创建了一个“创建”函数，它创建了一些东西，那么一个“销毁”函数可以安全地清理这些东西。这样会更容易理清内存。\n最后，当一个程序退出时，OS会为你清理所有的资源，但是有时不会立即执行。一个惯用法（也是本次练习中用到的）是立即终止并且让OS清理错误。\n如何使它崩溃 link这个程序有很多可以使之崩溃的地方，尝试下面这些东西，同时也想出自己的办法。\n最经典的方法是移除一些安全检查，你就可以传入任意数据。例如，第160行的检查防止你传入任何记录序号。 你也可以尝试弄乱数据文件。使用任何编辑器打开它并且随机修改几个字节并关闭。 你也可以寻找在运行中向程序传递非法参数的办法。例如将文件参数放到动作后面，就会创建一个以动作命名的文件，并且按照文件名的第一个字符执行动作。 这个程序中有个bug，因为strncpy有设计缺陷。查询strncpy的相关资料，然后试着弄清楚如果name或者address超过512个字节会发生什么。可以通过简单把最后一个字符设置成'\\0'来修复它，你应该无论如何都这样做（这也是函数原本应该做的）。 在附加题中我会让你传递参数来创建任意大小的数据库。在你造成程序退出或malloc的内存不足之前，尝试找出最大的数据库尺寸是多少。 附加题 link die函数需要接收conn变量作为参数，以便执行清理并关闭它。\n修改代码，使其接收参数作为MAX_DATA和MAX_ROWS，将它们储存在Database结构体中，并且将它们写到文件。这样就可以创建任意大小的数据库。\n向数据库添加更多操作，比如find。\n查询C如何打包结构体，并且试着弄清楚为什么你的文件是相应的大小。看看你是否可以计算出结构体添加一些字段之后的新大小。\n向Address添加一些字段，使它们可被搜索。\n编写一个shell脚本来通过以正确顺序运行命令执行自动化测试。提示：在bash顶端使用使用set -e，使之在任何命令发生错误时退出。\n译者注：使用Python编写多行脚本或许更方便一些。\n尝试重构程序，使用单一的全局变量来储存数据库连接。这个新版本和旧版本比起来如何？\n搜索“栈数据结构”，并且在你最喜欢的语言中实现它，然后尝试在C中实现。\n"
            }
        );
    index.add(
            {
                id:  28 ,
                href: "\/TechDocs\/docs\/c-guide\/ex18\/",
                title: "练习18：函数指针",
                description: "原文：Exercise 18: Pointers To Functions 译者：飞龙 函数在C中实际上只是指向程序中某一个代码存在位置的指针。就像你创建过的结构体指针、字符串和数组那样，你也可以创建指向函数的指针。函数指针的主要用途是向其他函数传递“回调”，或者模拟类和对象。在这个练习中我们会创建一些回调，并且下一节我们会制作一个简单的对象系统。 函数指针的格式类似这样： int (*POINTER_NAME)(int a, int b) 记住如何编写它的一个方法是： 编写一个普通的函数声明：int callme(int a, int b) 将函数用指针语法包装：int (*callme)(int a, int b) 将名称改成指针名称：int (*compare_cb)(int a, int b) 这个方法的关键是，当你完成这些之后，指针的变量名称为compare_cb，而你可以将它用作函数。这类似于指向数组的指针可以表示所指向的数组。指向函数的指针也可以用作表示所指向的函数，只不过是不同的名字。 int (*tester)(int a, int b) = sorted_order; printf(\"TEST: %d is same as %d\\n\", tester(2, 3), sorted_order(2, 3)); 即使是对于返回指针的函数指针，上述方法依然有效： 编写：char *make_coolness(int awesome_levels) 包装：char *(*make_coolness)(int awesome_levels) 重命名：char *(*coolness_cb)(int awesome_levels) 需要解决的下一个问题是使用函数指针向其它函数提供参数比较困难，比如当你打算向其它函数传递回调函数的时候。解决方法是使用typedef，它是C的一个关键字，可以给其它更复杂的类型起个新的名字。你需要记住的事情是，将typedef添加到相同的指针语法之前，然后你就可以将那个名字用作类型了。我使用下面的代码来演示这一特性： #include #include #include #include /** Our old friend die from ex17.",
                content: " 原文：Exercise 18: Pointers To Functions\n译者：飞龙\n函数在C中实际上只是指向程序中某一个代码存在位置的指针。就像你创建过的结构体指针、字符串和数组那样，你也可以创建指向函数的指针。函数指针的主要用途是向其他函数传递“回调”，或者模拟类和对象。在这个练习中我们会创建一些回调，并且下一节我们会制作一个简单的对象系统。\n函数指针的格式类似这样：\nint (*POINTER_NAME)(int a, int b) 记住如何编写它的一个方法是：\n编写一个普通的函数声明：int callme(int a, int b) 将函数用指针语法包装：int (*callme)(int a, int b) 将名称改成指针名称：int (*compare_cb)(int a, int b) 这个方法的关键是，当你完成这些之后，指针的变量名称为compare_cb，而你可以将它用作函数。这类似于指向数组的指针可以表示所指向的数组。指向函数的指针也可以用作表示所指向的函数，只不过是不同的名字。\nint (*tester)(int a, int b) = sorted_order; printf(\"TEST: %d is same as %d\\n\", tester(2, 3), sorted_order(2, 3)); 即使是对于返回指针的函数指针，上述方法依然有效：\n编写：char *make_coolness(int awesome_levels) 包装：char *(*make_coolness)(int awesome_levels) 重命名：char *(*coolness_cb)(int awesome_levels) 需要解决的下一个问题是使用函数指针向其它函数提供参数比较困难，比如当你打算向其它函数传递回调函数的时候。解决方法是使用typedef，它是C的一个关键字，可以给其它更复杂的类型起个新的名字。你需要记住的事情是，将typedef添加到相同的指针语法之前，然后你就可以将那个名字用作类型了。我使用下面的代码来演示这一特性：\n#include #include #include #include /** Our old friend die from ex17. */ void die(const char *message) { if(errno) { perror(message); } else { printf(\"ERROR: %s\\n\", message); } exit(1); } // a typedef creates a fake type, in this // case for a function pointer typedef int (*compare_cb)(int a, int b); /** * A classic bubble sort function that uses the * compare_cb to do the sorting. */ int *bubble_sort(int *numbers, int count, compare_cb cmp) { int temp = 0; int i = 0; int j = 0; int *target = malloc(count * sizeof(int)); if(!target) die(\"Memory error.\"); memcpy(target, numbers, count * sizeof(int)); for(i = 0; i \u003c count; i++) { for(j = 0; j \u003c count - 1; j++) { if(cmp(target[j], target[j+1]) \u003e 0) { temp = target[j+1]; target[j+1] = target[j]; target[j] = temp; } } } return target; } int sorted_order(int a, int b) { return a - b; } int reverse_order(int a, int b) { return b - a; } int strange_order(int a, int b) { if(a == 0 || b == 0) { return 0; } else { return a % b; } } /** * Used to test that we are sorting things correctly * by doing the sort and printing it out. */ void test_sorting(int *numbers, int count, compare_cb cmp) { int i = 0; int *sorted = bubble_sort(numbers, count, cmp); if(!sorted) die(\"Failed to sort as requested.\"); for(i = 0; i \u003c count; i++) { printf(\"%d \", sorted[i]); } printf(\"\\n\"); free(sorted); } int main(int argc, char *argv[]) { if(argc \u003c 2) die(\"USAGE: ex18 4 3 1 5 6\"); int count = argc - 1; int i = 0; char **inputs = argv + 1; int *numbers = malloc(count * sizeof(int)); if(!numbers) die(\"Memory error.\"); for(i = 0; i \u003c count; i++) { numbers[i] = atoi(inputs[i]); } test_sorting(numbers, count, sorted_order); test_sorting(numbers, count, reverse_order); test_sorting(numbers, count, strange_order); free(numbers); return 0; } 在这段程序中，你将创建动态排序的算法，它会使用比较回调对整数数组排序。下面是这个程序的分解，你应该能够清晰地理解它。\nex18.c:1~6\n通常的包含，用于所调用的所有函数。\nex18.c:7~17\n这就是之前练习的die函数，我将它用于错误检查。\nex18.c:21\n这是使用typedef的地方，在后面我像int或char类型那样，在bubble_sort和test_sorting中使用了compare_cb。\nex18.c:27~49\n一个冒泡排序的实现，它是整数排序的一种不高效的方法。这个函数包含了：\nex18.c:27\n这里是将typedef用于 compare_cb作为cmp最后一个参数的地方。现在它是一个会返回两个整数比较结果用于排序的函数。\nex18.c:29~34\n栈上变量的通常创建语句，前面是使用malloc创建的堆上整数数组。确保你理解了count * sizeof(int)做了什么。\nex18.c:38\n冒泡排序的外循环。\nex18.c:39\n冒泡排序的内循环。\nex18.c:40\n现在我调用了cmp回调，就像一个普通函数那样，但是不通过预先定义好的函数名，而是一个指向它的指针。调用者可以像它传递任何参数，只要这些参数符合compare_cb typedef的签名。\nex18.c:41-43\n冒泡排序所需的实际交换操作。\nex18.c:48\n最后返回新创建和排序过的结果数据target。\nex18.c:51-68\ncompare_cb函数类型三个不同版本，它们需要和我们所创建的typedef具有相同的定义。否则C编辑器会报错说类型不匹配。\nex18.c:74-87\n这是bubble_sort函数的测试。你可以看到我同时将compare_cb传给了bubble_sort来演示它是如何像其它指针一样传递的。\nex18.c:90-103\n一个简单的主函数，基于你通过命令行传递进来的整数，创建了一个数组。然后调用了test_sorting函数。\nex18.c:105-107\n最后，你会看到compare_cb函数指针的typedef是如何使用的。我仅仅传递了sorted_order、reverse_order和strange_order的名字作为函数来调用test_sorting。C编译器会找到这些函数的地址，并且生成指针用于test_sorting。如果你看一眼test_sorting你会发现它把这些函数传给了bubble_sort，并不关心它们是做了什么。只要符合compare_cb原型的东西都有效。\nex18.c:109\n我们在最后释放了我们创建的整数数组。\n你会看到什么 link运行这个程序非常简单，但是你要尝试不同的数字组合，甚至要尝试输入非数字来看看它做了什么：\n$ make ex18 cc -Wall -g ex18.c -o ex18 $ ./ex18 4 1 7 3 2 0 8 0 1 2 3 4 7 8 8 7 4 3 2 1 0 3 4 2 7 1 0 8 $ 如何使它崩溃 link我打算让你做一些奇怪的事情来使它崩溃，这些函数指针都是类似于其它指针的指针，他们都指向内存的一块区域。C中可以将一种指针的指针转换为另一种，以便以不同方式处理数据。这些通常是不必要的，但是为了想你展示如何侵入你的电脑，我希望你把这段代码添加在test_sorting下面：\nunsigned char *data = (unsigned char *)cmp; for(i = 0; i \u003c 25; i++) { printf(\"%02x:\", data[i]); } printf(\"\\n\"); 这个循环将你的函数转换成字符串，并且打印出来它的内容。这并不会中断你的程序，除非CPU和OS在执行过程中遇到了问题。在它打印排序过的数组之后，你所看到的是一个十六进制数字的字符串：\n55:48:89:e5:89:7d:fc:89:75:f8:8b:55:fc:8b:45:f8:29:d0:c9:c3:55:48:89:e5:89: 这就应该是函数的原始的汇编字节码了，你应该能看到它们有相同的起始和不同的结尾。也有可能这个循环并没有获得函数的全部，或者获得了过多的代码而跑到程序的另外一片空间。这些不通过更多分析是不可能知道的。\n附加题 link 用十六进制编辑器打开ex18，接着找到函数起始处的十六进制代码序列，看看是否能在原始程序中找到函数。 在你的十六进制编辑器中找到更多随机出现的东西并修改它们。重新运行你的程序看看发生了什么。字符串是你最容易修改的东西。 将错误的函数传给compare_cb，并看看C编辑器会报告什么错误。 将NULL传给它，看看程序中会发生什么。然后运行Valgrind来看看它会报告什么。 编写另一个排序算法，修改test_sorting使它接收任意的排序函数和排序函数的比较回调。并使用它来测试两种排序算法。 "
            }
        );
    index.add(
            {
                id:  29 ,
                href: "\/TechDocs\/docs\/c-guide\/ex19\/",
                title: "练习19：一个简单的对象系统",
                description: "原文：Exercise 19: A Simple Object System\n译者：飞龙\n我在学习面向对象编程之前学了C，所以它有助于我在C中构建面向对象系统，来理解OOP的基本含义。你可能在学习C之前就学了OOP语言，所以这章也可能会起到一种衔接作用。这个联系中，你将会构建一个简单的对象系统，但是也会了解更多关于C预处理器的事情。\n这个练习会构建一个简单的游戏，在游戏中你会在一个小型的城堡中杀死弥诺陶洛斯，并没有任何神奇之处，只是四个房间和一个坏家伙。这个练习同时是一个多文件的项目，并且比起之前的一些程序看起来更像一个真正的C程序。我在这里介绍C预处理器的原因，是你需要它来在你自己的程序中创建多个文件。\nC预处理器如何工作 linkC预处理器是个模板处理系统，它主要的用途是让C代码的编程更加容易，但是它通过一个语法感知的模板机制来实现。以前人们主要使用C预处理器来储存常量，以及创建“宏”来简化复杂的代码。在现代C语言中你会实际上使用它作为代码生成器来创建模板化的代码片段。\nC预处理器的工作原理是，如果你给它一个文件，比如.c文件，它会处理以#（井号）字符开头的各种文本。当它遇到一个这样的文本时，它会对输入文件中的文本做特定的替换。C预处理器的主要优点是他可以包含其他文件，并且基于该文件的内容对它的宏列表进行扩展。\n一个快速查看预处理器所做事情的方法，是对上个练习中的代码执行下列命令：\ncpp ex18.c | less 这会产生大量输出，但是如果你滚动它，会看到你使用#include包含的其他文件的内容。在原始的代码中向下滚动，你可以看到cpp如何基于头文件中不同的#define宏来转换代码。\nC编译器与cpp的集成十分紧密，这个例子只是向你展示它是如何在背后工作的。在现代C语言中，cpp系统也集成到C的函数中，你或许可以将它当做C语言的一部分。\n在剩余的章节中，我们会使用更多预处理器的语法，并且像往常一样解释它们。\n原型对象系统 link我们所创建的OOP系统是一个简单的“原型”风格的对象系统，很像JavaScript。你将以设置为字段的原型来开始，而不是类，接着将他们用作创建其它对象实例的基础。这个“没有类”的设计比起传统的基于类的对象系统更加易于实现和使用。\nObject头文件 link我打算将数据类型和函数声明放在一个单独的头文件中，叫做object.h。这个是一个标准的C技巧，可以让你集成二进制库，但其它程序员任然需要编译。在这个文件中，我使用了多个高级的C预处理器技巧，我接下来准备简略地描述它们，并且你会在后续的步骤中看到。\n#ifndef _object_h #define _object_h typedef enum { NORTH, SOUTH, EAST, WEST } Direction; typedef struct { char *description; int (*init)(void *self); void (*describe)(void *self); void (*destroy)(void *self); void *(*move)(void *self, Direction direction); int (*attack)(void *self, int damage); } Object; int Object_init(void *self); void Object_destroy(void *self); void Object_describe(void *self); void *Object_move(void *self, Direction direction); int Object_attack(void *self, int damage); void *Object_new(size_t size, Object proto, char *description); #define NEW(T, N) Object_new(sizeof(T), T##Proto, N) #define _(N) proto.",
                content: " 原文：Exercise 19: A Simple Object System\n译者：飞龙\n我在学习面向对象编程之前学了C，所以它有助于我在C中构建面向对象系统，来理解OOP的基本含义。你可能在学习C之前就学了OOP语言，所以这章也可能会起到一种衔接作用。这个联系中，你将会构建一个简单的对象系统，但是也会了解更多关于C预处理器的事情。\n这个练习会构建一个简单的游戏，在游戏中你会在一个小型的城堡中杀死弥诺陶洛斯，并没有任何神奇之处，只是四个房间和一个坏家伙。这个练习同时是一个多文件的项目，并且比起之前的一些程序看起来更像一个真正的C程序。我在这里介绍C预处理器的原因，是你需要它来在你自己的程序中创建多个文件。\nC预处理器如何工作 linkC预处理器是个模板处理系统，它主要的用途是让C代码的编程更加容易，但是它通过一个语法感知的模板机制来实现。以前人们主要使用C预处理器来储存常量，以及创建“宏”来简化复杂的代码。在现代C语言中你会实际上使用它作为代码生成器来创建模板化的代码片段。\nC预处理器的工作原理是，如果你给它一个文件，比如.c文件，它会处理以#（井号）字符开头的各种文本。当它遇到一个这样的文本时，它会对输入文件中的文本做特定的替换。C预处理器的主要优点是他可以包含其他文件，并且基于该文件的内容对它的宏列表进行扩展。\n一个快速查看预处理器所做事情的方法，是对上个练习中的代码执行下列命令：\ncpp ex18.c | less 这会产生大量输出，但是如果你滚动它，会看到你使用#include包含的其他文件的内容。在原始的代码中向下滚动，你可以看到cpp如何基于头文件中不同的#define宏来转换代码。\nC编译器与cpp的集成十分紧密，这个例子只是向你展示它是如何在背后工作的。在现代C语言中，cpp系统也集成到C的函数中，你或许可以将它当做C语言的一部分。\n在剩余的章节中，我们会使用更多预处理器的语法，并且像往常一样解释它们。\n原型对象系统 link我们所创建的OOP系统是一个简单的“原型”风格的对象系统，很像JavaScript。你将以设置为字段的原型来开始，而不是类，接着将他们用作创建其它对象实例的基础。这个“没有类”的设计比起传统的基于类的对象系统更加易于实现和使用。\nObject头文件 link我打算将数据类型和函数声明放在一个单独的头文件中，叫做object.h。这个是一个标准的C技巧，可以让你集成二进制库，但其它程序员任然需要编译。在这个文件中，我使用了多个高级的C预处理器技巧，我接下来准备简略地描述它们，并且你会在后续的步骤中看到。\n#ifndef _object_h #define _object_h typedef enum { NORTH, SOUTH, EAST, WEST } Direction; typedef struct { char *description; int (*init)(void *self); void (*describe)(void *self); void (*destroy)(void *self); void *(*move)(void *self, Direction direction); int (*attack)(void *self, int damage); } Object; int Object_init(void *self); void Object_destroy(void *self); void Object_describe(void *self); void *Object_move(void *self, Direction direction); int Object_attack(void *self, int damage); void *Object_new(size_t size, Object proto, char *description); #define NEW(T, N) Object_new(sizeof(T), T##Proto, N) #define _(N) proto.N #endif 看一看这个文件，你会发现我使用了几个新的语法片段，你之前从来没见过它们：\n#ifndef\n你已经见过了用于创建简单常量的#define，但是C预处理器可以根据条件判断来忽略一部分代码。这里的#ifndef是“如果没有被定义”的意思，它会检查是否已经出现过#define _object_h，如果已出现，就跳过这段代码。我之所以这样写，是因为我们可以将这个文件包含任意次，而无需担心多次定义里面的东西。\n#define\n有了上面保护该文件的#ifndef，我们接着添加_object_h的定义，因此之后任何试图包含此文件的行为，都会由于上面的语句而跳过这段代码。\n#define NEW(T,N)\n这条语句创建了一个宏，就像模板函数一样，无论你在哪里编写左边的代码，都会展开成右边的代码。这条语句仅仅是对我们通常调用的Object_new制作了一个快捷方式，并且避免了潜在的调用错误。在宏这种工作方式下，T、N还有New都被“注入”进了右边的代码中。T##Proto语法表示“将Proto连接到T的末尾”，所以如果你写下NEW(Room, \"Hello.\")，就会在这里变成RoomProto。\n#define _(N)\n这个宏是一种为对象系统设计的“语法糖”，将obj-\u003eproto.blah简写为obj-\u003e_(blah)。它不是必需的，但是它是一个接下来会用到的有趣的小技巧。\nObject源文件 linkobject.h是声明函数和数据类型的地方，它们在object.c中被定义（创建），所以接下来：\n#include #include #include #include \"object.h\" #include void Object_destroy(void *self) { Object *obj = self; if(obj) { if(obj-\u003edescription) free(obj-\u003edescription); free(obj); } } void Object_describe(void *self) { Object *obj = self; printf(\"%s.\\n\", obj-\u003edescription); } int Object_init(void *self) { // do nothing really return 1; } void *Object_move(void *self, Direction direction) { printf(\"You can't go that direction.\\n\"); return NULL; } int Object_attack(void *self, int damage) { printf(\"You can't attack that.\\n\"); return 0; } void *Object_new(size_t size, Object proto, char *description) { // setup the default functions in case they aren't set if(!proto.init) proto.init = Object_init; if(!proto.describe) proto.describe = Object_describe; if(!proto.destroy) proto.destroy = Object_destroy; if(!proto.attack) proto.attack = Object_attack; if(!proto.move) proto.move = Object_move; // this seems weird, but we can make a struct of one size, // then point a different pointer at it to \"cast\" it Object *el = calloc(1, size); *el = proto; // copy the description over el-\u003edescription = strdup(description); // initialize it with whatever init we were given if(!el-\u003einit(el)) { // looks like it didn't initialize properly el-\u003edestroy(el); return NULL; } else { // all done, we made an object of any type return el; } } 这个文件中并没有什么新东西，除了一个小技巧之外。Object_new函数通过把原型放到结构体的开头，利用了structs工作机制的一个方面。当你在之后看到ex19.h头文件时，你会明白为什么我将Object作为结构体的第一个字段。由于C按顺序将字段放入结构体，并且由于指针可以指向一块内存，我就可以将指针转换为任何我想要的东西。在这种情况下，即使我通过calloc获取了一大块内存，我仍然可以使用Object指针来指向它。\n当我开始编写ex19.h文件时，我会把它解释得更详细一些，因为当你看到它怎么用的时候才能更容易去理解它。\n上面的代码创建了基本的对象系统，但是你需要编译它和将它链接到ex19.c文件，来创建出完整的程序。object.c文件本身并没有main函数，所以它不可能被编译为完整的程序。下面是一个Makefile文件，它基于已经完成的事情来构建程序：\nCFLAGS=-Wall -g all: ex19 ex19: object.o clean: rm -f ex19 这个Makefile所做的事情仅仅是让ex19依赖于object.o。还记得make可以根据扩展名构建不同的文件吗？这相当于告诉make执行下列事情：\n当我运行make时，默认的all会构建ex19。 当它构建ex19时，也需要构建object.o，并且将它包含在其中。 make并不能找到object.o，但是它能发现object.c文件，并且知道如何把.c文件变成.o文件，所以它就这么做了。 一旦object.o文件构建完成，它就会运行正确的编译命令，从ex19.c和object.o中构建ex19。 游戏实现 link一旦你编写完成了那些文件，你需要使用对象系统来实现实际的游戏，第一步就是把所有数据类型和函数声明放在ex19.h文件中：\n#ifndef _ex19_h #define _ex19_h #include \"object.h\" struct Monster { Object proto; int hit_points; }; typedef struct Monster Monster; int Monster_attack(void *self, int damage); int Monster_init(void *self); struct Room { Object proto; Monster *bad_guy; struct Room *north; struct Room *south; struct Room *east; struct Room *west; }; typedef struct Room Room; void *Room_move(void *self, Direction direction); int Room_attack(void *self, int damage); int Room_init(void *self); struct Map { Object proto; Room *start; Room *location; }; typedef struct Map Map; void *Map_move(void *self, Direction direction); int Map_attack(void *self, int damage); int Map_init(void *self); #endif 它创建了三个你将会用到的新对象：Monster，Room，和Map。\n看一眼object.c:52，你可以看到这是我使用Object *el = calloc(1, size)的地方。回去看object.h的NEW宏，你可以发现它获得了另一个结构体的sizeof，比如Room，并且分配了这么多的空间。然而，由于我像一个Object指针指向了这块内存，并且我在Room的开头放置了Object proto，所以就可以将Room当成Object来用。\n详细分解请见下面：\n我调用了NEW(Room, \"Hello.\")，C预处理器会将其展开为Object_new(sizeof(Room), RoomProto, \"Hello.\")。 执行过程中，在Object_new的内部我分配了Room大小的一块内存，但是用Object *el来指向它。 由于C将Room.proto字段放在开头，这意味着el指针实际上指向了能访问到完整Object结构体的，足够大小的一块内存。它不知道这块内存叫做proto。 接下来它使用Object *el指针，通过*el = proto来设置这块内存的内容。要记住你可以复制结构体，而且*el的意思是“el所指向对象的值”，所以整条语句意思是“将el所指向对象的值赋为proto”。 由于这个谜之结构体被填充为来自proto的正确数据，这个函数接下来可以在Object上调用init，或者destroy。但是最神奇的一部分是无论谁调用这个函数都可以将它们改为想要的东西。 结合上面这些东西，我就可以使用这一个函数来创建新的类型，并且向它们提供新的函数来修改它们的行为。这看起来像是“黑魔法”，但它是完全有效的C代码。实际上，有少数标准的系统函数也以这种方式工作，我们将会用到一些这样的函数在网络程序中转换地址。\n编写完函数定义和数据结构之后，我现在就可以实现带有四个房间和一个牛头人的游戏了。\n#include #include #include #include #include #include \"ex19.h\" int Monster_attack(void *self, int damage) { Monster *monster = self; printf(\"You attack %s!\\n\", monster-\u003e_(description)); monster-\u003ehit_points -= damage; if(monster-\u003ehit_points \u003e 0) { printf(\"It is still alive.\\n\"); return 0; } else { printf(\"It is dead!\\n\"); return 1; } } int Monster_init(void *self) { Monster *monster = self; monster-\u003ehit_points = 10; return 1; } Object MonsterProto = { .init = Monster_init, .attack = Monster_attack }; void *Room_move(void *self, Direction direction) { Room *room = self; Room *next = NULL; if(direction == NORTH \u0026\u0026 room-\u003enorth) { printf(\"You go north, into:\\n\"); next = room-\u003enorth; } else if(direction == SOUTH \u0026\u0026 room-\u003esouth) { printf(\"You go south, into:\\n\"); next = room-\u003esouth; } else if(direction == EAST \u0026\u0026 room-\u003eeast) { printf(\"You go east, into:\\n\"); next = room-\u003eeast; } else if(direction == WEST \u0026\u0026 room-\u003ewest) { printf(\"You go west, into:\\n\"); next = room-\u003ewest; } else { printf(\"You can't go that direction.\"); next = NULL; } if(next) { next-\u003e_(describe)(next); } return next; } int Room_attack(void *self, int damage) { Room *room = self; Monster *monster = room-\u003ebad_guy; if(monster) { monster-\u003e_(attack)(monster, damage); return 1; } else { printf(\"You flail in the air at nothing. Idiot.\\n\"); return 0; } } Object RoomProto = { .move = Room_move, .attack = Room_attack }; void *Map_move(void *self, Direction direction) { Map *map = self; Room *location = map-\u003elocation; Room *next = NULL; next = location-\u003e_(move)(location, direction); if(next) { map-\u003elocation = next; } return next; } int Map_attack(void *self, int damage) { Map* map = self; Room *location = map-\u003elocation; return location-\u003e_(attack)(location, damage); } int Map_init(void *self) { Map *map = self; // make some rooms for a small map Room *hall = NEW(Room, \"The great Hall\"); Room *throne = NEW(Room, \"The throne room\"); Room *arena = NEW(Room, \"The arena, with the minotaur\"); Room *kitchen = NEW(Room, \"Kitchen, you have the knife now\"); // put the bad guy in the arena arena-\u003ebad_guy = NEW(Monster, \"The evil minotaur\"); // setup the map rooms hall-\u003enorth = throne; throne-\u003ewest = arena; throne-\u003eeast = kitchen; throne-\u003esouth = hall; arena-\u003eeast = throne; kitchen-\u003ewest = throne; // start the map and the character off in the hall map-\u003estart = hall; map-\u003elocation = hall; return 1; } Object MapProto = { .init = Map_init, .move = Map_move, .attack = Map_attack }; int process_input(Map *game) { printf(\"\\n\u003e \"); char ch = getchar(); getchar(); // eat ENTER int damage = rand() % 4; switch(ch) { case -1: printf(\"Giving up? You suck.\\n\"); return 0; break; case 'n': game-\u003e_(move)(game, NORTH); break; case 's': game-\u003e_(move)(game, SOUTH); break; case 'e': game-\u003e_(move)(game, EAST); break; case 'w': game-\u003e_(move)(game, WEST); break; case 'a': game-\u003e_(attack)(game, damage); break; case 'l': printf(\"You can go:\\n\"); if(game-\u003elocation-\u003enorth) printf(\"NORTH\\n\"); if(game-\u003elocation-\u003esouth) printf(\"SOUTH\\n\"); if(game-\u003elocation-\u003eeast) printf(\"EAST\\n\"); if(game-\u003elocation-\u003ewest) printf(\"WEST\\n\"); break; default: printf(\"What?: %d\\n\", ch); } return 1; } int main(int argc, char *argv[]) { // simple way to setup the randomness srand(time(NULL)); // make our map to work with Map *game = NEW(Map, \"The Hall of the Minotaur.\"); printf(\"You enter the \"); game-\u003elocation-\u003e_(describe)(game-\u003elocation); while(process_input(game)) { } return 0; } 说实话这里面并没有很多你没有见过的东西，并且你只需要理解我使用头文件中宏的方法。下面是需要学习和理解的一些重要的核心知识：\n实现一个原型涉及到创建它的函数版本，以及随后创建一个以“Proto”结尾的单一结构体。请参照MonsterProto，RoomProto和MapProto。 由于Object_new的实现方式，如果你没有在你的原型中设置一个函数，它会获得在object.c中创建的默认实现。 在Map_init中我创建了一个微型世界，然而更重要的是我使用了object.h中的NEW宏来创建全部对象。要把这一概念记在脑子里，可以试着把使用NEW的地方替换成Object_new的直接调用，来观察它如何被替换。 使用这些对象涉及到在它们上面调用函数，_(N)为我做了这些事情。如果你观察代码monster-\u003e_(attack)(monster, damage)，你会看到我使用了宏将其替换成monster-\u003eproto.attack(monster, damage)。通过重新将这些调用写成原始形式来再次学习这个转换。另外，如果你被卡住了，手动运行cpp来查看究竟发生了什么。 我使用了两个新的函数srand和rand，它们可以设置一个简单的随机数生成器，对于游戏已经够用了。我也使用了time来初始化随机数生成器。试着研究它们。 我使用了一个新的函数getchar来从标准输入中读取单个字符。试着研究它。 你会看到什么 link下面是我自己的游戏的输出：\n$ make ex19 cc -Wall -g -c -o object.o object.c cc -Wall -g ex19.c object.o -o ex19 $ ./ex19 You enter the The great Hall. \u003e l You can go: NORTH \u003e n You go north, into: The throne room. \u003e l You can go: SOUTH EAST WEST \u003e e You go east, into: Kitchen, you have the knife now. \u003e w You go west, into: The throne room. \u003e s You go south, into: The great Hall. \u003e n You go north, into: The throne room. \u003e w You go west, into: The arena, with the minotaur. \u003e a You attack The evil minotaur! It is still alive. \u003e a You attack The evil minotaur! It is dead! \u003e ^D Giving up? You suck. $ 审计该游戏 link我把所有assert检查留给你作为练习，我通常把它们作为软件的一部分。你已经看到了我如何使用assert来保证程序正确运行。然而现在我希望你返回去并完成下列事情：\n查看你定义的每个函数，一次一个文件。 在每个函数的最上面，添加assert来保证参数正确。例如在Object_new中要添加assert(description != NULL)。 浏览函数的每一行，找到所调用的任何函数。阅读它们的文档（或手册页），确认它们在错误下返回什么。添加另一个断言来检查错误是否发生。例如，Object_new在调用calloc之后应该进行assert(el != NULL)的检查。 如果函数应该返回一个值，也确保它返回了一个错误值（比如NULL），或者添加一个断言来确保返回值是有效的。例如，Object_new中，你需要在最后的返回之前添加assert(el != NULL)，由于它不应该为NULL。 对于每个你编写的if语句，确保都有对应的else语句，除非它用于错误检查并退出。 对于每个你编写的switch语句，确保都有一个default分支，来处理非预期的任何情况。 花费一些时间浏览函数的每一行，并且找到你犯下的任何错误。记住这个练习的要点是从“码农”转变为“黑客”。试着找到使它崩溃的办法，然后尽可能编写代码来防止崩溃或者过早退出。\n附加题 link 修改Makefile文件，使之在执行make clean时能够同时清理object.o。 编写一个测试脚本，能够以多种方式来调用该游戏，并且扩展Makefile使之能够通过运行make test来测试该游戏。 在游戏中添加更多房间和怪物。 把游戏的逻辑放在其它文件中，并把它编译为.o。然后，使用它来编写另一个小游戏。如果你正确编写的话，你会在新游戏中创建新的Map和main函数。 "
            }
        );
    index.add(
            {
                id:  30 ,
                href: "\/TechDocs\/docs\/c-guide\/ex20\/",
                title: "练习20：Zed的强大的调试宏",
                description: "原文：Exercise 20: Zed’s Awesome Debug Macros 译者：飞龙 在C中有一个永恒的问题，它伴随了你很长时间，然而在这个练习我打算使用一系列我开发的宏来解决它。到现在为止你都不知道它们的强大之处，所以你必须使用它们，总有一天你会来找我说，“Zed，这些调试宏真是太伟大了，我应该把我的第一个孩子的出生归功于你，因为你治好了我十年的心脏病，并且打消了我数次想要自杀的念头。真是要谢谢你这样一个好人，这里有一百万美元，和Leo Fender设计的Snakehead Telecaster电吉他的原型。” 是的，它们的确很强大。 C的错误处理问题 link几乎每个编程语言中，错误处理都非常难。有些语言尽可能试图避免错误这个概念，而另一些语言发明了复杂了控制结构，比如异常来传递错误状态。当然的错误大多是因为程序员假定错误不会发生，并且这一乐观的思想影响了他们所用和所创造的语言。 C通过返回错误码或设置全局的errno值来解决这些问题，并且你需要检查这些值。这种机制可以检查现存的复杂代码中，你执行的东西是否发生错误。当你编写更多的C代码时，你应该按照下列模式： 调用函数。 如果返回值出现错误（每次都必须检查）。 清理创建的所有资源。 打印出所有可能有帮助的错误信息。 这意味着对于每一个函数调用（是的，每个函数）你都可能需要多编写3~4行代码来确保它正常功能。这些还不包括清理你到目前创建的所有垃圾。如果你有10个不同的结构体，3个方式。和一个数据库链接，当你发现错误时你应该写额外的14行。 之前这并不是个问题，因为发生错误时，C程序会像你以前做的那样直接退出。你不需要清理任何东西，因为OS会为你自动去做。然而现在很多C程序需要持续运行数周、数月或者数年，并且需要优雅地处理来自于多种资源的错误。你并不能仅仅让你的服务器在首次运行就退出，你也不能让你写的库使使用它的程序退出。这非常糟糕。 其它语言通过异常来解决这个问题，但是这些问题也会在C中出现（其它语言也一样）。在C中你只能够返回一个值，但是异常是基于栈的返回系统，可以返回任意值。C语言中，尝试在栈上模拟异常非常困难，并且其它库也不会兼容。 调试宏 link我使用的解决方案是，使用一系列“调试宏”，它们在C中实现了基本的调试和错误处理系统。这个系统非常易于理解，兼容于每个库，并且使C代码更加健壮和简洁。 它通过实现一系列转换来处理错误，任何时候发生了错误，你的函数都会跳到执行清理和返回错误代码的“error:”区域。你可以使用check宏来检查错误代码，打印错误信息，然后跳到清理区域。你也可以使用一系列日志函数来打印出有用的调试信息。 我现在会向你展示你目前所见过的，最强大且卓越的代码的全部内容。 #ifndef __dbg_h__ #define __dbg_h__ #include #include #include #ifdef NDEBUG #define debug(M, ...) #else #define debug(M, ...) fprintf(stderr, \"DEBUG %s:%d: \" M \"\\n\", __FILE__, __LINE__, ##__VA_ARGS__) #endif #define clean_errno() (errno == 0 ? \"None\" : strerror(errno)) #define log_err(M, ...) fprintf(stderr, \"[ERROR] (%s:%d: errno: %s) \" M \"\\n\", __FILE__, __LINE__, clean_errno(), ##__VA_ARGS__) #define log_warn(M, .",
                content: " 原文：Exercise 20: Zed’s Awesome Debug Macros\n译者：飞龙\n在C中有一个永恒的问题，它伴随了你很长时间，然而在这个练习我打算使用一系列我开发的宏来解决它。到现在为止你都不知道它们的强大之处，所以你必须使用它们，总有一天你会来找我说，“Zed，这些调试宏真是太伟大了，我应该把我的第一个孩子的出生归功于你，因为你治好了我十年的心脏病，并且打消了我数次想要自杀的念头。真是要谢谢你这样一个好人，这里有一百万美元，和Leo Fender设计的Snakehead Telecaster电吉他的原型。”\n是的，它们的确很强大。\nC的错误处理问题 link几乎每个编程语言中，错误处理都非常难。有些语言尽可能试图避免错误这个概念，而另一些语言发明了复杂了控制结构，比如异常来传递错误状态。当然的错误大多是因为程序员假定错误不会发生，并且这一乐观的思想影响了他们所用和所创造的语言。\nC通过返回错误码或设置全局的errno值来解决这些问题，并且你需要检查这些值。这种机制可以检查现存的复杂代码中，你执行的东西是否发生错误。当你编写更多的C代码时，你应该按照下列模式：\n调用函数。 如果返回值出现错误（每次都必须检查）。 清理创建的所有资源。 打印出所有可能有帮助的错误信息。 这意味着对于每一个函数调用（是的，每个函数）你都可能需要多编写3~4行代码来确保它正常功能。这些还不包括清理你到目前创建的所有垃圾。如果你有10个不同的结构体，3个方式。和一个数据库链接，当你发现错误时你应该写额外的14行。\n之前这并不是个问题，因为发生错误时，C程序会像你以前做的那样直接退出。你不需要清理任何东西，因为OS会为你自动去做。然而现在很多C程序需要持续运行数周、数月或者数年，并且需要优雅地处理来自于多种资源的错误。你并不能仅仅让你的服务器在首次运行就退出，你也不能让你写的库使使用它的程序退出。这非常糟糕。\n其它语言通过异常来解决这个问题，但是这些问题也会在C中出现（其它语言也一样）。在C中你只能够返回一个值，但是异常是基于栈的返回系统，可以返回任意值。C语言中，尝试在栈上模拟异常非常困难，并且其它库也不会兼容。\n调试宏 link我使用的解决方案是，使用一系列“调试宏”，它们在C中实现了基本的调试和错误处理系统。这个系统非常易于理解，兼容于每个库，并且使C代码更加健壮和简洁。\n它通过实现一系列转换来处理错误，任何时候发生了错误，你的函数都会跳到执行清理和返回错误代码的“error:”区域。你可以使用check宏来检查错误代码，打印错误信息，然后跳到清理区域。你也可以使用一系列日志函数来打印出有用的调试信息。\n我现在会向你展示你目前所见过的，最强大且卓越的代码的全部内容。\n#ifndef __dbg_h__ #define __dbg_h__ #include #include #include #ifdef NDEBUG #define debug(M, ...) #else #define debug(M, ...) fprintf(stderr, \"DEBUG %s:%d: \" M \"\\n\", __FILE__, __LINE__, ##__VA_ARGS__) #endif #define clean_errno() (errno == 0 ? \"None\" : strerror(errno)) #define log_err(M, ...) fprintf(stderr, \"[ERROR] (%s:%d: errno: %s) \" M \"\\n\", __FILE__, __LINE__, clean_errno(), ##__VA_ARGS__) #define log_warn(M, ...) fprintf(stderr, \"[WARN] (%s:%d: errno: %s) \" M \"\\n\", __FILE__, __LINE__, clean_errno(), ##__VA_ARGS__) #define log_info(M, ...) fprintf(stderr, \"[INFO] (%s:%d) \" M \"\\n\", __FILE__, __LINE__, ##__VA_ARGS__) #define check(A, M, ...) if(!(A)) { log_err(M, ##__VA_ARGS__); errno=0; goto error; } #define sentinel(M, ...) { log_err(M, ##__VA_ARGS__); errno=0; goto error; } #define check_mem(A) check((A), \"Out of memory.\") #define check_debug(A, M, ...) if(!(A)) { debug(M, ##__VA_ARGS__); errno=0; goto error; } #endif 是的，这就是全部代码了，下面是它每一行所做的事情。\ndbg.h:1-2\n防止意外包含多次的保护措施，你已经在上一个练习中见过了。\ndbg.h:4-6\n包含这些宏所需的函数。\ndbg.h:8\n#ifdef的起始，它可以让你重新编译程序来移除所有调试日志信息。\ndbg.h:9\n如果你定义了NDEBUG之后编译，没有任何调试信息会输出。你可以看到#define debug()被替换为空（右边没有任何东西）。\ndbg.h:10\n上面的#ifdef所匹配的#else。\ndbg.h:11\n用于替代的#define debug，它将任何使用debug(\"format\", arg1, arg2)的地方替换成fprintf对stderr的调用。许多程序员并不知道，但是你的确可以创建与printf类似的可变参数宏。许多C编译器（实际上是C预处理器）并不支持它，但是gcc可以做到。这里的魔法是使用##__VA_ARGS__，意思是将剩余的所有额外参数放到这里。同时也要注意，使用了__FILE__和__LINE__来获取当前fine:line用于调试信息。这会非常有帮助。\ndbg.h:12\n#ifdef的结尾。\ndbg.h:14\nclean_errno宏用于获取errno的安全可读的版本。中间奇怪的语法是“三元运算符”，你会在后面学到它。\ndbg.h:16-20\nlog_err，log_warn和log_info宏用于为最终用户记录信息。它们类似于debug但不能被编译。\ndbg.h:22\n到目前为止最棒的宏。check会保证条件A为真，否则会记录错误M（带着log_err的可变参数），之后跳到函数的error:区域来执行清理。\ndbg.h:24\n第二个最棒的宏，sentinel可以放在函数的任何不应该执行的地方，它会打印错误信息并且跳到error:标签。你可以将它放到if-statements或者switch-statements的不该被执行的分支中，比如default。\ndbg.h:26\n简写的check_mem宏，用于确保指针有效，否则会报告“内存耗尽”的错误。\ndbg.h:28\n用于替代的check_debug宏，它仍然会检查并处理错误，尤其是你并不想报告的普遍错误。它里面使用了debug代替log_err来报告错误，所以当你定义了NDEBUG，它仍然会检查并且发生错误时跳出，但是不会打印消息了。\n使用dbg.h link下面是一个例子，在一个小的程序中使用了dbg.h的所有函数。这实际上并没有做什么事情，只是向你演示了如何使用每个宏。我们将在接下来的所有程序中使用这些宏，所有要确保理解了如何使用它们。\n#include \"dbg.h\" #include #include void test_debug() { // notice you don't need the \\n debug(\"I have Brown Hair.\"); // passing in arguments like printf debug(\"I am %d years old.\", 37); } void test_log_err() { log_err(\"I believe everything is broken.\"); log_err(\"There are %d problems in %s.\", 0, \"space\"); } void test_log_warn() { log_warn(\"You can safely ignore this.\"); log_warn(\"Maybe consider looking at: %s.\", \"/etc/passwd\"); } void test_log_info() { log_info(\"Well I did something mundane.\"); log_info(\"It happened %f times today.\", 1.3f); } int test_check(char *file_name) { FILE *input = NULL; char *block = NULL; block = malloc(100); check_mem(block); // should work input = fopen(file_name,\"r\"); check(input, \"Failed to open %s.\", file_name); free(block); fclose(input); return 0; error: if(block) free(block); if(input) fclose(input); return -1; } int test_sentinel(int code) { char *temp = malloc(100); check_mem(temp); switch(code) { case 1: log_info(\"It worked.\"); break; default: sentinel(\"I shouldn't run.\"); } free(temp); return 0; error: if(temp) free(temp); return -1; } int test_check_mem() { char *test = NULL; check_mem(test); free(test); return 1; error: return -1; } int test_check_debug() { int i = 0; check_debug(i != 0, \"Oops, I was 0.\"); return 0; error: return -1; } int main(int argc, char *argv[]) { check(argc == 2, \"Need an argument.\"); test_debug(); test_log_err(); test_log_warn(); test_log_info(); check(test_check(\"ex20.c\") == 0, \"failed with ex20.c\"); check(test_check(argv[1]) == -1, \"failed with argv\"); check(test_sentinel(1) == 0, \"test_sentinel failed.\"); check(test_sentinel(100) == -1, \"test_sentinel failed.\"); check(test_check_mem() == -1, \"test_check_mem failed.\"); check(test_check_debug() == -1, \"test_check_debug failed.\"); return 0; error: return 1; } 要注意check是如何使用的，并且当它为false时会跳到error:标签来执行清理。这一行读作“检查A是否为真，不为真就打印M并跳出”。\n你会看到什么 link当你执行这段代码并且向第一个参数提供一些东西，你会看到：\n$ make ex20 cc -Wall -g -DNDEBUG ex20.c -o ex20 $ ./ex20 test [ERROR] (ex20.c:16: errno: None) I believe everything is broken. [ERROR] (ex20.c:17: errno: None) There are 0 problems in space. [WARN] (ex20.c:22: errno: None) You can safely ignore this. [WARN] (ex20.c:23: errno: None) Maybe consider looking at: /etc/passwd. [INFO] (ex20.c:28) Well I did something mundane. [INFO] (ex20.c:29) It happened 1.300000 times today. [ERROR] (ex20.c:38: errno: No such file or directory) Failed to open test. [INFO] (ex20.c:57) It worked. [ERROR] (ex20.c:60: errno: None) I shouldn't run. [ERROR] (ex20.c:74: errno: None) Out of memory. 看到check失败之后，它是如何打印具体的行号了吗？这会为接下来的调试工作节省时间。同时也观察errno被设置时它如何打印错误信息。同样，这也可以节省你调试的时间。\nC预处理器如何扩展宏 link现在我会向你简单介绍一些预处理器的工作原理，让你知道这些宏是如何工作的。我会拆分dbg.h中阿最复杂的宏并且让你运行cpp来让你观察它实际上是如何工作的。\n假设我有一个函数叫做dosomething()，执行成功是返回0，发生错误时返回-1。每次我调用dosomething的时候，我都要检查错误码，所以我将代码写成这样：\nint rc = dosomething(); if(rc != 0) { fprintf(stderr, \"There was an error: %s\\n\", strerror()); goto error; } 我想使用预处理器做的是，将这个if语句封装为更可读并且便于记忆的一行代码。于是可以使用这个check来执行dbg.h中的宏所做的事情：\nint rc = dosomething(); check(rc == 0, \"There was an error.\"); 这样更加简洁，并且恰好解释了所做的事情：检查函数是否正常工作，如果没有就报告错误。我们需要一些特别的预处理器“技巧”来完成它，这些技巧使预处理器作为代码生成工具更加易用。再次看看check和log_err宏：\n#define log_err(M, ...) fprintf(stderr, \"[ERROR] (%s:%d: errno: %s) \" M \"\\n\", __FILE__, __LINE__, clean_errno(), ##__VA_ARGS__) #define check(A, M, ...) if(!(A)) { log_err(M, ##__VA_ARGS__); errno=0; goto error; } 第一个宏，log_err更简单一些，只是将它自己替换为fprintf对stderr的调用。这个宏唯一的技巧性部分就是在log_err(M, ...)的定义中使用...。它所做的是让你向宏传入可变参数，从而传入fprintf需要接收的参数。它们是如何注入fprintf的呢？观察末尾的##__VA_ARGS__，它告诉预处理器将...所在位置的参数注入到fprintf调用的相应位置。于是你可以像这样调用了：\nlog_err(\"Age: %d, name: %s\", age, name); age, name参数就是...所定义的部分，这些参数会被注入到fprintf中，输出会变成：\nfprintf(stderr, \"[ERROR] (%s:%d: errno: %s) Age %d: name %d\\n\", __FILE__, __LINE__, clean_errno(), age, name); 看到末尾的age, name了吗？这就是...和##__VA_ARGS__的工作机制，在调用其它变参宏（或者函数）的时候它会起作用。观察check宏调用log_err的方式，它也是用了...和##__VA_ARGS__。这就是传递整个printf风格的格式字符串给check的途径，它之后会传给log_err，二者的机制都像printf一样。\n下一步是学习check如何为错误检查构造if语句，如果我们剖析log_err的用法，我们会得到：\nif(!(A)) { errno=0; goto error; } 它的意思是，如果A为假，则重置errno并且调用error标签。check宏会被上述if语句·替换，所以如果我们手动扩展check(rc == 0, \"There was an error.\")，我们会得到：\nif(!(rc == 0)) { log_err(\"There was an error.\"); errno=0; goto error; } 在这两个宏的展开过程中，你应该了解了预处理器会将宏替换为它的定义的扩展版本，并且递归地来执行这个步骤，扩展宏定义中的宏。预处理器是个递归的模板系统，就像我之前提到的那样。它的强大来源于使用参数化的代码来生成整个代码块，这使它成为便利的代码生成工具。\n下面只剩一个问题了：为什么不像die一样使用函数呢？原因是需要在错误处理时使用file:line的数值和goto操作。如果你在函数在内部执行这些，你不会得到错误真正出现位置的行号，并且goto的实现也相当麻烦。\n另一个原因是，如果你编写原始的if语句，它看起来就像是你代码中的其它的if语句，所以它看起来并不像一个错误检查。通过将if语句包装成check宏，就会使这一错误检查的逻辑更清晰，而不是主控制流的一部分。\n最后，C预处理器提供了条件编译部分代码的功能，所以你可以编写只在构建程序的开发或调试版本时需要的代码。你可以看到这在dbg.h中已经用到了，debug宏的主体部分只被编译器用到。如果没有这个功能，你需要多出一个if语句来检查是否为“调试模式”，也浪费了CPU资源来进行没有必要的检查。\n附加题 link 将#define NDEBUG放在文件顶端来消除所有调试信息。 撤销上面添加的一行，并在MakeFile顶端将-D NDEBUG添加到CFLAGS，之后重新编译来达到同样效果。 修改日志宏，使之包含函数名称和file:line。 "
            }
        );
    index.add(
            {
                id:  31 ,
                href: "\/TechDocs\/docs\/c-guide\/ex21\/",
                title: "练习21：高级数据类型和控制结构",
                description: "原文：Exercise 21: Advanced Data Types And Flow Control\n译者：飞龙\n这个练习是C语言中所有可用的数据类型和控制结构的摘要。它也可以作为一份参考在补完你的知识，并且不含有任何代码。我会通过创建教学卡片的方式，让你记住一些信息，所以你会在脑子里记住所有重要的概念。\n这个练习非常有用，你应该花至少一周的时间来巩固内容并且补全这里所没有的元素。你应学出每个元素是什么意思，以及编写程序来验证你得出的结论。\n可用的数据类型 linkint\n储存普通的整数，默认为32位大小。\n译者注：int在32或64位环境下为32位，但它不应该被看作平台无关的。如果需要用到平台无关的定长整数，请使用int(n)_t。\ndouble\n储存稍大的浮点数。\nfloat\n储存稍小的浮点数。\nchar\n储存单字节字符。\nvoid\n表示“无类型”，用于声明不返回任何东西的函数，或者所指类型不明的指针，例如void *thing。\nenum\n枚举类型，类似于整数，也可转换为整数，但是通过符号化的名称访问或设置。当switch语句中没有覆盖到所有枚举的元素时，一些编译器会发出警告。\n类型修饰符 linkunsigned\n修改类型，使它不包含任何负数，同时上界变高。\nsigned\n可以储存正数和负数，但是上界会变为（大约）一半，下界变为和上界（大约）等长。\n译者注：符号修饰符只对char和*** int有效。*** int默认为signed，而char根据具体实现，可以默认为signed，也可以为unsigned。\nlong\n对该类型使用较大的空间，使它能存下更大的数，通常使当前大小加倍。\nshort\n对该类型使用较小的空间，使它储存能力变小，但是占据空间也变成一半。\n类型限定符 linkconst\n表示变量在初始化后不能改变。\nvolatile\n表示会做最坏的打算，编译器不会对它做任何优化。通常仅在对变量做一些奇怪的事情时，才会用到它。\nregister\n强制让编译器将这个变量保存在寄存器中，并且也可以无视它。目前的编译器更善于处理在哪里存放变量，所以应该只在确定这样会提升性能时使用它。\n类型转换 linkC使用了一种“阶梯形类型提升”的机制，它会观察运算符两边的变量，并且在运算之前将较小边的变量转换为较大边。这个过程按照如下顺序：\nlong double double float long long long int (short, char) 译者注：short和char会在运算之前转换成int。同种类型的unsigned和signed运算，signed保持字节不变转换成unsigned。\n类型大小 linkstdint.h为定长的整数类型定义了一些typedef，同时也有一些用于这些类型的宏。这比老的limits.h更加易于使用，因为它是不变的。这些类型如下：\nint8_t\n8位符号整数。\nuint8_t\n8位无符号整数。\nint16_t\n16位符号整数。\nuint16_t\n16位无符号整数。\nint32_t",
                content: " 原文：Exercise 21: Advanced Data Types And Flow Control\n译者：飞龙\n这个练习是C语言中所有可用的数据类型和控制结构的摘要。它也可以作为一份参考在补完你的知识，并且不含有任何代码。我会通过创建教学卡片的方式，让你记住一些信息，所以你会在脑子里记住所有重要的概念。\n这个练习非常有用，你应该花至少一周的时间来巩固内容并且补全这里所没有的元素。你应学出每个元素是什么意思，以及编写程序来验证你得出的结论。\n可用的数据类型 linkint\n储存普通的整数，默认为32位大小。\n译者注：int在32或64位环境下为32位，但它不应该被看作平台无关的。如果需要用到平台无关的定长整数，请使用int(n)_t。\ndouble\n储存稍大的浮点数。\nfloat\n储存稍小的浮点数。\nchar\n储存单字节字符。\nvoid\n表示“无类型”，用于声明不返回任何东西的函数，或者所指类型不明的指针，例如void *thing。\nenum\n枚举类型，类似于整数，也可转换为整数，但是通过符号化的名称访问或设置。当switch语句中没有覆盖到所有枚举的元素时，一些编译器会发出警告。\n类型修饰符 linkunsigned\n修改类型，使它不包含任何负数，同时上界变高。\nsigned\n可以储存正数和负数，但是上界会变为（大约）一半，下界变为和上界（大约）等长。\n译者注：符号修饰符只对char和*** int有效。*** int默认为signed，而char根据具体实现，可以默认为signed，也可以为unsigned。\nlong\n对该类型使用较大的空间，使它能存下更大的数，通常使当前大小加倍。\nshort\n对该类型使用较小的空间，使它储存能力变小，但是占据空间也变成一半。\n类型限定符 linkconst\n表示变量在初始化后不能改变。\nvolatile\n表示会做最坏的打算，编译器不会对它做任何优化。通常仅在对变量做一些奇怪的事情时，才会用到它。\nregister\n强制让编译器将这个变量保存在寄存器中，并且也可以无视它。目前的编译器更善于处理在哪里存放变量，所以应该只在确定这样会提升性能时使用它。\n类型转换 linkC使用了一种“阶梯形类型提升”的机制，它会观察运算符两边的变量，并且在运算之前将较小边的变量转换为较大边。这个过程按照如下顺序：\nlong double double float long long long int (short, char) 译者注：short和char会在运算之前转换成int。同种类型的unsigned和signed运算，signed保持字节不变转换成unsigned。\n类型大小 linkstdint.h为定长的整数类型定义了一些typedef，同时也有一些用于这些类型的宏。这比老的limits.h更加易于使用，因为它是不变的。这些类型如下：\nint8_t\n8位符号整数。\nuint8_t\n8位无符号整数。\nint16_t\n16位符号整数。\nuint16_t\n16位无符号整数。\nint32_t\n32位符号整数。\nuint32_t\n32位无符号整数。\nint64_t\n64位符号整数。\nuint64_t\n64位无符号整数。\n译者注：当用于对类型大小有要求的特定平台时，可以使用这些类型。如果你怕麻烦，不想处理平台相关类型的今后潜在的扩展的话，也可以使用这些类型。\n下面的模式串为(u)int(BITS)_t，其中前面的u代表unsigned，BITS是所占位数的大小。这些模式串返回了这些类型的最大（或最小）值。\nINT(N)_MAX\nN位符号整数的最大正值，例如INT16_MAX。\nINT(N)_MIN\nN位符号整数的最小负值。\nUINT(N)_MAX\nN位无符号整数的最大正值。为什么不定义其最小值，是因为最小值是0，不可能出现负值。\n警告\n要注意，不要从字面上在任何头文件中去找INT(N)_MAX的定义。这里的N应该为特定整数，比如8、16、32、64，甚至可能是128。我在这个练习中使用了这个记法，就不需要显式写出每一个不同的组合了。\n在stdint.h中，对于size_t类型和足够存放指针的整数也有一些宏定义，以及其它便捷类型的宏定义。编译器至少要保证它们为某一大小，并允许它们为更大的大小。\nint_least(N)_t\n至少N位的整数。\nuint_least(N)_t\n至少N位的无符号整数。\nINT_LEAST(N)_MAX\nint_least(N)_t类型的最大值。\nINT_LEAST(N)_MIN\nint_least(N)_t类型的最小值。\nUINT_LEAST(N)_MAX\nuint_least(N)_t的最大值。\nint_fast(N)_t\n与int_least(N)_t相似，但是是至少N位的“最快”整数。\nuint_fast(N)_t\n至少N位的“最快”无符号整数。\nINT_FAST(N)_MAX\nint_fast(N)_t的最大值。\nINT_FAST(N)_MIN\nint_fast(N)_t的最小值。\nUINT_FAST(N)_MAX\nuint_fast(N)_t的最大值。\nintptr_t\n足够存放指针的符号整数。\nuintptr_t\n足够存放指针的无符号整数。\nINTPTR_MAX\nintptr_t的最大值。\nINTPTR_MIN\nintptr_t的最小值。\nUINTPTR_MAX\nuintptr_t的最大值。\nintmax_t\n系统中可能的最大尺寸的整数类型。\nuintmax_t\n系统中可能的最大尺寸的无符号整数类型。\nINTMAX_MAX\nintmax_t的最大值。\nINTMAX_MIN\nintmax_t的最小值。\nUINTMAX_MAX\nuintmax_t的最大值。\nPTRDIFF_MIN\nptrdiff_t的最小值。\nPTRDIFF_MAX\nptrdiff_t的最大值。\nSIZE_MAX\nsize_t的最大值。\n可用的运算符 link这是一个全面的列表，关于你可以在C中使用的全部运算符。这个列表中我会标明一些东西：\n二元\n该运算符有左右两个操作数：X + Y。\n一元\n该运算符作用于操作数本身-X。\n前缀\n该运算符出现在操作数之前：++X。\n后缀\n通常和前缀版本相似，但是出现在操作数之后，并且意义不同：X++。\n三元\n只有一个三元运算符，意思是“三个操作数”：X ? Y : Z。\n算数运算符 link下面是基本的算数运算符，我将函数调用()放入其中因为它更接近“算数”运算。\n()\n函数调用。\n二元 *\n乘法。\n/\n除法。\n二元 +\n加法。\n一元 +\n无变化。\n后缀 ++\n读取变量然后自增。\n前缀 ++\n自增变量然后读取。\n后缀 --\n读取变量然后自减。\n前缀 --\n自减变量然后读取。\n二元 -\n减法。\n一元 -\n取反，可用于表示负数。\n数据运算 link它们用于以不同方式和形式访问数据。\n-\u003e\n结构体指针的成员访问。一元*和.运算符的复合。\n.\n结构体值的成员访问。\n[]\n取数组下标。二元+和一元*运算符的复合。\nsizeof\n取类型或变量大小。\n一元 \u0026\n取地址。\n一元 *\n取值（提领地址）。\n逻辑运算符 link它们用于测试变量的等性和不等性。\n!=\n不等于。\n\u003c\n小于。\n\u003c=\n小于等于。\n==\n等于（并不是赋值）。\n\u003e\n大于。\n\u003e=\n大于等于。\n位运算符 link它们更加高级，用于修改整数的原始位。\n二元 \u0026\n位与。\n\u003c\u003c\n左移。\n\u003e\u003e\n右移。\n^\n位异或。\n|\n位或。\n~\n取补（翻转所有位）。\n布尔运算符。 link用于真值测试，仔细学习三元运算符，它非常有用。\n!\n取非。\n\u0026\u0026\n与。\n||\n或。\n?:\n三元真值测试，X ? Y : Z读作“若X则Y否则Z”。\n赋值运算符 link复合赋值运算符在赋值同时执行运算。大多数上面的运算符都可以组成复合赋值运算符。\n=\n赋值。\n%=\n取余赋值。\n\u0026=\n位与赋值。\n*=\n乘法赋值。\n+=\n加法赋值。\n-=\n减法赋值。\n/=\n除法赋值。\n\u003c\u003c=\n左移赋值。\n\u003e\u003e=\n右移赋值。\n^=\n位异或赋值。\n|=\n位或赋值。\n可用的控制结构 link下面是一些你没有接触过的控制结构：\ndo-while\ndo { ... } while(X);首先执行花括号中的代码，之后再跳出前测试X表达式。\nbreak\n放在循环中用于跳出循环。\ncontinue\n跳到循环尾。\ngoto\n跳到你已经放置label的位置，你已经在dbg.h中看到它了，用于跳到error标签。\n附加题 link 阅读stdint.h或它的描述，写出所有可能出现的大小定义。 查询本练习的每一项，写出它在代码中的作用。上网浏览资料来研究它如何正确使用。 将这些信息做成教学卡片，每天看上15分钟来记住它们。 创建一个程序，打印出每个类型的示例，并验证你的研究结果是否正确。 "
            }
        );
    index.add(
            {
                id:  32 ,
                href: "\/TechDocs\/docs\/c-guide\/ex22\/",
                title: "练习22：栈、作用域和全局",
                description: "原文：Exercise 22: The Stack, Scope, And Globals\n译者：飞龙\n许多人在开始编程时，对“作用域”这个概念都不是很清楚。起初它来源于系统栈的使用方式（在之前提到过一些），以及它用于临时变量储存的方式。这个练习中，我们会通过学习栈数据结构如何工作来了解作用域，然后再来看看现代C语言处理作用域的方式。\n这个练习的真正目的是了解一些比较麻烦的东西在C中如何存储。当一个人没有掌握作用域的概念时，它几乎也不能理解变量在哪里被创建，存在以及销毁。一旦你知道了这些，作用域的概念会变得易于理解。\n这个练习需要如下三个文件：\nex22.h\n用于创建一些外部变量和一些函数的头文件。\nex22.c\n它并不像通常一样，是包含main的源文件，而是含有一些ex22.h中声明的函数和变量，并且会变成ex22.o。\nex22_main.c\nmain函数实际所在的文件，它会包含另外两个文件，并演示了它们包含的东西以及其它作用域概念。\nex22.h 和 ex22.c link你的第一步是创建你自己的ex22.h头文件，其中定义了所需的函数和“导出”变量。\n#ifndef _ex22_h #define _ex22_h // makes THE_SIZE in ex22.c available to other .c files extern int THE_SIZE; // gets and sets an internal static variable in ex22.c int get_age(); void set_age(int age); // updates a static variable that's inside update_ratio double update_ratio(double ratio); void print_size(); #endif 最重要的事情是extern int THE_SIZE的用法，我将会在你创建完ex22.",
                content: " 原文：Exercise 22: The Stack, Scope, And Globals\n译者：飞龙\n许多人在开始编程时，对“作用域”这个概念都不是很清楚。起初它来源于系统栈的使用方式（在之前提到过一些），以及它用于临时变量储存的方式。这个练习中，我们会通过学习栈数据结构如何工作来了解作用域，然后再来看看现代C语言处理作用域的方式。\n这个练习的真正目的是了解一些比较麻烦的东西在C中如何存储。当一个人没有掌握作用域的概念时，它几乎也不能理解变量在哪里被创建，存在以及销毁。一旦你知道了这些，作用域的概念会变得易于理解。\n这个练习需要如下三个文件：\nex22.h\n用于创建一些外部变量和一些函数的头文件。\nex22.c\n它并不像通常一样，是包含main的源文件，而是含有一些ex22.h中声明的函数和变量，并且会变成ex22.o。\nex22_main.c\nmain函数实际所在的文件，它会包含另外两个文件，并演示了它们包含的东西以及其它作用域概念。\nex22.h 和 ex22.c link你的第一步是创建你自己的ex22.h头文件，其中定义了所需的函数和“导出”变量。\n#ifndef _ex22_h #define _ex22_h // makes THE_SIZE in ex22.c available to other .c files extern int THE_SIZE; // gets and sets an internal static variable in ex22.c int get_age(); void set_age(int age); // updates a static variable that's inside update_ratio double update_ratio(double ratio); void print_size(); #endif 最重要的事情是extern int THE_SIZE的用法，我将会在你创建完ex22.c之后解释它：\n#include #include \"ex22.h\" #include \"dbg.h\" int THE_SIZE = 1000; static int THE_AGE = 37; int get_age() { return THE_AGE; } void set_age(int age) { THE_AGE = age; } double update_ratio(double new_ratio) { static double ratio = 1.0; double old_ratio = ratio; ratio = new_ratio; return old_ratio; } void print_size() { log_info(\"I think size is: %d\", THE_SIZE); } 这两个文件引入了一些新的变量储存方式：\nextern\n这个关键词告诉编译器“这个变量已存在，但是他在别的‘外部区域’里”。通常它的意思是一个.c文件要用到另一个.c文件中定义的变量。这种情况下，我们可以说ex22.c中的THE_SIZE变量能被ex22_main.c访问到。\nstatic（文件）\n这个关键词某种意义上是extern的反义词，意思是这个变量只能在当前的.c文件中使用，程序的其它部分不可访问。要记住文件级别的static（比如这里的THE_AGE）和其它位置不同。\nstatic（函数）\n如果你使用static在函数中声明变量，它和文件中的static定义类似，但是只能够在该函数中访问。它是一种创建某个函数的持续状态的方法，但事实上它很少用于现代的C语言，因为它们很难和线程一起使用。\n在上面的两个文件中，你需要理解如下几个变量和函数：\nTHE_SIZE\n这个你使用extern声明的变量将会在ex22_main.c中用到。\nget_age和set_age\n它们用于操作静态变量THE_AGE，并通过函数将其暴露给程序的其它部分。你不能够直接访问到THE_AGE，但是这些函数可以。\nupdate_ratio\n它生成新的ratio值并返回旧的值。它使用了函数级的静态变量ratio来跟踪ratio当前的值。\nprint_size\n打印出ex22.c所认为的THE_SIZE的当前值。\nex22_main.c link一旦你写完了上面那些文件，你可以接着编程main函数，它会使用所有上面的文件并且演示了一些更多的作用域转换：\n#include \"ex22.h\" #include \"dbg.h\" const char *MY_NAME = \"Zed A. Shaw\"; void scope_demo(int count) { log_info(\"count is: %d\", count); if(count \u003e 10) { int count = 100; // BAD! BUGS! log_info(\"count in this scope is %d\", count); } log_info(\"count is at exit: %d\", count); count = 3000; log_info(\"count after assign: %d\", count); } int main(int argc, char *argv[]) { // test out THE_AGE accessors log_info(\"My name: %s, age: %d\", MY_NAME, get_age()); set_age(100); log_info(\"My age is now: %d\", get_age()); // test out THE_SIZE extern log_info(\"THE_SIZE is: %d\", THE_SIZE); print_size(); THE_SIZE = 9; log_info(\"THE SIZE is now: %d\", THE_SIZE); print_size(); // test the ratio function static log_info(\"Ratio at first: %f\", update_ratio(2.0)); log_info(\"Ratio again: %f\", update_ratio(10.0)); log_info(\"Ratio once more: %f\", update_ratio(300.0)); // test the scope demo int count = 4; scope_demo(count); scope_demo(count * 20); log_info(\"count after calling scope_demo: %d\", count); return 0; } 我会把这个文件逐行拆分，你应该能够找到我提到的每个变量在哪里定义。\nex22_main.c:4\n使用了const来创建常量，它可用于替代define来创建常量。\nex22_main.c:6\n一个简单的函数，演示了函数中更多的作用域问题。\nex22_main.c:8\n在函数顶端打印出count的值。\nex22_main.c:10\nif语句会开启一个新的作用域区块，并且在其中创建了另一个count变量。这个版本的count变量是一个全新的变量。if语句就好像开启了一个新的“迷你函数”。\nex22_main.c:11\ncount对于当前区块是局部变量，实际上不同于函数参数列表中的参数。\nex22_main.c:13\n将它打印出来，所以你可以在这里看到100，并不是传给scope_demo的参数。\nex22_main.c:16\n这里是最难懂得部分。你在两部分都有count变量，一个数函数参数，另一个是if语句中。if语句创建了新的代码块，所以11行的count并不影响同名的参数。这一行将其打印出来，你会看到它打印了参数的值而不是100。\nex22_main.c:18-20\n之后我将count参数设为3000并且打印出来，这里演示了你也可以修改函数参数的值，但并不会影响变量的调用者版本。\n确保你浏览了整个函数，但是不要认为你已经十分了解作用娱乐。如果你在一个代码块中（比如if或while语句）创建了一些变量，这些变量是全新的变量，并且只在这个代码块中存在。这是至关重要的东西，也是许多bug的来源。我要强调你应该在这里花一些时间。\nex22_main.c的剩余部分通过操作和打印变量演示了它们的全部。\nex22_main.c:26\n打印出MY_NAME的当前值，并且使用get_age读写器从ex22.c获取THE_AGE。\nex22_main.c:27-30\n使用了ex22.c中的set_age来修改并打印THE_AGE。\nex22_main.c:33-39\n接下来我对ex22.c中的THE_SIZE做了相同的事情，但这一次我直接访问了它，并且同时演示了它实际上在那个文件中已经修改了，还使用print_size打印了它。\nex22_main.c:42-44\n展示了update_ratio中的ratio在两次函数调用中如何保持了它的值。\nex22_main.c:46-51\n最后运行scope_demo，你可以在实例中观察到作用域。要注意到的关键点是，count局部变量在调用后保持不变。你将它像一个变量一样传入函数，它一定不会发生改变。要想达到目的你需要我们的老朋友指针。如果你将指向count的指针传入函数，那么函数就会持有它的地址并且能够改变它。\n上面解释了这些文件中所发生的事情，但是你应该跟踪它们，并且确保在你学习的过程中明白了每个变量都在什么位置。\n你会看到什么 link这次我想让你手动构建这两个文件，而不是使用你的Makefile。于是你可以看到它们实际上如何被编译器放到一起。这是你应该做的事情，并且你应该看到如下输出：\n$ cc -Wall -g -DNDEBUG -c -o ex22.o ex22.c $ cc -Wall -g -DNDEBUG ex22_main.c ex22.o -o ex22_main $ ./ex22_main [INFO] (ex22_main.c:26) My name: Zed A. Shaw, age: 37 [INFO] (ex22_main.c:30) My age is now: 100 [INFO] (ex22_main.c:33) THE_SIZE is: 1000 [INFO] (ex22.c:32) I think size is: 1000 [INFO] (ex22_main.c:38) THE SIZE is now: 9 [INFO] (ex22.c:32) I think size is: 9 [INFO] (ex22_main.c:42) Ratio at first: 1.000000 [INFO] (ex22_main.c:43) Ratio again: 2.000000 [INFO] (ex22_main.c:44) Ratio once more: 10.000000 [INFO] (ex22_main.c:8) count is: 4 [INFO] (ex22_main.c:16) count is at exit: 4 [INFO] (ex22_main.c:20) count after assign: 3000 [INFO] (ex22_main.c:8) count is: 80 [INFO] (ex22_main.c:13) count in this scope is 100 [INFO] (ex22_main.c:16) count is at exit: 80 [INFO] (ex22_main.c:20) count after assign: 3000 [INFO] (ex22_main.c:51) count after calling scope_demo: 4 确保你跟踪了每个变量是如何改变的，并且将其匹配到所输出的那一行。我使用了dbg.h的log_info来让你获得每个变量打印的具体行号，并且在文件中找到它用于跟踪。\n作用域、栈和Bug link如果你正确完成了这个练习，你会看到有很多不同方式在C代码中放置变量。你可以使用extern或者访问类似get_age的函数来创建全局。你也可以在任何代码块中创建新的变量，它们在退出代码块之前会拥有自己的值，并且屏蔽掉外部的变量。你也可以响函数传递一个值并且修改它，但是调用者的变量版本不会发生改变。\n需要理解的最重要的事情是，这些都可以造成bug。C中在你机器中许多位置放置和访问变量的能力会让你对它们所在的位置感到困扰。如果你不知道它们的位置，你就可能不能适当地管理它们。\n下面是一些编程C代码时需要遵循的规则，可以让你避免与栈相关的bug：\n不要隐藏某个变量，就像上面scope_demo中对count所做的一样。这可能会产生一些隐蔽的bug，你认为你改变了某个变量但实际上没有。 避免过多的全局变量，尤其是跨越多个文件。如果必须的话，要使用读写器函数，就像get_age。这并不适用于常量，因为它们是只读的。我是说对于THE_SIZE这种变量，如果你希望别人能够修改它，就应该使用读写器函数。 在你不清楚的情况下，应该把它放在堆上。不要依赖于栈的语义，或者指定区域，而是要直接使用malloc创建它。 不要使用函数级的静态变量，就像update_ratio。它们并不有用，而且当你想要使你的代码运行在多线程环境时，会有很大的隐患。对于良好的全局变量，它们也非常难于寻找。 避免复用函数参数，因为你搞不清楚仅仅想要复用它还是希望修改它的调用者版本。 如何使它崩溃 link对于这个练习，崩溃这个程序涉及到尝试访问或修改你不能访问的东西。\n试着从ex22_main.c直接访问ex22.c中的你不能访问变量。例如，你能不能获取update_ratio中的ratio？如果你用一个指针指向它会发生什么？ 移除ex22.h的extern声明，来观察会得到什么错误或警告。 对不同变量添加static或者const限定符，之后尝试修改它们。 附加题 link 研究“值传递”和“引用传递”的差异，并且为二者编写示例。（译者注：C中没有引用传递，你可以搜索“指针传递”。） 使用指针来访问原本不能访问的变量。 使用Valgrind来观察错误的访问是什么样子。 编写一个递归调用并导致栈溢出的函数。如果不知道递归函数是什么的话，试着在scope_demo底部调用scope_demo本身，会形成一种循环。 重新编写Makefile使之能够构建这些文件。 "
            }
        );
    index.add(
            {
                id:  33 ,
                href: "\/TechDocs\/docs\/c-guide\/ex23\/",
                title: "练习23：认识达夫设备",
                description: "原文：Exercise 23: Meet Duff’s Device 译者：飞龙 这个练习是一个脑筋急转弯，我会向你介绍最著名的C语言黑魔法之一，叫做“达夫设备”，以“发明者”汤姆·达夫的名字命名。这一强大（或邪恶？）的代码中，几乎你学过的任何东西都被包装在一个小的结构中。弄清它的工作机制也是一个好玩的谜题。 注 C的一部分乐趣来源于这种神奇的黑魔法，但这也是使C难以使用的地方。你最好能够了解这些技巧，因为他会带给你关于C语言和你计算机的深入理解。但是，你应该永远都不要使用它们，并总是追求简单易读的代码。 达夫设备由汤姆·达夫“发现”（或创造），它是一个C编译器的小技巧，本来不应该能够正常工作。我并不想告诉你做了什么，因为这是一个谜题，等着你来思考并尝试解决。你需要运行这段代码，之后尝试弄清它做了什么，以及为什么可以这样做。 #include #include #include \"dbg.h\" int normal_copy(char *from, char *to, int count) { int i = 0; for(i = 0; i \u003c count; i++) { to[i] = from[i]; } return i; } int duffs_device(char *from, char *to, int count) { { int n = (count + 7) / 8; switch(count % 8) { case 0: do { *to++ = *from++; case 7: *to++ = *from++; case 6: *to++ = *from++; case 5: *to++ = *from++; case 4: *to++ = *from++; case 3: *to++ = *from++; case 2: *to++ = *from++; case 1: *to++ = *from++; } while(--n \u003e 0); } } return count; } int zeds_device(char *from, char *to, int count) { { int n = (count + 7) / 8; switch(count % 8) { case 0: again: *to++ = *from++; case 7: *to++ = *from++; case 6: *to++ = *from++; case 5: *to++ = *from++; case 4: *to++ = *from++; case 3: *to++ = *from++; case 2: *to++ = *from++; case 1: *to++ = *from++; if(--n \u003e 0) goto again; } } return count; } int valid_copy(char *data, int count, char expects) { int i = 0; for(i = 0; i \u003c count; i++) { if(data[i] !",
                content: " 原文：Exercise 23: Meet Duff’s Device\n译者：飞龙\n这个练习是一个脑筋急转弯，我会向你介绍最著名的C语言黑魔法之一，叫做“达夫设备”，以“发明者”汤姆·达夫的名字命名。这一强大（或邪恶？）的代码中，几乎你学过的任何东西都被包装在一个小的结构中。弄清它的工作机制也是一个好玩的谜题。\n注\nC的一部分乐趣来源于这种神奇的黑魔法，但这也是使C难以使用的地方。你最好能够了解这些技巧，因为他会带给你关于C语言和你计算机的深入理解。但是，你应该永远都不要使用它们，并总是追求简单易读的代码。\n达夫设备由汤姆·达夫“发现”（或创造），它是一个C编译器的小技巧，本来不应该能够正常工作。我并不想告诉你做了什么，因为这是一个谜题，等着你来思考并尝试解决。你需要运行这段代码，之后尝试弄清它做了什么，以及为什么可以这样做。\n#include #include #include \"dbg.h\" int normal_copy(char *from, char *to, int count) { int i = 0; for(i = 0; i \u003c count; i++) { to[i] = from[i]; } return i; } int duffs_device(char *from, char *to, int count) { { int n = (count + 7) / 8; switch(count % 8) { case 0: do { *to++ = *from++; case 7: *to++ = *from++; case 6: *to++ = *from++; case 5: *to++ = *from++; case 4: *to++ = *from++; case 3: *to++ = *from++; case 2: *to++ = *from++; case 1: *to++ = *from++; } while(--n \u003e 0); } } return count; } int zeds_device(char *from, char *to, int count) { { int n = (count + 7) / 8; switch(count % 8) { case 0: again: *to++ = *from++; case 7: *to++ = *from++; case 6: *to++ = *from++; case 5: *to++ = *from++; case 4: *to++ = *from++; case 3: *to++ = *from++; case 2: *to++ = *from++; case 1: *to++ = *from++; if(--n \u003e 0) goto again; } } return count; } int valid_copy(char *data, int count, char expects) { int i = 0; for(i = 0; i \u003c count; i++) { if(data[i] != expects) { log_err(\"[%d] %c != %c\", i, data[i], expects); return 0; } } return 1; } int main(int argc, char *argv[]) { char from[1000] = {'a'}; char to[1000] = {'c'}; int rc = 0; // setup the from to have some stuff memset(from, 'x', 1000); // set it to a failure mode memset(to, 'y', 1000); check(valid_copy(to, 1000, 'y'), \"Not initialized right.\"); // use normal copy to rc = normal_copy(from, to, 1000); check(rc == 1000, \"Normal copy failed: %d\", rc); check(valid_copy(to, 1000, 'x'), \"Normal copy failed.\"); // reset memset(to, 'y', 1000); // duffs version rc = duffs_device(from, to, 1000); check(rc == 1000, \"Duff's device failed: %d\", rc); check(valid_copy(to, 1000, 'x'), \"Duff's device failed copy.\"); // reset memset(to, 'y', 1000); // my version rc = zeds_device(from, to, 1000); check(rc == 1000, \"Zed's device failed: %d\", rc); check(valid_copy(to, 1000, 'x'), \"Zed's device failed copy.\"); return 0; error: return 1; } 这段代码中我编写了三个版本的复制函数：\nnormal_copy\n使用普通的for循环来将字符从一个数组复制到另一个。\nduffs_device\n这个就是称为“达夫设备”的脑筋急转弯，以汤姆·达夫的名字命名。这段有趣的邪恶代码应归咎于他。\nzeds_device\n“达夫设备”的另一个版本，其中使用了goto来让你发现一些线索，关于duffs_device中奇怪的do-while做了什么。\n在往下学习之前仔细了解这三个函数，并试着自己解释代码都做了什么。\n你会看到什么 link这个程序没有任何输出，它只会执行并退出。你应当在Valgrind下运行它并确保没有任何错误。\n解决谜题 link首先需要了解的一件事，就是C对于它的一些语法是弱检查的。这就是你可以将do-while的一部分放入switch语句的一部分的原因，并且在其它地方的另一部分还可以正常工作。如果你观察带有goto again的我的版本，它实际上更清晰地解释了工作原理，但要确保你理解了这一部分是如何工作的。\n第二件事是switch语句的默认贯穿机制可以让你跳到指定的case，并且继续运行直到switch结束。\n最后的线索是count % 8以及顶端对n的计算。\n现在，要理解这些函数的工作原理，需要完成下列事情：\n将代码抄写在一张纸上。 当每个变量在switch之前初始化时，在纸的空白区域，把每个变量列在表中。 按照switch的逻辑模拟执行代码，之后再正确的case处跳出。 更新变量表，包括to、from和它们所指向的数组。 当你到达while或者我的goto时，检查你的变量，之后按照逻辑返回do-while顶端，或者again标签所在的地方。 继续这一手动的执行过程，更新变量，直到确定明白了代码如何运作。 为什么写成这样？ link当你弄明白它的实际工作原理时，最终的问题是：为什么要把代码写成这样？这个小技巧的目的是手动编写“循环展开”。大而长的循环会非常慢，所以提升速度的一个方法就是找到循环中某个固定的部分，之后在循环中复制代码，序列化地展开。例如，如果你知道一个循环会执行至少20次，你就可以将这20次的内容直接写在源代码中。\n达夫设备通过将循环展开为8个迭代块，来完成这件事情。这是个聪明的办法，并且可以正常工作。但是目前一个好的编译器也会为你完成这些。你不应该这样做，除非少数情况下你证明了它的确可以提升速度。\n附加题 link 不要再这样写代码了。 查询维基百科的“达夫设备”词条，并且看看你能不能找到错误。将它与这里的版本对比，并且阅读文章来试着理解，为什么维基百科上的代码在你这里不能正常工作，但是对于汤姆·达夫可以。 创建一些宏，来自动完成任意长度的这种设备。例如，你想创建32个case语句，并且不想手动把它们都写出来时，你会怎么办？你可以编写一次展开8个的宏吗？ 修改main函数，执行一些速度检测，来看看哪个实际上更快。 查询memcpy、memmove和memset，并且也比较一下它们的速度。 不要再这样写代码了！ "
            }
        );
    index.add(
            {
                id:  34 ,
                href: "\/TechDocs\/docs\/c-guide\/ex24\/",
                title: "练习24：输入输出和文件",
                description: "原文：Exercise 24: Input, Output, Files 译者：飞龙 你已经学会了使用printf来打印变量，这非常不错，但是还需要学习更多。这个练习中你会用到fscanf和fgets在结构体中构建关于一个人的信息。在这个关于读取输入的简介之后，你会得到C语言IO函数的完整列表。其中一些你已经见过并且使用过了，所以这个练习也是一个记忆练习。 #include #include \"dbg.h\" #define MAX_DATA 100 typedef enum EyeColor { BLUE_EYES, GREEN_EYES, BROWN_EYES, BLACK_EYES, OTHER_EYES } EyeColor; const char *EYE_COLOR_NAMES[] = { \"Blue\", \"Green\", \"Brown\", \"Black\", \"Other\" }; typedef struct Person { int age; char first_name[MAX_DATA]; char last_name[MAX_DATA]; EyeColor eyes; float income; } Person; int main(int argc, char *argv[]) { Person you = {.age = 0}; int i = 0; char *in = NULL; printf(\"What's your First Name?",
                content: " 原文：Exercise 24: Input, Output, Files\n译者：飞龙\n你已经学会了使用printf来打印变量，这非常不错，但是还需要学习更多。这个练习中你会用到fscanf和fgets在结构体中构建关于一个人的信息。在这个关于读取输入的简介之后，你会得到C语言IO函数的完整列表。其中一些你已经见过并且使用过了，所以这个练习也是一个记忆练习。\n#include #include \"dbg.h\" #define MAX_DATA 100 typedef enum EyeColor { BLUE_EYES, GREEN_EYES, BROWN_EYES, BLACK_EYES, OTHER_EYES } EyeColor; const char *EYE_COLOR_NAMES[] = { \"Blue\", \"Green\", \"Brown\", \"Black\", \"Other\" }; typedef struct Person { int age; char first_name[MAX_DATA]; char last_name[MAX_DATA]; EyeColor eyes; float income; } Person; int main(int argc, char *argv[]) { Person you = {.age = 0}; int i = 0; char *in = NULL; printf(\"What's your First Name? \"); in = fgets(you.first_name, MAX_DATA-1, stdin); check(in != NULL, \"Failed to read first name.\"); printf(\"What's your Last Name? \"); in = fgets(you.last_name, MAX_DATA-1, stdin); check(in != NULL, \"Failed to read last name.\"); printf(\"How old are you? \"); int rc = fscanf(stdin, \"%d\", \u0026you.age); check(rc \u003e 0, \"You have to enter a number.\"); printf(\"What color are your eyes:\\n\"); for(i = 0; i \u003c= OTHER_EYES; i++) { printf(\"%d) %s\\n\", i+1, EYE_COLOR_NAMES[i]); } printf(\"\u003e \"); int eyes = -1; rc = fscanf(stdin, \"%d\", \u0026eyes); check(rc \u003e 0, \"You have to enter a number.\"); you.eyes = eyes - 1; check(you.eyes \u003c= OTHER_EYES \u0026\u0026 you.eyes \u003e= 0, \"Do it right, that's not an option.\"); printf(\"How much do you make an hour? \"); rc = fscanf(stdin, \"%f\", \u0026you.income); check(rc \u003e 0, \"Enter a floating point number.\"); printf(\"----- RESULTS -----\\n\"); printf(\"First Name: %s\", you.first_name); printf(\"Last Name: %s\", you.last_name); printf(\"Age: %d\\n\", you.age); printf(\"Eyes: %s\\n\", EYE_COLOR_NAMES[you.eyes]); printf(\"Income: %f\\n\", you.income); return 0; error: return -1; } 这个程序非常简单，并且引入了叫做fscanf的函数，意思是“文件的格式化输入”。scanf家族的函数是printf的反转版本。printf用于以某种格式打印数据，然而scanf以某种格式读取（或者扫描）输入。\n文件开头没有什么新的东西，所以下面只列出main所做的事情：\nex24.c:24-28\n创建所需的变量。\nex24.c:30-32\n使用fgets函数获取名字，它从输入读取字符串（这个例子中是stdin），但是确保它不会造成缓冲区溢出。\nex24.c:34-36\n对 you.last_name执行相同操作，同样使用了fgets。\nex24.c:38-39\n使用fscanf来从stdin读取整数，并且将其放到you.age中。你可以看到，其中使用了和printf相同格式的格式化字符串。你也应该看到传入了you.age的地址，便于fscnaf获得它的指针来修改它。这是一个很好的例子，解释了使用指向数据的指针作为“输出参数”。\nex24.c:41-45\n打印出用于眼睛颜色的所有可选项，并且带有EyeColor枚举所匹配的数值。\nex24.c:47-50\n再次使用了fscanf，从you.eyes中获取数值，但是保证了输入是有效的。这非常重要，因为用户可以输入一个超出EYE_COLOR_NAMES数组范围的值，并且会导致段错误。\nex24.c:52-53\n获取you.income的值。\nex24.c:55-61\n将所有数据打印出来，便于你看到它们是否正确。要注意EYE_COLOR_NAMES用于打印EyeColor枚举值实际上的名字。\n你会看到什么 link当你运行这个程序时，你应该看到你的输入被适当地转换。你应该尝试给它非预期的输入，看看程序是怎么预防它的。\n$ make ex24 cc -Wall -g -DNDEBUG ex24.c -o ex24 $ ./ex24 What's your First Name? Zed What's your Last Name? Shaw How old are you? 37 What color are your eyes: 1) Blue 2) Green 3) Brown 4) Black 5) Other \u003e 1 How much do you make an hour? 1.2345 ----- RESULTS ----- First Name: Zed Last Name: Shaw Age: 37 Eyes: Blue Income: 1.234500 如何使它崩溃 link这个程序非常不错，但是这个练习中真正重要的部分是，scanf如何发生错误。对于简单的数值转换没有问题，但是对于字符串会出现问题，因为scanf在你读取之前并不知道缓冲区有多大。类似于gets的函数（并不是fgets，不带f的版本）也有一个我们已经避免的问题。它并不是道输入缓冲区有多大，并且可能会使你的程序崩溃。\n要演示fscanf和字符串的这一问题，需要修改使用fgets的那一行，使它变成fscanf(stdin, \"%50s\", you.first_name)，并且尝试再次运行。你会注意到，它读取了过多的内容，并且吃掉了你的回车键。这并不是你期望它所做的，你应该使用fgets而不是去解决古怪的scanf问题。\n接下来，将fgets改为gets，接着使用valgrind来执行valgrind ./ex24 \u003c /dev/urandom，往你的程序中输入一些垃圾字符串。这叫做对你的程序进行“模糊测试”，它是一种不错的方法来发现输入错误。这个例子中，你需要从/dev/urandom文件来输入一些垃圾，并且观察它如何崩溃。在一些平台上你需要执行数次，或者修改MAX_DATA来使其变小。\ngets函数非常糟糕，以至于一些平台在程序运行时会警告你使用了gets。你应该永远避免使用这个函数。\n最后，找到you.eyes输入的地方，并移除对其是否在正确范围内的检查。然后，为它输入一个错误的数值，比如-1或者1000。在Valgrind执行这些操作，来观察会发生什么。\n译者注：根据最新的C11标准，对于输入函数，你应该总是使用_s后缀的安全版本。对于向字符串的输出函数，应该总是使用C99中新增的带n的版本，例如snprintf。如果你的编译器支持新版本，就不应该使用旧版本的不安全函数。\nIO函数 link这是一个各种IO函数的简单列表。你应该查询每个函数并为其创建速记卡，包含函数名称，功能和它的任何变体。\nfscanf fgets fopen freopen fdopen fclose fcloseall fgetpos fseek ftell rewind fprintf fwrite fread 过一遍这些函数，并且记住它们的不同变体和它们的功能。例如，对于fscanf的卡片，上面应该有scanf、sscanf、vscanf，以及其它。并且在背面写下每个函数所做的事情。\n最后，为了获得这些卡片所需的信息，使用man来阅读它的帮助。例如，fscanf帮助页由man fscanf得到。\n附加题 link 将这个程序重写为不需要fscanf的版本。你需要使用类似于atoi的函数来将输入的字符串转换为数值。 修改这个程序，使用scanf来代替fscanf，并观察有什么不同。 修改程序，是输入的名字不包含任何换行符和空白字符。 使用scanf编写函数，按照文件名读取文件内容，每次读取单个字符，但是不要越过（文件和缓冲区的）末尾。使这个函数接受字符串大小来更加通用，并且确保无论什么情况下字符串都以'\\0'结尾。 "
            }
        );
    index.add(
            {
                id:  35 ,
                href: "\/TechDocs\/docs\/c-guide\/ex25\/",
                title: "练习25：变参函数",
                description: "原文：Exercise 25: Variable Argument Functions 译者：飞龙 在C语言中，你可以通过创建“变参函数”来创建你自己的printf或者scanf版本。这些函数使用stdarg.h头，它们可以让你为你的库创建更加便利的接口。它们对于创建特定类型的“构建”函数、格式化函数和任何用到可变参数的函数都非常实用。 理解“变参函数”对于C语言编程并不必要，我在编程生涯中也只有大约20次用到它。但是，理解变参函数如何工作有助于你对它的调试，并且让你更加了解计算机。 /** WARNING: This code is fresh and potentially isn't correct yet. */ #include #include #include #include \"dbg.h\" #define MAX_DATA 100 int read_string(char **out_string, int max_buffer) { *out_string = calloc(1, max_buffer + 1); check_mem(*out_string); char *result = fgets(*out_string, max_buffer, stdin); check(result != NULL, \"Input error.\"); return 0; error: if(*out_string) free(*out_string); *out_string = NULL; return -1; } int read_int(int *out_int) { char *input = NULL; int rc = read_string(\u0026input, MAX_DATA); check(rc == 0, \"Failed to read number.",
                content: " 原文：Exercise 25: Variable Argument Functions\n译者：飞龙\n在C语言中，你可以通过创建“变参函数”来创建你自己的printf或者scanf版本。这些函数使用stdarg.h头，它们可以让你为你的库创建更加便利的接口。它们对于创建特定类型的“构建”函数、格式化函数和任何用到可变参数的函数都非常实用。\n理解“变参函数”对于C语言编程并不必要，我在编程生涯中也只有大约20次用到它。但是，理解变参函数如何工作有助于你对它的调试，并且让你更加了解计算机。\n/** WARNING: This code is fresh and potentially isn't correct yet. */ #include #include #include #include \"dbg.h\" #define MAX_DATA 100 int read_string(char **out_string, int max_buffer) { *out_string = calloc(1, max_buffer + 1); check_mem(*out_string); char *result = fgets(*out_string, max_buffer, stdin); check(result != NULL, \"Input error.\"); return 0; error: if(*out_string) free(*out_string); *out_string = NULL; return -1; } int read_int(int *out_int) { char *input = NULL; int rc = read_string(\u0026input, MAX_DATA); check(rc == 0, \"Failed to read number.\"); *out_int = atoi(input); free(input); return 0; error: if(input) free(input); return -1; } int read_scan(const char *fmt, ...) { int i = 0; int rc = 0; int *out_int = NULL; char *out_char = NULL; char **out_string = NULL; int max_buffer = 0; va_list argp; va_start(argp, fmt); for(i = 0; fmt[i] != '\\0'; i++) { if(fmt[i] == '%') { i++; switch(fmt[i]) { case '\\0': sentinel(\"Invalid format, you ended with %%.\"); break; case 'd': out_int = va_arg(argp, int *); rc = read_int(out_int); check(rc == 0, \"Failed to read int.\"); break; case 'c': out_char = va_arg(argp, char *); *out_char = fgetc(stdin); break; case 's': max_buffer = va_arg(argp, int); out_string = va_arg(argp, char **); rc = read_string(out_string, max_buffer); check(rc == 0, \"Failed to read string.\"); break; default: sentinel(\"Invalid format.\"); } } else { fgetc(stdin); } check(!feof(stdin) \u0026\u0026 !ferror(stdin), \"Input error.\"); } va_end(argp); return 0; error: va_end(argp); return -1; } int main(int argc, char *argv[]) { char *first_name = NULL; char initial = ' '; char *last_name = NULL; int age = 0; printf(\"What's your first name? \"); int rc = read_scan(\"%s\", MAX_DATA, \u0026first_name); check(rc == 0, \"Failed first name.\"); printf(\"What's your initial? \"); rc = read_scan(\"%c\\n\", \u0026initial); check(rc == 0, \"Failed initial.\"); printf(\"What's your last name? \"); rc = read_scan(\"%s\", MAX_DATA, \u0026last_name); check(rc == 0, \"Failed last name.\"); printf(\"How old are you? \"); rc = read_scan(\"%d\", \u0026age); printf(\"---- RESULTS ----\\n\"); printf(\"First Name: %s\", first_name); printf(\"Initial: '%c'\\n\", initial); printf(\"Last Name: %s\", last_name); printf(\"Age: %d\\n\", age); free(first_name); free(last_name); return 0; error: return -1; } 这个程序和上一个练习很像，除了我编写了自己的scanf风格函数，它以我自己的方式处理字符串。你应该对main函数很清楚了，以及read_string和read_int两个函数，因为它们并没有做什么新的东西。\n这里的变参函数叫做read_scan，它使用了va_list数据结构执行和scanf相同的工作，并支持宏和函数。下面是它的工作原理：\n我将函数的最后一个参数设置为...，它向C表示这个函数在fmt参数之后接受任何数量的参数。我可以在它前面设置许多其它的参数，但是在它后面不能放置任何参数。 在设置完一些参数时，我创建了va_list类型的变量，并且使用va_list来为其初始化。这配置了stdarg.h中的这一可以处理可变参数的组件。 接着我使用了for循环，遍历fmt格式化字符串，并且处理了类似scanf的格式，但比它略简单。它里面只带有整数、字符和字符串。 当我碰到占位符时，我使用了switch语句来确定需要做什么。 现在，为了从va_list argp中获得遍历，我需要使用va_arg(argp, TYPE)宏，其中TYPE是我将要向参数传递的准确类型。这一设计的后果是你会非常盲目，所以如果你没有足够的变量传入，程序就会崩溃。 和scanf的有趣的不同点是，当它碰到's'占位符时，我使用read_string来创建字符串。va_list argp栈需要接受两个函数：需要读取的最大尺寸，以及用于输出的字符串指针。read_string使用这些信息来执行实际工作。 这使read_scan比scan更加一致，因为你总是使用\u0026提供变量的地址，并且合理地设置它们。 最后，如果它碰到了不在格式中的字符，它仅仅会读取并跳过，而并不关心字符是什么，因为它只需要跳过。 你会看到什么 link当你运行程序时，会得到与下面详细的结果：\n$ make ex25 cc -Wall -g -DNDEBUG ex25.c -o ex25 $ ./ex25 What's your first name? Zed What's your initial? A What's your last name? Shaw How old are you? 37 ---- RESULTS ---- First Name: Zed Initial: 'A' Last Name: Shaw Age: 37 如何使它崩溃 link这个程序对缓冲区溢出更加健壮，但是和scanf一样，它不能够处理输入的格式错误。为了使它崩溃，试着修改代码，把首先传入用于'%s'格式的尺寸去掉。同时试着传入多于MAX_DATA的数据，之后找到在read_string中不使用calloc的方法，并且修改它的工作方式。最后还有个问题是fgets会吃掉换行符，所以试着使用fgetc修复它，要注意字符串结尾应为'\\0'。\n附加题 link 再三检查确保你明白了每个out_变量的作用。最重要的是out_string，并且它是指针的指针。所以，理清当你设置时获取到的是指针还是内容尤为重要。 使用变参系统编写一个和printf相似的函数，重新编写main来使用它。 像往常一样，阅读这些函数/宏的手册页，确保知道了它在你的平台做了什么，一些平台会使用宏而其它平台会使用函数，还有一些平台会让它们不起作用。这完全取决于你所用的编译器和平台。 "
            }
        );
    index.add(
            {
                id:  36 ,
                href: "\/TechDocs\/docs\/c-guide\/ex26\/",
                title: "练习26：编写第一个真正的程序",
                description: "原文：Exercise 26: Write A First Real Program\n译者：飞龙\n这本书你已经完成一半了，所以你需要做一个期中检测。期中检测中你需要重新构建一个我特地为本书编写的软件，叫做devpkg。随后你需要以一些方式扩展它，并且通过编写一些单元测试来改进代码。\n注\n我在一些你需要完成的练习之前编写了这个练习。如果你现在尝试这个练习，记住软件可能会含有一些bug，你可能由于我的错误会产生一些问题，也可能不知道需要什么来完成它。如果这样的话，通过help@learncodethehardway.org来告诉我，之后等待我写完其它练习。\n什么是devpkg？ linkdevpkg是一个简单的C程序，可以用于安装其它软件。我特地为本书编写了它，作为一种方式来教你真正的软件是如何构建的，以及如何复用他人的库。它使用了一个叫做Apache可移植运行时（APR）的库，其中含有许多工作跨平台的便利的C函数，包括Windows。此外，它只是从互联网（或本地文件）抓取代码，并且执行通常的./configure ; make ; make install命令，每个程序员都用到过。\n这个练习中，你的目标是从源码构建devpkg，完成我提供的每个挑战，并且使用源码来理解devpkg做了什么和为什么这样做。\n我们打算创建什么 link我们打算创建一个具有三个命令的工具：\ndevpkg -S\n在电脑上安装新的软件。\ndevpkg -I\n从URL安装软件。\ndevpkg -L\n列出安装的所有软件。\ndevpkg -F\n为手动构建抓取源代码。\ndevpkg -B\n构建所抓取的源码代码并且安装它，即使它已经安装了。\n我们想让devpkg能够接受几乎任何URL，判断项目的类型，下载，安装，以及注册已经安装的软件。我们也希望它能够处理一个简单的依赖列表，以便它能够安装项目所需的所有软件。\n设计 link为了完成这一目标，devpkg具有非常简单的设计：\n使用外部命令\n大多数工作都是通过类似于curl、git和tar的外部命令完成的。这样减少了devpkg所需的代码量。\n简单的文件数据库\n你可以轻易使它变得很复杂，但是一开始你需要完成一个简单的文件数据库，位于/usr/local/.devpkg/db，来跟踪已安装的软件。\n/usr/local\n同样你可以使它更高级，但是对于初学者来说，假设项目始终位于/usr/local中，它是大多数Unix软件的标准安装目录。\nconfigure; make; make install\n假设大多数软件可以通过configure; make; make install来安装，也许configure是可选的。如果软件不能通过这种方式安装，要么提供某种方式来修改命令，要么devpkg就可以无视它。\n用户可以root\n我们假设用于可以使用sudo来提升至root权限，除非他们直到最后才想root。\n这会使我们的程序像当初设想的一样简单，并且对于它的功能来说已经足够了。之后你可以进一步修改它。\nApache 可移植运行时 link你需要做的另外一件事情就是使用Apache可移植运行时（APR）来未完成这个练习获得一个可移植的工具集。APR并不是必要的，你也可以不用它，但是你需要写的代码就会非常多。我现在强制你使用APR，使你能够熟悉链接和使用其他的库。最后，APR也能在Windows上工作，所以你可以把它迁移到许多其它平台上。\n你应该获取apr-1.4.5和apr-util-1.3的库，以及浏览在apr.apache.org主站上的文档。\n下面是一个ShellScript，用于安装所需的所有库。你应该手动将它写到一个文件中，之后运行它直到APR安装好并且没有任何错误。\nset -e cd /tmp curl -L -O http://archive.apache.org/dist/apr/apr-1.4.6.tar.gz tar -xzvf apr-1.",
                content: " 原文：Exercise 26: Write A First Real Program\n译者：飞龙\n这本书你已经完成一半了，所以你需要做一个期中检测。期中检测中你需要重新构建一个我特地为本书编写的软件，叫做devpkg。随后你需要以一些方式扩展它，并且通过编写一些单元测试来改进代码。\n注\n我在一些你需要完成的练习之前编写了这个练习。如果你现在尝试这个练习，记住软件可能会含有一些bug，你可能由于我的错误会产生一些问题，也可能不知道需要什么来完成它。如果这样的话，通过help@learncodethehardway.org来告诉我，之后等待我写完其它练习。\n什么是devpkg？ linkdevpkg是一个简单的C程序，可以用于安装其它软件。我特地为本书编写了它，作为一种方式来教你真正的软件是如何构建的，以及如何复用他人的库。它使用了一个叫做Apache可移植运行时（APR）的库，其中含有许多工作跨平台的便利的C函数，包括Windows。此外，它只是从互联网（或本地文件）抓取代码，并且执行通常的./configure ; make ; make install命令，每个程序员都用到过。\n这个练习中，你的目标是从源码构建devpkg，完成我提供的每个挑战，并且使用源码来理解devpkg做了什么和为什么这样做。\n我们打算创建什么 link我们打算创建一个具有三个命令的工具：\ndevpkg -S\n在电脑上安装新的软件。\ndevpkg -I\n从URL安装软件。\ndevpkg -L\n列出安装的所有软件。\ndevpkg -F\n为手动构建抓取源代码。\ndevpkg -B\n构建所抓取的源码代码并且安装它，即使它已经安装了。\n我们想让devpkg能够接受几乎任何URL，判断项目的类型，下载，安装，以及注册已经安装的软件。我们也希望它能够处理一个简单的依赖列表，以便它能够安装项目所需的所有软件。\n设计 link为了完成这一目标，devpkg具有非常简单的设计：\n使用外部命令\n大多数工作都是通过类似于curl、git和tar的外部命令完成的。这样减少了devpkg所需的代码量。\n简单的文件数据库\n你可以轻易使它变得很复杂，但是一开始你需要完成一个简单的文件数据库，位于/usr/local/.devpkg/db，来跟踪已安装的软件。\n/usr/local\n同样你可以使它更高级，但是对于初学者来说，假设项目始终位于/usr/local中，它是大多数Unix软件的标准安装目录。\nconfigure; make; make install\n假设大多数软件可以通过configure; make; make install来安装，也许configure是可选的。如果软件不能通过这种方式安装，要么提供某种方式来修改命令，要么devpkg就可以无视它。\n用户可以root\n我们假设用于可以使用sudo来提升至root权限，除非他们直到最后才想root。\n这会使我们的程序像当初设想的一样简单，并且对于它的功能来说已经足够了。之后你可以进一步修改它。\nApache 可移植运行时 link你需要做的另外一件事情就是使用Apache可移植运行时（APR）来未完成这个练习获得一个可移植的工具集。APR并不是必要的，你也可以不用它，但是你需要写的代码就会非常多。我现在强制你使用APR，使你能够熟悉链接和使用其他的库。最后，APR也能在Windows上工作，所以你可以把它迁移到许多其它平台上。\n你应该获取apr-1.4.5和apr-util-1.3的库，以及浏览在apr.apache.org主站上的文档。\n下面是一个ShellScript，用于安装所需的所有库。你应该手动将它写到一个文件中，之后运行它直到APR安装好并且没有任何错误。\nset -e cd /tmp curl -L -O http://archive.apache.org/dist/apr/apr-1.4.6.tar.gz tar -xzvf apr-1.4.6.tar.gz cd apr-1.4.6 ./configure make sudo make install cd /tmp rm -rf apr-1.4.6 apr-1.4.6.tar.gz curl -L -O http://archive.apache.org/dist/apr/apr-util-1.4.1.tar.gz tar -xzvf apr-util-1.4.1.tar.gz cd apr-util-1.4.1 ./configure --with-apr=/usr/local/apr make sudo make install #cleanup cd /tmp rm -rf apr-util-1.4.1* apr-1.4.6* 我希望你输入这个脚本，因为这就是devpkg基本上所做的事情，只是带有了一些选项和检查项。实际上，你可以使用Shell以更少的代码来完成它，但是这对于一本C语言的书不是一个很好的程序。\n简单运行这个脚本，修复它直到正常工作，就完成的所有库的安装，之后你需要完成项目的剩下部分。\n项目布局 link你需要创建一些简单的项目文件来起步。下面是我通常创建一个新项目的方法：\nmkdir devpkg cd devpkg touch README Makefile 其它依赖 link你应该已经安装了APR和APR-util，所以你需要一些更多的文件作为基本的依赖：\n练习20中的dbg.h。 从http://bstring.sourceforge.net/下载的bstrlib.h和bstrlib.c。下载.zip文件，解压并且将这个两个文件拷贝到项目中。 运行make bstrlib.o，如果这不能正常工作，阅读下面的“修复bstring”指南。 注\n在一些平台上bstring.c文件会出现下列错误：\nbstrlib.c:2762: error: expected declaration specifiers or '...' before numeric constant 这是由于作者使用了一个不好的定义，它在一些平台上不能工作。你需要修改第2759行的#ifdef __GNUC__，并把它改成：\n#if defined(__GNUC__) \u0026\u0026 !defined(__APPLE__) 之后在Mac OSX平台上就应该能够正常工作了。\n做完上面这些后，你应该有了Makefile，README，dbg.h，bstrlib.h和bstrlib.c，并做好了准备。\nMakefile link我们最好从Makefile开始，因为它列出了项目如何构建，以及你会创建哪些源文件。\nPREFIX?=/usr/local CFLAGS=-g -Wall -I${PREFIX}/apr/include/apr-1 -I${PREFIX}/apr/include/apr-util-1 LDFLAGS=-L${PREFIX}/apr/lib -lapr-1 -pthread -laprutil-1 all: devpkg devpkg: bstrlib.o db.o shell.o commands.o install: all install -d $(DESTDIR)/$(PREFIX)/bin/ install devpkg $(DESTDIR)/$(PREFIX)/bin/ clean: rm -f *.o rm -f devpkg rm -rf *.dSYM 比起之前看到过的，这并没有什么新东西，除了可能有些奇怪的?=语法，它表示“如果之前没有定义，就将PREFIX设置为该值”。\n注\n如果你使用了最近版本的Ubuntu，你会得到apr_off_t 或 off64_t的错误，之后需要向CFLAGS添加-D_LARGEFILE64_SOURCE=1。\n所需的另一件事是，你需要向/etc/ld.conf.so.d/添加/usr/local/apr/lib，之后运行ldconfig使它能够选择正常的库。\n源文件 link我们可以从makefile中看到，devpkg有四个依赖项，它们是：\nbstrlib.o\n由bstrlib.c和bstrlib.o产生，你已经将它们引入了。\ndb.o\n由db.c和db.h产生，它包含了一个小型“数据库”程序集的代码。\nshell.o\n由shell.c和shell.h产生，包含一些函数，是类似curl的一些命令运行起来更容易。\ncommands.o\n由commands.c和commands.h产生，包含了devpkg所需的所有命令并使它更易用。\ndevpkg\n它不会显式提到，但是它是Makefile在这一部分的目标。它由devpkg.c产生，包含用于整个程序的main函数。\n你的任务就是创建这些文件，并且输入代码并保证正确。\n注\n你读完这个描述可能会想，“Zed为什么那么聪明，坐着就能设计出来这些文件？！”我并不是用我强大的代码功力魔术般地把devpkg设计成这样。而是我做了这些：\n我编写了简单的README来获得如何构建项目的灵感。 我创建了一个简单的bash脚本（就像你编写的那样）来理清所需的所有组件。 我创建了一个.c文件，并且在它上面花了几天，酝酿并想出点子。 接着我编写并调试程序，之后我将这一个大文件分成四个文件。 做完这些之后，我重命名和优化了函数和数据结构，使它们在逻辑上更“美观”。 最后，使新程序成功并以相同方式工作之后，我添加了一些新的特性，比如-F和-B选项。 你读到的这份列表是我打算教给你的，但不要认为这是我构建软件的通用方法。有时候我会事先知道主题，并且会做更多的规划。也有时我会编写一份规划并将它扔掉，之后再规划更好的版本。它完全取决于我的经验告诉我哪个比较好，或者我的灵感将我带到何处。\n如果你碰到一个“专家”，它告诉你只有一个方法可以解决编程问题，那么它在骗你。要么它们实际使用了很多策略，要么他们并不足够好。\nDB函数 link程序中必须有个方法来记录已经安装的URL，列出这些URL，并且检查一些程序是否已安装以便跳过。我会使用一个简单、扁平化的文件数据库，以及bstrlib.h。\n首先，创建db.h头文件，以便让你知道需要实现什么。\n#ifndef _db_h #define _db_h #define DB_FILE \"/usr/local/.devpkg/db\" #define DB_DIR \"/usr/local/.devpkg\" int DB_init(); int DB_list(); int DB_update(const char *url); int DB_find(const char *url); #endif 之后实现db.c中的这些函数，在你编写它的时候，像之前一样使用make。\n#include #include #include #include \"db.h\" #include \"bstrlib.h\" #include \"dbg.h\" static FILE *DB_open(const char *path, const char *mode) { return fopen(path, mode); } static void DB_close(FILE *db) { fclose(db); } static bstring DB_load() { FILE *db = NULL; bstring data = NULL; db = DB_open(DB_FILE, \"r\"); check(db, \"Failed to open database: %s\", DB_FILE); data = bread((bNread)fread, db); check(data, \"Failed to read from db file: %s\", DB_FILE); DB_close(db); return data; error: if(db) DB_close(db); if(data) bdestroy(data); return NULL; } int DB_update(const char *url) { if(DB_find(url)) { log_info(\"Already recorded as installed: %s\", url); } FILE *db = DB_open(DB_FILE, \"a+\"); check(db, \"Failed to open DB file: %s\", DB_FILE); bstring line = bfromcstr(url); bconchar(line, '\\n'); int rc = fwrite(line-\u003edata, blength(line), 1, db); check(rc == 1, \"Failed to append to the db.\"); return 0; error: if(db) DB_close(db); return -1; } int DB_find(const char *url) { bstring data = NULL; bstring line = bfromcstr(url); int res = -1; data = DB_load(); check(data, \"Failed to load: %s\", DB_FILE); if(binstr(data, 0, line) == BSTR_ERR) { res = 0; } else { res = 1; } error: // fallthrough if(data) bdestroy(data); if(line) bdestroy(line); return res; } int DB_init() { apr_pool_t *p = NULL; apr_pool_initialize(); apr_pool_create(\u0026p, NULL); if(access(DB_DIR, W_OK | X_OK) == -1) { apr_status_t rc = apr_dir_make_recursive(DB_DIR, APR_UREAD | APR_UWRITE | APR_UEXECUTE | APR_GREAD | APR_GWRITE | APR_GEXECUTE, p); check(rc == APR_SUCCESS, \"Failed to make database dir: %s\", DB_DIR); } if(access(DB_FILE, W_OK) == -1) { FILE *db = DB_open(DB_FILE, \"w\"); check(db, \"Cannot open database: %s\", DB_FILE); DB_close(db); } apr_pool_destroy(p); return 0; error: apr_pool_destroy(p); return -1; } int DB_list() { bstring data = DB_load(); check(data, \"Failed to read load: %s\", DB_FILE); printf(\"%s\", bdata(data)); bdestroy(data); return 0; error: return -1; } 挑战1：代码复查 link在继续之前，仔细阅读这些文件的每一行，并且确保你以准确地输入了它们。通过逐行阅读代码来实践它。同时，跟踪每个函数调用，并且确保你使用了check来校验返回值。最后，在APR网站上的文档，或者bstrlib.h 或 bstrlib.c的源码中，查阅每个你不认识的函数。\nShell 函数 linkdevkpg的一个关键设计是，使用类似于curl、tar和git的外部工具来完成大部分的工作。我们可以找到在程序内部完成这些工作的库，但是如果我们只是需要这些程序的基本功能，这样就毫无意义。在Unix运行其它命令并不丢人。\n为了完成这些，我打算使用apr_thread_proc.h函数来运行程序，但是我也希望创建一个简单的类“模板”系统。我会使用struct Shell，它持有所有运行程序所需的信息，但是在参数中有一些“空位”，我可以将它们替换成实际值。\n观察shell.h文件来了解我会用到的结构和命令。你可以看到我使用extern来表明其他的.c文件也能访问到shell.c中定义的变量。\n#ifndef _shell_h #define _shell_h #define MAX_COMMAND_ARGS 100 #include typedef struct Shell { const char *dir; const char *exe; apr_procattr_t *attr; apr_proc_t proc; apr_exit_why_e exit_why; int exit_code; const char *args[MAX_COMMAND_ARGS]; } Shell; int Shell_run(apr_pool_t *p, Shell *cmd); int Shell_exec(Shell cmd, ...); extern Shell CLEANUP_SH; extern Shell GIT_SH; extern Shell TAR_SH; extern Shell CURL_SH; extern Shell CONFIGURE_SH; extern Shell MAKE_SH; extern Shell INSTALL_SH; #endif 确保你已经创建了shell.h，并且extern Shell变量的名字和数量相同。它们被Shell_run和Shell_exec函数用于运行命令。我定义了这两个函数，并且在shell.c中创建实际变量。\n#include \"shell.h\" #include \"dbg.h\" #include int Shell_exec(Shell template, ...) { apr_pool_t *p = NULL; int rc = -1; apr_status_t rv = APR_SUCCESS; va_list argp; const char *key = NULL; const char *arg = NULL; int i = 0; rv = apr_pool_create(\u0026p, NULL); check(rv == APR_SUCCESS, \"Failed to create pool.\"); va_start(argp, template); for(key = va_arg(argp, const char *); key != NULL; key = va_arg(argp, const char *)) { arg = va_arg(argp, const char *); for(i = 0; template.args[i] != NULL; i++) { if(strcmp(template.args[i], key) == 0) { template.args[i] = arg; break; // found it } } } rc = Shell_run(p, \u0026template); apr_pool_destroy(p); va_end(argp); return rc; error: if(p) { apr_pool_destroy(p); } return rc; } int Shell_run(apr_pool_t *p, Shell *cmd) { apr_procattr_t *attr; apr_status_t rv; apr_proc_t newproc; rv = apr_procattr_create(\u0026attr, p); check(rv == APR_SUCCESS, \"Failed to create proc attr.\"); rv = apr_procattr_io_set(attr, APR_NO_PIPE, APR_NO_PIPE, APR_NO_PIPE); check(rv == APR_SUCCESS, \"Failed to set IO of command.\"); rv = apr_procattr_dir_set(attr, cmd-\u003edir); check(rv == APR_SUCCESS, \"Failed to set root to %s\", cmd-\u003edir); rv = apr_procattr_cmdtype_set(attr, APR_PROGRAM_PATH); check(rv == APR_SUCCESS, \"Failed to set cmd type.\"); rv = apr_proc_create(\u0026newproc, cmd-\u003eexe, cmd-\u003eargs, NULL, attr, p); check(rv == APR_SUCCESS, \"Failed to run command.\"); rv = apr_proc_wait(\u0026newproc, \u0026cmd-\u003eexit_code, \u0026cmd-\u003eexit_why, APR_WAIT); check(rv == APR_CHILD_DONE, \"Failed to wait.\"); check(cmd-\u003eexit_code == 0, \"%s exited badly.\", cmd-\u003eexe); check(cmd-\u003eexit_why == APR_PROC_EXIT, \"%s was killed or crashed\", cmd-\u003eexe); return 0; error: return -1; } Shell CLEANUP_SH = { .exe = \"rm\", .dir = \"/tmp\", .args = {\"rm\", \"-rf\", \"/tmp/pkg-build\", \"/tmp/pkg-src.tar.gz\", \"/tmp/pkg-src.tar.bz2\", \"/tmp/DEPENDS\", NULL} }; Shell GIT_SH = { .dir = \"/tmp\", .exe = \"git\", .args = {\"git\", \"clone\", \"URL\", \"pkg-build\", NULL} }; Shell TAR_SH = { .dir = \"/tmp/pkg-build\", .exe = \"tar\", .args = {\"tar\", \"-xzf\", \"FILE\", \"--strip-components\", \"1\", NULL} }; Shell CURL_SH = { .dir = \"/tmp\", .exe = \"curl\", .args = {\"curl\", \"-L\", \"-o\", \"TARGET\", \"URL\", NULL} }; Shell CONFIGURE_SH = { .exe = \"./configure\", .dir = \"/tmp/pkg-build\", .args = {\"configure\", \"OPTS\", NULL}, }; Shell MAKE_SH = { .exe = \"make\", .dir = \"/tmp/pkg-build\", .args = {\"make\", \"OPTS\", NULL} }; Shell INSTALL_SH = { .exe = \"sudo\", .dir = \"/tmp/pkg-build\", .args = {\"sudo\", \"make\", \"TARGET\", NULL} }; 自底向上阅读shell.c的代码（这也是常见的C源码布局），你会看到我创建了实际的Shell变量，它在shell.h中以extern修饰。它们虽然在这里，但是也被程序的其它部分使用。这就是创建全局变量的方式，它们可以存在于一个.c文件中，但是可在任何地方使用。你不应该创建很多这类变量，但是它们的确很方便。\n继续阅读代码，我们读到了Shell_run，它是一个“基”函数，只是基于Shell中的东西执行命令。它使用了许多在apr_thread_proc.h中定义的函数，你需要查阅它们的每一个来了解工作原理。这就像是一些使用system函数调用的代码一样，但是它可以让你控制其他程序的执行。例如，在我们的Shell结构中，存在.dir属性在运行之前强制程序必须在指定目录中。\n最后，我创建了Shell_exec函数，它是个变参函数。你在之前已经看到过了，但是确保你理解了stdarg.h函数以及如何编写它们。在下个挑战中你需要分析这一函数。\n挑战2：分析Shell_exec link为这些文件（以及向挑战1那样的完整的代码复查）设置的挑战是完整分析Shell_exec，并且拆分代码来了解工作原理。你应该能够理解每一行代码，for循环如何工作，以及参数如何被替换。\n一旦你分析完成，向struct Shell添加一个字段，提供需要替代的args变量的数量。更新所有命令来接受参数的正确数量，随后增加一个错误检查，来确认参数被正确替换，以及在错误时退出。\n命令行函数 link现在你需要构造正确的命令来完成功能。这些命令会用到APR的函数、db.h和shell.h来执行下载和构建软件的真正工作。这些文件最为复杂，所以要小心编写它们。你需要首先编写commands.h文件，接着在commands.c文件中实现它的函数。\n#ifndef _commands_h #define _commands_h #include #define DEPENDS_PATH \"/tmp/DEPENDS\" #define TAR_GZ_SRC \"/tmp/pkg-src.tar.gz\" #define TAR_BZ2_SRC \"/tmp/pkg-src.tar.bz2\" #define BUILD_DIR \"/tmp/pkg-build\" #define GIT_PAT \"*.git\" #define DEPEND_PAT \"*DEPENDS\" #define TAR_GZ_PAT \"*.tar.gz\" #define TAR_BZ2_PAT \"*.tar.bz2\" #define CONFIG_SCRIPT \"/tmp/pkg-build/configure\" enum CommandType { COMMAND_NONE, COMMAND_INSTALL, COMMAND_LIST, COMMAND_FETCH, COMMAND_INIT, COMMAND_BUILD }; int Command_fetch(apr_pool_t *p, const char *url, int fetch_only); int Command_install(apr_pool_t *p, const char *url, const char *configure_opts, const char *make_opts, const char *install_opts); int Command_depends(apr_pool_t *p, const char *path); int Command_build(apr_pool_t *p, const char *url, const char *configure_opts, const char *make_opts, const char *install_opts); #endif commands.h中并没有很多之前没见过的东西。你应该看到了一些字符串的定义，它们在任何地方都会用到。真正的代码在commands.c中。\n#include #include #include #include \"commands.h\" #include \"dbg.h\" #include \"bstrlib.h\" #include \"db.h\" #include \"shell.h\" int Command_depends(apr_pool_t *p, const char *path) { FILE *in = NULL; bstring line = NULL; in = fopen(path, \"r\"); check(in != NULL, \"Failed to open downloaded depends: %s\", path); for(line = bgets((bNgetc)fgetc, in, '\\n'); line != NULL; line = bgets((bNgetc)fgetc, in, '\\n')) { btrimws(line); log_info(\"Processing depends: %s\", bdata(line)); int rc = Command_install(p, bdata(line), NULL, NULL, NULL); check(rc == 0, \"Failed to install: %s\", bdata(line)); bdestroy(line); } fclose(in); return 0; error: if(line) bdestroy(line); if(in) fclose(in); return -1; } int Command_fetch(apr_pool_t *p, const char *url, int fetch_only) { apr_uri_t info = {.port = 0}; int rc = 0; const char *depends_file = NULL; apr_status_t rv = apr_uri_parse(p, url, \u0026info); check(rv == APR_SUCCESS, \"Failed to parse URL: %s\", url); if(apr_fnmatch(GIT_PAT, info.path, 0) == APR_SUCCESS) { rc = Shell_exec(GIT_SH, \"URL\", url, NULL); check(rc == 0, \"git failed.\"); } else if(apr_fnmatch(DEPEND_PAT, info.path, 0) == APR_SUCCESS) { check(!fetch_only, \"No point in fetching a DEPENDS file.\"); if(info.scheme) { depends_file = DEPENDS_PATH; rc = Shell_exec(CURL_SH, \"URL\", url, \"TARGET\", depends_file, NULL); check(rc == 0, \"Curl failed.\"); } else { depends_file = info.path; } // recursively process the devpkg list log_info(\"Building according to DEPENDS: %s\", url); rv = Command_depends(p, depends_file); check(rv == 0, \"Failed to process the DEPENDS: %s\", url); // this indicates that nothing needs to be done return 0; } else if(apr_fnmatch(TAR_GZ_PAT, info.path, 0) == APR_SUCCESS) { if(info.scheme) { rc = Shell_exec(CURL_SH, \"URL\", url, \"TARGET\", TAR_GZ_SRC, NULL); check(rc == 0, \"Failed to curl source: %s\", url); } rv = apr_dir_make_recursive(BUILD_DIR, APR_UREAD | APR_UWRITE | APR_UEXECUTE, p); check(rv == APR_SUCCESS, \"Failed to make directory %s\", BUILD_DIR); rc = Shell_exec(TAR_SH, \"FILE\", TAR_GZ_SRC, NULL); check(rc == 0, \"Failed to untar %s\", TAR_GZ_SRC); } else if(apr_fnmatch(TAR_BZ2_PAT, info.path, 0) == APR_SUCCESS) { if(info.scheme) { rc = Shell_exec(CURL_SH, \"URL\", url, \"TARGET\", TAR_BZ2_SRC, NULL); check(rc == 0, \"Curl failed.\"); } apr_status_t rc = apr_dir_make_recursive(BUILD_DIR, APR_UREAD | APR_UWRITE | APR_UEXECUTE, p); check(rc == 0, \"Failed to make directory %s\", BUILD_DIR); rc = Shell_exec(TAR_SH, \"FILE\", TAR_BZ2_SRC, NULL); check(rc == 0, \"Failed to untar %s\", TAR_BZ2_SRC); } else { sentinel(\"Don't now how to handle %s\", url); } // indicates that an install needs to actually run return 1; error: return -1; } int Command_build(apr_pool_t *p, const char *url, const char *configure_opts, const char *make_opts, const char *install_opts) { int rc = 0; check(access(BUILD_DIR, X_OK | R_OK | W_OK) == 0, \"Build directory doesn't exist: %s\", BUILD_DIR); // actually do an install if(access(CONFIG_SCRIPT, X_OK) == 0) { log_info(\"Has a configure script, running it.\"); rc = Shell_exec(CONFIGURE_SH, \"OPTS\", configure_opts, NULL); check(rc == 0, \"Failed to configure.\"); } rc = Shell_exec(MAKE_SH, \"OPTS\", make_opts, NULL); check(rc == 0, \"Failed to build.\"); rc = Shell_exec(INSTALL_SH, \"TARGET\", install_opts ? install_opts : \"install\", NULL); check(rc == 0, \"Failed to install.\"); rc = Shell_exec(CLEANUP_SH, NULL); check(rc == 0, \"Failed to cleanup after build.\"); rc = DB_update(url); check(rc == 0, \"Failed to add this package to the database.\"); return 0; error: return -1; } int Command_install(apr_pool_t *p, const char *url, const char *configure_opts, const char *make_opts, const char *install_opts) { int rc = 0; check(Shell_exec(CLEANUP_SH, NULL) == 0, \"Failed to cleanup before building.\"); rc = DB_find(url); check(rc != -1, \"Error checking the install database.\"); if(rc == 1) { log_info(\"Package %s already installed.\", url); return 0; } rc = Command_fetch(p, url, 0); if(rc == 1) { rc = Command_build(p, url, configure_opts, make_opts, install_opts); check(rc == 0, \"Failed to build: %s\", url); } else if(rc == 0) { // no install needed log_info(\"Depends successfully installed: %s\", url); } else { // had an error sentinel(\"Install failed: %s\", url); } Shell_exec(CLEANUP_SH, NULL); return 0; error: Shell_exec(CLEANUP_SH, NULL); return -1; } 在你输入并编译它之后，就可以开始分析了。如果到目前为止你完成了前面的挑战，你会理解如何使用shell.c函数来运行shell命令，以及参数如何被替换。如果没有则需要回退到前面的挑战，确保你真正理解了Shell_exec的工作原理。\n挑战3：评判我的设计 link像之前一样，完整地复查一遍代码来保证一模一样。接着浏览每个函数并且确保你知道他如何工作。你也应该跟踪这个文件或其它文件中，每个函数对其它函数的调用。最后，确认你理解了这里的所有调用APR的函数。\n一旦你正确编写并分析了这个文件，把我当成一个傻瓜一样来评判我的设计，我需要看看你是否可以改进它。不要真正修改代码，只是创建一个notes.txt并且写下你的想法和你需要修改的地方。\ndevpkg的main函数 linkdevpkg.c是最后且最重要的，但是也可能是最简单的文件，其中创建了main函数。没有与之配套的.h文件，因为这个文件包含其他所有文件。这个文件用于创建devpkg可执行程序，同时组装了来自Makefile的其它.o文件。在文件中输入代码并保证正确。\n#include #include #include #include #include #include \"dbg.h\" #include \"db.h\" #include \"commands.h\" int main(int argc, const char const *argv[]) { apr_pool_t *p = NULL; apr_pool_initialize(); apr_pool_create(\u0026p, NULL); apr_getopt_t *opt; apr_status_t rv; char ch = '\\0'; const char *optarg = NULL; const char *config_opts = NULL; const char *install_opts = NULL; const char *make_opts = NULL; const char *url = NULL; enum CommandType request = COMMAND_NONE; rv = apr_getopt_init(\u0026opt, p, argc, argv); while(apr_getopt(opt, \"I:Lc:m:i:d:SF:B:\", \u0026ch, \u0026optarg) == APR_SUCCESS) { switch (ch) { case 'I': request = COMMAND_INSTALL; url = optarg; break; case 'L': request = COMMAND_LIST; break; case 'c': config_opts = optarg; break; case 'm': make_opts = optarg; break; case 'i': install_opts = optarg; break; case 'S': request = COMMAND_INIT; break; case 'F': request = COMMAND_FETCH; url = optarg; break; case 'B': request = COMMAND_BUILD; url = optarg; break; } } switch(request) { case COMMAND_INSTALL: check(url, \"You must at least give a URL.\"); Command_install(p, url, config_opts, make_opts, install_opts); break; case COMMAND_LIST: DB_list(); break; case COMMAND_FETCH: check(url != NULL, \"You must give a URL.\"); Command_fetch(p, url, 1); log_info(\"Downloaded to %s and in /tmp/\", BUILD_DIR); break; case COMMAND_BUILD: check(url, \"You must at least give a URL.\"); Command_build(p, url, config_opts, make_opts, install_opts); break; case COMMAND_INIT: rv = DB_init(); check(rv == 0, \"Failed to make the database.\"); break; default: sentinel(\"Invalid command given.\"); } return 0; error: return 1; } 挑战4：README 和测试文件 link为这个文件设置的挑战是理解参数如何处理，以及参数是什么，之后创建含有使用指南的README文件。在编写README的同时，也编写一个简单的simple.sh，它运行./devpkg来检查每个命令都在实际环境下工作。在你的脚本顶端使用set -e，使它跳过第一个错误。\n最后，在Valgrind下运行程序，确保在进行下一步之前，所有东西都能正常运行。\n期中检测 link最后的挑战就是这个期中检测，它包含三件事情：\n将你的代码与我的在线代码对比，以100%的分数开始，每错一行减去1%。 在你的notes.txt中记录你是如何改进代码和devpkg的功能，并且实现你的改进。 编写一个devpkg的替代版本，使用其他你喜欢的语言，或者你觉得最适合编写它的语言。对比二者，之后基于你的结果改进你的devpkg的C版本。 你可以执行下列命令来将你的代码与我的对比：\ncd .. # get one directory above your current one git clone git://gitorious.org/devpkg/devpkg.git devpkgzed diff -r devpkg devpkgzed 这将会克隆我的devpkg版本到devpkgzed目录中。之后使用工具diff来对比你的和我的代码。书中你所使用的这些文件直接来自于这个项目，所以如果出现了不同的行，肯定就有错误。\n要记住这个练习没有真正的及格或不及格，它只是一个方式来让你挑战自己，并尽可能变得精确和谨慎。\n"
            }
        );
    index.add(
            {
                id:  37 ,
                href: "\/TechDocs\/docs\/c-guide\/ex27\/",
                title: "练习27：创造性和防御性编程",
                description: "原文：Exercise 27: Creative And Defensive Programming 译者：飞龙 你已经学到了大多数C语言的基础，并且准备好开始成为一个更严谨的程序员了。这里就是从初学者走向专家的地方，不仅仅对于C，更对于核心的计算机科学概念。我将会教给你一些核心的数据结构和算法，它们是每个程序员都要懂的，还有一些我在真实程序中所使用的一些非常有趣的东西。 在我开始之前，我需要教给你一些基本的技巧和观念，它们能帮助你编写更好的软件。练习27到31会教给你高级的概念和特性，而不是谈论编程，但是这些之后你将会应用它们来编写核心库或有用的数据结构。 编写更好的C代码（实际上是所有语言）的第一步是，学习一种新的观念叫做“防御性编程”。防御性编程假设你可能会制造出很多错误，之后尝试在每一步尽可能预防它们。这个练习中我打算教给你如何以防御性的思维来思考编程。 创造性编程思维 link在这个简单的练习中要告诉你如何做到创造性是不可能的，但是我会告诉你一些涉及到任务风险和开放思维的创造力。恐惧会快速地扼杀创造力，所以我采用，并且许多程序员也采用的这种思维方式使我不会惧怕风险，并且看上去像个傻瓜。 我不会犯错误。 人们所想的并不重要。 我脑子里面诞生的想法才是最好的。 我只是暂时接受了这种思维，并且在应用中用了一些小技巧。为了这样做我会提出一些想法，寻找创造性的解决方案，开一些奇奇怪怪的脑洞，并且不会害怕发明一些古怪的东西。在这种思维方式下，我通常会编写出第一个版本的糟糕代码，用于将想法描述出来。 然而，当我完成我的创造性原型时，我会将它扔掉，并且将它变得严谨和可考。其它人在这里常犯的一个错误就是将创造性思维引入它们的实现阶段。这样会产生一种非常不同的破坏性思维，它是创造性思维的阴暗面： 编写完美的软件是可行的。 我的大脑告诉我了真相，它不会发现任何错误，所以我写了完美的软件。 我的代码就是我自己，批判它的人也在批判我。 这些都是错误的。你经常会碰到一些程序员，它们对自己创造的软件具有强烈的荣誉感。这很正常，但是这种荣誉感会成为客观上改进作品的阻力。由于这种荣誉感和它们对作品的依恋，它们会一直相信它们编写的东西是完美的。只要它们忽视其它人的对这些代码的观点，它们就可以保护它们的玻璃心，并且永远不会改进。 同时具有创造性思维和编写可靠软件的技巧是，采用防御性编程的思维。 防御性编程思维 link在你做出创造性原型，并且对你的想法感觉良好之后，就应该切换到防御性思维了。防御性思维的程序员大致上会否定你的代码，并且相信下面这些事情： 软件中存在错误。 你并不是你的软件，但你需要为错误负责。 你永远不可能消除所有错误，只能降低它们的可能性。 这种思维方式让你诚实地对待你的代码，并且为改进批判地分析它。注意上面并没有说你充满了错误，只是说你的代码充满错误。这是一个需要理解的关键，因为它给了你编写下一个实现的客观力量。 就像创造性思维，防御性编程思维也有阴暗面。防御性程序员是一个惧怕任何事情的偏执狂，这种恐惧使他们远离可能的错误或避免犯错误。当你尝试做到严格一致或正确时这很好，但是它是创造力和专注的杀手。 八个防御性编程策略 link一旦你接受了这一思维，你可以重新编写你的原型，并且遵循下面的八个策略，它们被我用于尽可能把代码变得可靠。当我编写代码的“实际”版本，我会严格按照下面的策略，并且尝试消除尽可能多的错误，以一些会破坏我软件的人的方式思考。 永远不要信任输入 永远不要提供的输入，并总是校验它。 避免错误 如果错误可能发生，不管可能性多低都要避免它。 过早暴露错误 过早暴露错误，并且评估发生了什么、在哪里发生以及如何修复。 记录假设 清楚地记录所有先决条件，后置条件以及不变量。 防止过多的文档 不要在实现阶段就编写文档，它们可以在代码完成时编写。 使一切自动化 使一切自动化，尤其是测试。 简单化和清晰化 永远简化你的代码，在没有牺牲安全性的同时变得最小和最整洁。 质疑权威 不要盲目遵循或拒绝规则。 这些并不是全部，仅仅是一些核心的东西，我认为程序员应该在编程可靠的代码时专注于它们。要注意我并没有真正说明如何具体做到这些，我接下来会更细致地讲解每一条，并且会布置一些覆盖它们的练习。 应用这八条策略 link这些观点都是一些流行心理学的陈词滥调，但是你如何把它们应用到实际编程中呢？我现在打算向你展示这本书中的一些代码所做的事情，这些代码用具体的例子展示每一条策略。这八条策略并不止于这些例子，你应该使用它们作为指导，使你的代码更可靠。 永远不要信任输入 link让我们来看一个坏设计和“更好”的设计的例子。我并不想称之为好设计，因为它可以做得更好。看一看这两个函数，它们都复制字符串，main函数用于测试哪个更好。 undef NDEBUG #include \"dbg.h\" #include #include /* * Naive copy that assumes all inputs are always valid * taken from K\u0026R C and cleaned up a bit.",
                content: " 原文：Exercise 27: Creative And Defensive Programming\n译者：飞龙\n你已经学到了大多数C语言的基础，并且准备好开始成为一个更严谨的程序员了。这里就是从初学者走向专家的地方，不仅仅对于C，更对于核心的计算机科学概念。我将会教给你一些核心的数据结构和算法，它们是每个程序员都要懂的，还有一些我在真实程序中所使用的一些非常有趣的东西。\n在我开始之前，我需要教给你一些基本的技巧和观念，它们能帮助你编写更好的软件。练习27到31会教给你高级的概念和特性，而不是谈论编程，但是这些之后你将会应用它们来编写核心库或有用的数据结构。\n编写更好的C代码（实际上是所有语言）的第一步是，学习一种新的观念叫做“防御性编程”。防御性编程假设你可能会制造出很多错误，之后尝试在每一步尽可能预防它们。这个练习中我打算教给你如何以防御性的思维来思考编程。\n创造性编程思维 link在这个简单的练习中要告诉你如何做到创造性是不可能的，但是我会告诉你一些涉及到任务风险和开放思维的创造力。恐惧会快速地扼杀创造力，所以我采用，并且许多程序员也采用的这种思维方式使我不会惧怕风险，并且看上去像个傻瓜。\n我不会犯错误。 人们所想的并不重要。 我脑子里面诞生的想法才是最好的。 我只是暂时接受了这种思维，并且在应用中用了一些小技巧。为了这样做我会提出一些想法，寻找创造性的解决方案，开一些奇奇怪怪的脑洞，并且不会害怕发明一些古怪的东西。在这种思维方式下，我通常会编写出第一个版本的糟糕代码，用于将想法描述出来。\n然而，当我完成我的创造性原型时，我会将它扔掉，并且将它变得严谨和可考。其它人在这里常犯的一个错误就是将创造性思维引入它们的实现阶段。这样会产生一种非常不同的破坏性思维，它是创造性思维的阴暗面：\n编写完美的软件是可行的。 我的大脑告诉我了真相，它不会发现任何错误，所以我写了完美的软件。 我的代码就是我自己，批判它的人也在批判我。 这些都是错误的。你经常会碰到一些程序员，它们对自己创造的软件具有强烈的荣誉感。这很正常，但是这种荣誉感会成为客观上改进作品的阻力。由于这种荣誉感和它们对作品的依恋，它们会一直相信它们编写的东西是完美的。只要它们忽视其它人的对这些代码的观点，它们就可以保护它们的玻璃心，并且永远不会改进。\n同时具有创造性思维和编写可靠软件的技巧是，采用防御性编程的思维。\n防御性编程思维 link在你做出创造性原型，并且对你的想法感觉良好之后，就应该切换到防御性思维了。防御性思维的程序员大致上会否定你的代码，并且相信下面这些事情：\n软件中存在错误。 你并不是你的软件，但你需要为错误负责。 你永远不可能消除所有错误，只能降低它们的可能性。 这种思维方式让你诚实地对待你的代码，并且为改进批判地分析它。注意上面并没有说你充满了错误，只是说你的代码充满错误。这是一个需要理解的关键，因为它给了你编写下一个实现的客观力量。\n就像创造性思维，防御性编程思维也有阴暗面。防御性程序员是一个惧怕任何事情的偏执狂，这种恐惧使他们远离可能的错误或避免犯错误。当你尝试做到严格一致或正确时这很好，但是它是创造力和专注的杀手。\n八个防御性编程策略 link一旦你接受了这一思维，你可以重新编写你的原型，并且遵循下面的八个策略，它们被我用于尽可能把代码变得可靠。当我编写代码的“实际”版本，我会严格按照下面的策略，并且尝试消除尽可能多的错误，以一些会破坏我软件的人的方式思考。\n永远不要信任输入\n永远不要提供的输入，并总是校验它。\n避免错误\n如果错误可能发生，不管可能性多低都要避免它。\n过早暴露错误\n过早暴露错误，并且评估发生了什么、在哪里发生以及如何修复。\n记录假设\n清楚地记录所有先决条件，后置条件以及不变量。\n防止过多的文档\n不要在实现阶段就编写文档，它们可以在代码完成时编写。\n使一切自动化\n使一切自动化，尤其是测试。\n简单化和清晰化\n永远简化你的代码，在没有牺牲安全性的同时变得最小和最整洁。\n质疑权威\n不要盲目遵循或拒绝规则。\n这些并不是全部，仅仅是一些核心的东西，我认为程序员应该在编程可靠的代码时专注于它们。要注意我并没有真正说明如何具体做到这些，我接下来会更细致地讲解每一条，并且会布置一些覆盖它们的练习。\n应用这八条策略 link这些观点都是一些流行心理学的陈词滥调，但是你如何把它们应用到实际编程中呢？我现在打算向你展示这本书中的一些代码所做的事情，这些代码用具体的例子展示每一条策略。这八条策略并不止于这些例子，你应该使用它们作为指导，使你的代码更可靠。\n永远不要信任输入 link让我们来看一个坏设计和“更好”的设计的例子。我并不想称之为好设计，因为它可以做得更好。看一看这两个函数，它们都复制字符串，main函数用于测试哪个更好。\nundef NDEBUG #include \"dbg.h\" #include #include /* * Naive copy that assumes all inputs are always valid * taken from K\u0026R C and cleaned up a bit. */ void copy(char to[], char from[]) { int i = 0; // while loop will not end if from isn't '\\0' terminated while((to[i] = from[i]) != '\\0') { ++i; } } /* * A safer version that checks for many common errors using the * length of each string to control the loops and termination. */ int safercopy(int from_len, char *from, int to_len, char *to) { assert(from != NULL \u0026\u0026 to != NULL \u0026\u0026 \"from and to can't be NULL\"); int i = 0; int max = from_len \u003e to_len - 1 ? to_len - 1 : from_len; // to_len must have at least 1 byte if(from_len \u003c 0 || to_len \u003c= 0) return -1; for(i = 0; i \u003c max; i++) { to[i] = from[i]; } to[to_len - 1] = '\\0'; return i; } int main(int argc, char *argv[]) { // careful to understand why we can get these sizes char from[] = \"0123456789\"; int from_len = sizeof(from); // notice that it's 7 chars + \\0 char to[] = \"0123456\"; int to_len = sizeof(to); debug(\"Copying '%s':%d to '%s':%d\", from, from_len, to, to_len); int rc = safercopy(from_len, from, to_len, to); check(rc \u003e 0, \"Failed to safercopy.\"); check(to[to_len - 1] == '\\0', \"String not terminated.\"); debug(\"Result is: '%s':%d\", to, to_len); // now try to break it rc = safercopy(from_len * -1, from, to_len, to); check(rc == -1, \"safercopy should fail #1\"); check(to[to_len - 1] == '\\0', \"String not terminated.\"); rc = safercopy(from_len, from, 0, to); check(rc == -1, \"safercopy should fail #2\"); check(to[to_len - 1] == '\\0', \"String not terminated.\"); return 0; error: return 1; } copy函数是典型的C代码，而且它是大量缓冲区溢出的来源。它有缺陷，因为它总是假设接受到的是合法的C字符串（带有'\\0'），并且只是用一个while循环来处理。问题是，确保这些是十分困难的，并且如果没有处理好，它会使while循环无限执行。编写可靠代码的一个要点就是，不要编写可能不会终止的循环。\nsafecopy函数尝试通过要求调用者提供两个字符串的长度来解决问题。它可以执行有关这些字符串的、copy函数不具备的特定检查。他可以保证长度正确，to字符串具有足够的容量，以及它总是可终止。这个函数不像copy函数那样可能会永远执行下去。\n这个就是永远不信任输入的实例。如果你假设你的函数要接受一个没有终止标识的字符串（通常是这样），你需要设计你的函数，不要依赖字符串本身。如果你想让参数不为NULL，你应该对此做检查。如果大小应该在正常范围内，也要对它做检查。你只需要简单假设调用你代码的人会把它弄错，并且使他们更难破坏你的函数。\n这个可以扩展到从外部环境获取输入的的软件。程序员著名的临终遗言是，“没人会这样做。”我看到他们说了这句话后，第二天有人就这样做，黑掉或崩溃它们的应用。如果你说没有人会这样做，那就加固代码来保证他们不会简单地黑掉你的应用。你会因所做的事情而感到高兴。\n这种行为会出现收益递减。下面是一个清单，我会尝试对我用C写的每个函数做如下工作：\n对于每一个参数定义它的先决条件，以及这个条件是否导致失效或返回错误值。如果你在编写一个库，比起失效要更倾向于错误。 对于每个先决条件，使用assert(test \u0026\u0026 \"message\");在最开始添加assert检查。这句代码会执行检查，失败时OS通常会打印断言行，通常它包括信息。当你尝试弄清assert为什么在这里时，这会非常有用。 对于其它先决条件，返回错误代码或者使用我的check宏来执行它并且提供错误信息。我在这个例子中没有使用check，因为它会混淆比较。 记录为什么存在这些先决条件，当一个程序员碰到错误时，他可以弄清楚这些是否是真正必要的。 如果你修改了输入，确保当函数退出或中止时它们也会正确产生。 总是要检查所使用的函数的错误代码。例如，人们有时会忘记检查fopen或fread的返回代码，这会导致他们在错误下仍然使用这个资源。这会导致你的程序崩溃或者易受攻击。 你也需要返回一致的错误代码，以便对你的每个函数添加相同的机制。一旦你熟悉了这一习惯，你就会明白为什么我的check宏这样工作。 只是这些微小的事情就会改进你的资源处理方式，并且避免一大堆错误。\n避免错误 link上一个例子中你可能会听到别人说，“程序员不会经常错误地使用copy。”尽管大量攻击都针对这类函数，他们仍旧相信这种错误的概率非常低。概率是个很有趣的事情，因为人们不擅长猜测所有事情的概率，这非常难以置信。然而人们对于判断一个事情是否可能，是很擅长的。他们可能会说copy中的错误不常见，但是无法否认它可能发生。\n关键的原因是对于一些常见的事情，它首先是可能的。判断可能性非常简单，因为我们都知道事情如何发生。但是随后判断出概率就不是那么容易了。人们错误使用copy的情况会占到20%、10%，或1%？没有人知道。为了弄清楚你需要收集证据，统计许多软件包中的错误率，并且可能需要调查真实的程序员如何使用这个函数。\n这意味着，如果你打算避免错误，你不需要尝试避免可能发生的事情，而是要首先集中解决概率最大的事情。解决软件所有可能崩溃的方式并不可行，但是你可以尝试一下。同时，如果你不以最少的努力解决最可能发生的事件，你就是在不相关的风险上浪费时间。\n下面是一个决定避免什么的处理过程：\n列出所有可能发生的错误，无论概率大小，并带着它们的原因。不要列出外星人可能会监听内存来偷走密码这样的事情。 评估每个的概率，使用危险行为的百分比来表示。如果你处理来自互联网的情况，那么则为可能出现错误的请求的百分比。如果是函数调用，那么它是出现错误的函数调用百分比。 评估每个的工作量，使用避免它所需的代码量或工作时长来表示。你也可以简单给它一个“容易”或者“难”的度量。当需要修复的简单错误仍在列表上时，任何这种度量都可以让你避免做无谓的工作。 按照工作量（低到高）和概率（高到低）排序，这就是你的任务列表。 之后避免你在列表中列出的任何错误，如果你不能消除它的可能性，要降低它的概率。 如果存在你不能修复的错误，记录下来并提供给可以修复的人。 这一微小的过程会产生一份不错的待办列表。更重要的是，当有其它重要的事情需要解决时，它让你远离劳而无功。你也可以更正式或更不正式地处理这一过程。如果你要完成整个安全审计，你最好和团队一起做，并且有个更详细的电子表格。如果你只是编写一个函数，简单地复查代码之后划掉它们就够了。最重要的是你要停止假设错误不会发生，并且着力于消除它们，这样就不会浪费时间。\n过早暴露错误 link如果你遇到C中的错误，你有两个选择：\n返回错误代码。 中止进程。 这就是处理方法，你需要执行它来确保错误尽快发生，记录清楚，提供错误信息，并且易于程序员来避免它。这就是我提供的check宏这样工作的原因。对于每一个错误，你都要让它你打印信息、文件名和行号，并且强制返回错误代码。如果你使用了我的宏，你会以正确的方式做任何事情。\n我倾向于返回错误代码而不是终止程序。如果出现了大错误我会中止程序，但是实际上我很少碰到大错误。一个需要中止程序的很好例子是，我获取到了一个无效的指针，就像safecopy中那样。我没有让程序在某个地方产生“段错误”，而是立即捕获并中止。但是，如果传入NULL十分普遍，我可能会改变方式而使用check来检查，以保证调用者可以继续运行。\n然而在库中，我尽我最大努力永不中止。使用我的库的软件可以决定是否应该中止。如果这个库使用非常不当，我才会中止程序。\n最后，关于“暴露”的一大部分内容是，不要对多于一个错误使用相同的信息或错误代码。你通常会在外部资源的错误中见到这种情况。比如一个库捕获了套接字上的错误，之后简单报告“套接字错误”。它应该做的是返回具体的信息，比如套接字上发生了什么错误，使它可以被合理地调试和修复。当你设计错误报告时，确保对于不同的错误你提供了不同的错误消息。\n记录假设 link如果你遵循并执行了这个建议，你就构建了一份“契约”，关于函数期望这个世界是什么样子。你已经为每个参数预设了条件，处理潜在的错误，并且优雅地产生失败。下一步是完善这一契约，并且添加“不变量”和“后置条件”。\n不变量就是在函数运行时，一些场合下必须恒为真的条件。这对于简单的函数并不常见，但是当你处理复杂的结构时，它会变得很必要。一个关于不变量的很好的例子是，结构体在使用时都会合理地初始化。另一个是有序的数据结构在处理时总是排好序的。\n后置条件就是退出值或者函数运行结果的保证。这可以和不变了混在一起，但是也可以是一些很简单的事情，比如“函数应总是返回0，或者错误时返回-1”。通常这些都有文档记录，但是如果你的函数返回一个分配的资源，你应该添加一个后置条件，做检查来确保它返回了一个不为NULL的东西。或者，你可以使用NULL来表示错误，这种情况下，你的后置条件就是资源在任何错误时都会被释放。\n在C编程中，不变量和后置条件都通常比实际的代码和断言更加文档化。处理它们的最好当时就是尽可能添加assert调用，之后记录剩下的部分。如果你这么做了，当其它人碰到错误时，他们可以看到你在编写函数时做了什么假设。\n避免过多文档 link程序员编写代码时的一个普遍问题，就是他们会记录一个普遍的bug，而不是简单地修复它。我最喜欢的方式是，Ruby on Rails系统只是简单地假设所有月份都有30天。日历太麻烦了，所以与其修复它，不如在一些地方放置一个小的注释，说这是故意的，并且几年内都不会改正。每次一些人试图抱怨它时，他们都会说，“文档里面都有！”\n如果你能够实际修复问题，文档并不重要，并且，如果函数具有严重的缺陷，你在修复它之前可以不记录它。在Ruby on Rails的例子中，不包含日期函数会更好一些，而不是包含一个没人会用的错误的函数。\n当你为防御性编程执行清理时，尽可能尝试修复任何事情。如果你发现你记录了越来越多的，你不能修复的事情，需要考虑重新设计特性，或简单地移除它。如果你真的需要保留这一可怕的错误的特性，那么我建议你编写它、记录它，并且在你受责备之前找一份新的工作。\n使一切自动化 link你是个程序员，这意味着你的工作是通过自动化消灭其它人的工作。它的终极目标是使用自动化来使你自己也失业。很显然你不应该完全消除你做的东西，但如果你花了一整天在终端上重复运行手动测试，你的工作就不是编程。你只是在做QA，并且你应该使自己自动化，消除这个你可能并不是真的想干的QA工作。\n实现它的最简单方式就是编写自动化测试，或者单元测试。这本书里我打算讲解如何使它更简单，并且我会避免多数编写测试的信条。我只会专注于如何编写它们，测试什么，以及如何使测试更高效。\n下面是程序员没有但是应该自动化的一些事情：\n测试和校验。 构建过程。 软件部署。 系统管理。 错误报告。 尝试花一些时间在自动化上面，你会有更多的时间用来处理一些有趣的事情。或者，如果这对你来说很有趣，也许你应该编写自动化完成这些事情的软件。\n简单化和清晰化 link“简单性”的概念对许多人来说比较微妙，尤其是一些聪明人。它们通常将“内涵”与“简单性”混淆起来。如果他们很好地理解了它，很显然非常简单。简单性的测试是通过将一个东西与比它更简单的东西比较。但是，你会看到编写代码的人会使用最复杂的、匪夷所思的数据结构，因为它们认为做同样事情的简单版本非常“恶心”。对复杂性的爱好是程序员的弱点。\n你可以首先通过告诉自己，“简单和清晰并不恶心，无论谁在干什么事情”来战胜这一弱点。如果其它人编写了愚蠢的观察者模式涉及到19个类，12个接口，而你只用了两个字符串操作就可以实现它，那么你赢了。他们就是错了，无论他们认为自己的复杂设计有多么高大上。\n对于要使用哪个函数的最简单测试是：\n确保所有函数都没有问题。如果它有错误，它有多快或多简单就不重要了。 如果你不能修复问题，就选择另外一个。 它们会产生相同结果嘛？如果不是就挑选具有所需结果的函数。 如果它们会产生相同结果，挑选包含更少特性，更少分支的那个，或者挑选你认为最简单的那个。 确保你没有只是挑选最具有表现力的那个。无论怎么样，简单和清晰，都会战胜复杂和恶心。 你会注意到，最后我一般会放弃并告诉你根据你的判断。简单性非常讽刺地是一件复杂的事情，所以使用你的品位作为指引是最好的方式。只需要确保在你获取更多经验之后，你会调整你对于什么是“好”的看法。\n质疑权威 link最后一个策略是最重要的，因为它让你突破防御性编程思维，并且让你转换为创造性思维。防御性编程是权威性的，并且比较无情。这一思维方式的任务是让你遵循规则，因为否则你会错失一些东西或心烦意乱。\n这一权威性的观点的坏处是扼杀了独立的创造性思维。规则对于完成事情是必要的，但是做它们的奴隶会扼杀你的创造力。\n这条最后的策略的意思是你应该周期性地质疑你遵循的规则，并且假设它们都是错误的，就像你之前复查的软件那样。在一段防御性编程的时间之后，我通常会这样做，我会拥有一个不编程的休息并让这些规则消失。之后我会准备好去做一些创造性的工作，或按需做更多的防御型编程。\n顺序并不重要 link在这一哲学上我想说的最后一件事，就是我并不是告诉你要按照一个严格的规则，比如“创造！防御！创造！防御！”去做这件事。最开始你可能想这样做，但是我实际上会做不等量的这些事情，取决于我想做什么，并且我可能会将二者融合到一起，没有明确的边界。\n我也不认为其中一种思维会优于另一种，或者它们之间有严格的界限。你需要在编程上既有创造力也要严格，所以如果想要提升的话，需要同时做到它们。\n附加题 link 到现在为止（以及以后）书中的代码都可能违反这些规则。回退并挑选一个练习，将你学到的应用在它上面，来看看你能不能改进它或发现bug。 寻找一个开源项目，对其中一些文件进行类似的代码复查。如果你发现了bug，提交一个补丁来修复它。 "
            }
        );
    index.add(
            {
                id:  38 ,
                href: "\/TechDocs\/docs\/c-guide\/ex28\/",
                title: "练习28：Makefile 进阶",
                description: "原文：Exercise 28: Intermediate Makefiles\n译者：飞龙\n在下面的三个练习中你会创建一个项目的目录框架，用于构建之后的C程序。这个目录框架会在这本书中剩余的章节中使用，并且这个练习中我会涉及到Makefile便于你理解它。\n这个结构的目的是，在不凭借配置工具的情况下，使构建中等规模的程序变得容易。如果完成了它，你会学到很多GNU make和一些小型shell脚本方面的东西。\n基本的项目结构 link首先要做的事情是创建一个C的目录框架，并且放置一些多续项目都拥有的，基本的文件和目录。这是我的目录：\n$ mkdir c-skeleton $ cd c-skeleton/ $ touch LICENSE README.md Makefile $ mkdir bin src tests $ cp dbg.h src/ # this is from Ex20 $ ls -l total 8 -rw-r--r-- 1 zedshaw staff 0 Mar 31 16:38 LICENSE -rw-r--r-- 1 zedshaw staff 1168 Apr 1 17:00 Makefile -rw-r--r-- 1 zedshaw staff 0 Mar 31 16:38 README.md drwxr-xr-x 2 zedshaw staff 68 Mar 31 16:38 bin drwxr-xr-x 2 zedshaw staff 68 Apr 1 10:07 build drwxr-xr-x 3 zedshaw staff 102 Apr 3 16:28 src drwxr-xr-x 2 zedshaw staff 68 Mar 31 16:38 tests $ ls -l src total 8 -rw-r--r-- 1 zedshaw staff 982 Apr 3 16:28 dbg.",
                content: " 原文：Exercise 28: Intermediate Makefiles\n译者：飞龙\n在下面的三个练习中你会创建一个项目的目录框架，用于构建之后的C程序。这个目录框架会在这本书中剩余的章节中使用，并且这个练习中我会涉及到Makefile便于你理解它。\n这个结构的目的是，在不凭借配置工具的情况下，使构建中等规模的程序变得容易。如果完成了它，你会学到很多GNU make和一些小型shell脚本方面的东西。\n基本的项目结构 link首先要做的事情是创建一个C的目录框架，并且放置一些多续项目都拥有的，基本的文件和目录。这是我的目录：\n$ mkdir c-skeleton $ cd c-skeleton/ $ touch LICENSE README.md Makefile $ mkdir bin src tests $ cp dbg.h src/ # this is from Ex20 $ ls -l total 8 -rw-r--r-- 1 zedshaw staff 0 Mar 31 16:38 LICENSE -rw-r--r-- 1 zedshaw staff 1168 Apr 1 17:00 Makefile -rw-r--r-- 1 zedshaw staff 0 Mar 31 16:38 README.md drwxr-xr-x 2 zedshaw staff 68 Mar 31 16:38 bin drwxr-xr-x 2 zedshaw staff 68 Apr 1 10:07 build drwxr-xr-x 3 zedshaw staff 102 Apr 3 16:28 src drwxr-xr-x 2 zedshaw staff 68 Mar 31 16:38 tests $ ls -l src total 8 -rw-r--r-- 1 zedshaw staff 982 Apr 3 16:28 dbg.h $ 之后你会看到我执行了ls -l，所以你会看到最终结果。\n下面是每个文件所做的事情：\nLICENSE\n如果你在项目中发布源码，你会希望包含一份协议。如果你不这么多，虽然你有代码的版权，但是通常没有人有权使用。\nREADME.md\n对你项目的简要说明。它以.md结尾，所以应该作为Markdown来解析。\nMakefile\n这个项目的主要构建文件。\nbin/\n放置可运行程序的地方。这里通常是空的，Makefile会在这里生成程序。\nbuild/\n当值库和其它构建组件的地方。通常也是空的，Makefile会在这里生成这些东西。\nsrc/\n放置源码的地方，通常是.c和.h文件。\ntests/\n放置自动化测试的地方。\nsrc/dbg.h\n我将练习20的dbg.h复制到了这里。\n我刚才分解了这个项目框架的每个组件，所以你应该明白它们怎么工作。\nMakefile link我要讲到的第一件事情就是Makefile，因为你可以从中了解其它东西的情况。这个练习的Makeile比之前更加详细，所以我会在你输入它之后做详细的分解。\nCFLAGS=-g -O2 -Wall -Wextra -Isrc -rdynamic -DNDEBUG $(OPTFLAGS) LIBS=-ldl $(OPTLIBS) PREFIX?=/usr/local SOURCES=$(wildcard src/**/*.c src/*.c) OBJECTS=$(patsubst %.c,%.o,$(SOURCES)) TEST_SRC=$(wildcard tests/*_tests.c) TESTS=$(patsubst %.c,%,$(TEST_SRC)) TARGET=build/libYOUR_LIBRARY.a SO_TARGET=$(patsubst %.a,%.so,$(TARGET)) all: $(TARGET) $(SO_TARGET) tests dev: CFLAGS=-g -Wall -Isrc -Wall -Wextra $(OPTFLAGS) dev: all $(TARGET): CFLAGS += -fPIC $(TARGET): build $(OBJECTS) ar rcs $@ $(OBJECTS) ranlib $@ $(SO_TARGET): $(TARGET) $(OBJECTS) $(CC) -shared -o $@ $(OBJECTS) build: @mkdir -p build @mkdir -p bin .PHONY: tests tests: CFLAGS += $(TARGET) tests: $(TESTS) sh ./tests/runtests.sh valgrind: VALGRIND=\"valgrind --log-file=/tmp/valgrind-%p.log\" $(MAKE) clean: rm -rf build $(OBJECTS) $(TESTS) rm -f tests/tests.log find . -name \"*.gc*\" -exec rm {} \\; rm -rf `find . -name \"*.dSYM\" -print` install: all install -d $(DESTDIR)/$(PREFIX)/lib/ install $(TARGET) $(DESTDIR)/$(PREFIX)/lib/ BADFUNCS='[^_.\u003ea-zA-Z0-9](str(n?cpy|n?cat|xfrm|n?dup|str|pbrk|tok|_)|stpn?cpy|a?sn?printf|byte_)' check: @echo Files with potentially dangerous functions. @egrep $(BADFUNCS) $(SOURCES) || true 要记住你应该使用一致的Tab字符来缩进Makefile。你的编辑器应该知道怎么做，但是如果不是这样你可以换个编辑器。没有程序员会使用一个连如此简单的事情都做不好的编辑器。\n头部 link这个Makefile设计用于构建一个库，我们之后会用到它，并且通过使用GNU make的特殊特性使它在任何平台上都可用。我会在这一节拆分它的每一部分，先从头部开始。\nMakefile:1\n这是通常的CFLAGS，几乎每个项目都会设置，但是带有用于构建库的其它东西。你可能需要为不同平台调整它。要注意最后的OPTFLAGS变量可以让使用者按需扩展构建选项。\nMakefile:2\n用于链接库的选项，同样也允许其它人使用OPTFLAGS变量扩展链接选项。\nMakefile:3\n设置一个叫做PREFIX的可选变量，它只在没有PREFIX设置的平台上运行Makefile时有效。这就是?=的作用。\nMakefile:5\n这神奇的一行通过执行wildcard搜索在src/中所有*.c文件来动态创建SOURCES变量。你需要提供src/**/*.c和src/*.c以便GNU make能够包含src目录及其子目录的所有此类文件。\nMakefile:6\n一旦你创建了源文件列表，你可以使用patsubst命令获取*.c文件的SOURCES来创建目标文件的新列表。你可以告诉patsubst把所有%.c扩展为%.o，并将它们赋给OBJECTS。\nMakefile:8\n再次使用wildcard来寻找所有用于单元测试的测试源文件。它们存放在不同的目录中。\nMakefile:9\n之后使用相同的patsubst技巧来动态获得所有TEST目标。其中我去掉了.c后缀，使整个程序使用相同的名字创建。之前我将.c替换为.o来创建目标文件。\nMakefile:11\n最后，我将最终目标设置为build/libYOUR_LIBRARY.a，你可以为你实际构建的任何库来修改它。\n这就是Makefile的头部了，但是我应该对“让其他人扩展构建”做个解释。你在运行它的时候可以这样做：\n$ make PREFIX=/tmp install $ make OPTFLAGS=-pthread 如果你传入匹配Makefile中相同名称的变量，它们会在构建中生效。你可以利用它来修改Makefile的运行方式。第一条命令改变了PREFIX，使它安装到/tmp。第二条设置了OPTFLAGS，为之添加了pthread选项。\n构建目标 link我会继续Makefile的分解，这一部分用于构建目标文件（object file）和目标（target）：\nMakefile:14\n要记住在没有提供目标时make会默认运行第一个目标。这里它叫做all:，并且它提供了$(TARGET) tests作为构建目标。查看TARGET变量，你会发现这就是库文件，所以all:首先会构建出库文件。之后，tests目标会构建单元测试。\nMakefile:16\n另一个用于执行“开发者构建”的目标，它介绍了一种为单一目标修改选项的技巧，如果我执行“开发构建”，我希望CFLAGS包含类似Wextra这样用于发现bug的选项。如果你将它们放到目标的那行中，并再编写一行来指向原始目标（这里是all），那么它就会将改为你设置的选项。我通常将它用于在不同的平台上设置所需的不同选项。\nMakefile:19\n构建TARGET库，然而它同样使用了15行的技巧，向一个目标提供选项来为当前目标修改它们。这里我通过适用+=语法为库的构建添加了-fPIC。\nMakefile:20\n现在这一真实目标首先创建build目录，之后编译所有OBJECTS。\nMakefile:21\n运行实际创建TARGET的ar的命令。$@ $(OBJECTS)语法的意思是，将当前目标的名称放在这里，并把OBJECTS的内容放在后面。这里$@的值为19行的$(TARGET)，它实际上为build/libYOUR_LIBRARY.a。看起来在这一重定向中它做了很多跟踪工作，它也有这个功能，并且你可以通过修改顶部的TARGET，来构建一个全新的库。\nMakefile:22\n最后，在TARGET上运行ranlib来构建这个库。\nMakefile:24-24\n用于在build/和bin/目录不存在的条件下创建它们。之后它被19行引用，那里提供了build目标来确保build/目录已创建。\n你现在拥有了用于构建软件的所需的所有东西。之后我们会创建用于构建和运行单元测试的东西，来执行自动化测试。\n单元测试 linkC不同于其他语言，因为它更易于为每个需要测试的东西创建小型程序。一些测试框架试图模拟其他语言中的模块概念，并且执行动态加载，但是它在C中并不适用。这也不是必要的，因为你可以仅仅编写一个程序用于每个测试。\n我接下来会涉及到Makefile的这一部分，并且你会看到test/目录中真正起作用的内容。\nMakefile:29\n如果你拥有一个不是“真实”的目标，只有有个目录或者文件叫这个名字，你需要使用g.PHONY:标签来标记它，以便make忽略该文件。\nMakefile:30\n我使用了与修改CFLAGS变量相同的技巧，并且将TARGET添加到构建中，于是每个测试程序都会链接TARGET库。这里它会添加build/libYOUR_LIBRARY.a用于链接。\nMakefile:31\n之后我创建了实际的test:目录，它依赖于所有在TESTS变量中列出的程序。这一行实际上说，“Make，请使用你已知的程序构建方法，以及当前CFLAGS设置的内容来构建TESTS中的每个程序。”\nMakefile:32\n最后，所有TESTS构建完之后，会运行一个我稍后创建的简单shell脚本，它知道如何全部运行他们并报告它们的输出、这一行实际上运行它来让你看到测试结果。\nMakefile:34-35\n为了能够动态使用Valgrind重复运行测试，我创建了valgrind:标签，它设置了正确的变量并且再次运行它。它会将Valgrind的日志放到/tmp/valgrind-*.log，你可以查看并了解发生了什么。之后tests/runtests.sh看到VALGRIND变量时，它会明白要在Valgrind下运行测试程序。\n你需要为单元测试创建一个小型的shell脚本，它知道如何运行程序。我们开始创建这个tests/runtests.sh脚本：\necho \"Running unit tests:\" for i in tests/*_tests do if test -f $i then if $VALGRIND ./$i 2\u003e\u003e tests/tests.log then echo $i PASS else echo \"ERROR in test $i: here's tests/tests.log\" echo \"------\" tail tests/tests.log exit 1 fi fi done echo \"\" 当我提到单元测试如何工作时，我会在之后用到它。\n清理工具 link我已经有了用于单元测试的工具，所以下一步就是创建需要重置时的清理工具。\nMakefile:38\nclean:目标在我需要清理这个项目的任何时候都会执行清理。\nMakefile:39-42\n这会清理不同编译器和工具留下的多数垃圾。它也会移除build/目录并且使用了一个技巧来清理XCode为调试目的而留下的*.dSYM。\n如果你碰到了想要执行清理的垃圾，你只需要简单地扩展需要删除的文件列表。\n安装 link然后，我会需要一种安装项目的方法，对Makefile来说就是把构建出来的库放到通常的PREFIX目录下，它通常是/usr/local/lib。\nMakefile:45\n它会使install:依赖于all:目录，所以当你运行make install之后也会先确保一切都已构建。\nMakefile:46\n接下来我使用install程序来创建lib目标的目录。其中我通过使用两个为安装者提供便利的变量，尝试让安装尽可能灵活。DESTDIR交给安装者，便于在安全或者特定的目录里执行自己的构建。PREFIX在别人想要将项目安装到其它目录而不是/user/local时会被使用。\nMakefile:47\n在此之后我使用insyall来实际安装这个库，到它需要安装的地方。\ninstall程序的目的是确保这些事情都设置了正确的权限。当你运行make install时你通常使用root权限来执行，所以通常的构建过程应为make \u0026\u0026 sudo make install。\n检查工具 linkMakefile的最后一部分是个额外的部分，我把它包含在我的C项目中用于发现任何使用C中“危险”函数的情况。这些函数是字符串函数和另一些“不保护栈”的函数。\nMakefile:50\n设置变量，它是个稍大的正则表达式，用于检索类似strcpy的危险函数。\nMakefile:51\n这是check:目标，使你能够随时执行检查。\nMakefile:52\n它只是一个打印信息的方式，使用了@echo来告诉make不要打印命令，只需打印输出。\nMakefile:53\n对源文件运行egrep命令来寻找任何危险的字符串。最后的|| true是一种方法，用于防止make认为egrep没有找到任何东西是执行失败。\n当你执行它之后，它会表现得十分奇怪，如果没有任何危险的函数，你会得到一个错误。\n你会看到什么 link我在完成这个项目框架目录的构建之前，还设置了两个额外的练习。下面这是我对Makefile特性的测试结果：\n$ make clean rm -rf build rm -f tests/tests.log find . -name \"*.gc*\" -exec rm {} \\; rm -rf `find . -name \"*.dSYM\" -print` $ make check Files with potentially dangerous functions. ^Cmake: *** [check] Interrupt: 2 $ make ar rcs build/libYOUR_LIBRARY.a ar: no archive members specified usage: ar -d [-TLsv] archive file ... ar -m [-TLsv] archive file ... ar -m [-abiTLsv] position archive file ... ar -p [-TLsv] archive [file ...] ar -q [-cTLsv] archive file ... ar -r [-cuTLsv] archive file ... ar -r [-abciuTLsv] position archive file ... ar -t [-TLsv] archive [file ...] ar -x [-ouTLsv] archive [file ...] make: *** [build/libYOUR_LIBRARY.a] Error 1 $ make valgrind VALGRIND=\"valgrind --log-file=/tmp/valgrind-%p.log\" make ar rcs build/libYOUR_LIBRARY.a ar: no archive members specified usage: ar -d [-TLsv] archive file ... ar -m [-TLsv] archive file ... ar -m [-abiTLsv] position archive file ... ar -p [-TLsv] archive [file ...] ar -q [-cTLsv] archive file ... ar -r [-cuTLsv] archive file ... ar -r [-abciuTLsv] position archive file ... ar -t [-TLsv] archive [file ...] ar -x [-ouTLsv] archive [file ...] make[1]: *** [build/libYOUR_LIBRARY.a] Error 1 make: *** [valgrind] Error 2 $ 当我运行clean:目标时它会生效，但是由于我在src/目录中并没有任何源文件，其它命令并没有真正起作用。我会在下个练习中补完它。\n附加题 link 尝试通过将源文件和头文件添加进src/，来使Makefile真正起作用，并且构建出库文件。在源文件中不应该需要main函数。 研究check:目标会使用BADFUNCS的正则表达式来寻找什么函数。 如果你没有做过自动化测试，查询有关资料为以后做准备。 "
            }
        );
    index.add(
            {
                id:  39 ,
                href: "\/TechDocs\/docs\/c-guide\/ex29\/",
                title: "练习29：库和链接",
                description: "原文：Exercise 29: Libraries And Linking 译者：飞龙 C语言编程的核心能力之一就是链接OS所提供的库。链接是一种为你的程序添加额外特性的方法，这些特性由其它人在系统中创建并打包。你已经使用了一些自动包含的标准库，但是我打算对库的不同类型和它们的作用做个解释。 首先，库在每个语言中都没有良好的设计。我不知道为什么，但是似乎语言的设计者都将链接视为不是特别重要的东西。它们通常令人混乱，难以使用，不能正确进行版本控制，并以不同的方式链接到各种地方。 C没有什么不同，但是C中的库和链接是Unix操作系统的组件，并且可执行的格式在很多年前就设计好了。学习C如何链接库有助于理解OS如何工作，以及它如何运行你的程序。 C中的库有两种基本类型： 静态 你可以使用ar和ranlib来构建它，就像上个练习中的libYOUR_LIBRARY.a那样（Windows下后缀为.lib）。这种库可以当做一系列.o对象文件和函数的容器，以及当你构建程序时，可以当做是一个大型的.o文件。 动态 它们通常以.so（Linux）或.dll（Windows）结尾。在OSX中，差不多有一百万种后缀，取决于版本和编写它的人。严格来讲，OSX中的.dylib，.bundle和framework这三个之间没什么不同。这些文件都被构建好并且放置到指定的地方。当你运行程序时，OS会动态加载这些文件并且“凭空”链接到你的程序中。 我倾向于对小型或中型项目使用静态的库，因为它们易于使用，并且工作在在更多操作系统上。我也喜欢将所有代码放入静态库中，之后链接它来执行单元测试，或者链接到所需的程序中。 动态库适用于大型系统，它的空间十分有限，或者其中大量程序都使用相同的功能。这种情况下不应该为每个程序的共同特性静态链接所有代码，而是应该将它放到动态库中，这样它仅仅会为所有程序加载一份。 在上一个练习中，我讲解了如何构建静态库（.a），我会在本书的剩余部分用到它。这个练习中我打算向你展示如何构建一个简单的.so库，并且如何使用Unix系统的dlopen动态加载它。我会手动执行它，以便你可以理解每件实际发生的事情。之后，附加题这部分会使用c项目框架来创建它。 动态加载动态库 link我创建了两个源文件来完成它。一个用于构建libex29.so库，另一个是个叫做ex29的程序，它可以加载这个库并运行其中的程序： #include #include #include \"dbg.h\" int print_a_message(const char *msg) { printf(\"A STRING: %s\\n\", msg); return 0; } int uppercase(const char *msg) { int i = 0; // BUG: \\0 termination problems for(i = 0; msg[i] != '\\0'; i++) { printf(\"%c\", toupper(msg[i])); } printf(\"\\n\"); return 0; } int lowercase(const char *msg) { int i = 0; // BUG: \\0 termination problems for(i = 0; msg[i] !",
                content: " 原文：Exercise 29: Libraries And Linking\n译者：飞龙\nC语言编程的核心能力之一就是链接OS所提供的库。链接是一种为你的程序添加额外特性的方法，这些特性由其它人在系统中创建并打包。你已经使用了一些自动包含的标准库，但是我打算对库的不同类型和它们的作用做个解释。\n首先，库在每个语言中都没有良好的设计。我不知道为什么，但是似乎语言的设计者都将链接视为不是特别重要的东西。它们通常令人混乱，难以使用，不能正确进行版本控制，并以不同的方式链接到各种地方。\nC没有什么不同，但是C中的库和链接是Unix操作系统的组件，并且可执行的格式在很多年前就设计好了。学习C如何链接库有助于理解OS如何工作，以及它如何运行你的程序。\nC中的库有两种基本类型：\n静态\n你可以使用ar和ranlib来构建它，就像上个练习中的libYOUR_LIBRARY.a那样（Windows下后缀为.lib）。这种库可以当做一系列.o对象文件和函数的容器，以及当你构建程序时，可以当做是一个大型的.o文件。\n动态\n它们通常以.so（Linux）或.dll（Windows）结尾。在OSX中，差不多有一百万种后缀，取决于版本和编写它的人。严格来讲，OSX中的.dylib，.bundle和framework这三个之间没什么不同。这些文件都被构建好并且放置到指定的地方。当你运行程序时，OS会动态加载这些文件并且“凭空”链接到你的程序中。\n我倾向于对小型或中型项目使用静态的库，因为它们易于使用，并且工作在在更多操作系统上。我也喜欢将所有代码放入静态库中，之后链接它来执行单元测试，或者链接到所需的程序中。\n动态库适用于大型系统，它的空间十分有限，或者其中大量程序都使用相同的功能。这种情况下不应该为每个程序的共同特性静态链接所有代码，而是应该将它放到动态库中，这样它仅仅会为所有程序加载一份。\n在上一个练习中，我讲解了如何构建静态库（.a），我会在本书的剩余部分用到它。这个练习中我打算向你展示如何构建一个简单的.so库，并且如何使用Unix系统的dlopen动态加载它。我会手动执行它，以便你可以理解每件实际发生的事情。之后，附加题这部分会使用c项目框架来创建它。\n动态加载动态库 link我创建了两个源文件来完成它。一个用于构建libex29.so库，另一个是个叫做ex29的程序，它可以加载这个库并运行其中的程序：\n#include #include #include \"dbg.h\" int print_a_message(const char *msg) { printf(\"A STRING: %s\\n\", msg); return 0; } int uppercase(const char *msg) { int i = 0; // BUG: \\0 termination problems for(i = 0; msg[i] != '\\0'; i++) { printf(\"%c\", toupper(msg[i])); } printf(\"\\n\"); return 0; } int lowercase(const char *msg) { int i = 0; // BUG: \\0 termination problems for(i = 0; msg[i] != '\\0'; i++) { printf(\"%c\", tolower(msg[i])); } printf(\"\\n\"); return 0; } int fail_on_purpose(const char *msg) { return 1; } 这里面没什么神奇之处。其中故意留了一些bug，看你是否注意到了。你需要在随后修复它们。\n我们将要使用dlopen，dlsym，和dlclose函数来处理上面的函数。\n#include #include \"dbg.h\" #include typedef int (*lib_function)(const char *data); int main(int argc, char *argv[]) { int rc = 0; check(argc == 4, \"USAGE: ex29 libex29.so function data\"); char *lib_file = argv[1]; char *func_to_run = argv[2]; char *data = argv[3]; void *lib = dlopen(lib_file, RTLD_NOW); check(lib != NULL, \"Failed to open the library %s: %s\", lib_file, dlerror()); lib_function func = dlsym(lib, func_to_run); check(func != NULL, \"Did not find %s function in the library %s: %s\", func_to_run, lib_file, dlerror()); rc = func(data); check(rc == 0, \"Function %s return %d for data: %s\", func_to_run, rc, data); rc = dlclose(lib); check(rc == 0, \"Failed to close %s\", lib_file); return 0; error: return 1; } 我现在会拆分这个程序，便于你理解这一小段代码其中的原理。\nex29.c:5\n我随后会使用这个函数指针定义，来调用库中的函数。这没什么新东西，确保你理解了它的作用。\nex29.c:17\n在为一个小型程序做必要的初始化后，我使用了dlopen函数来加载由lib_file表示的库。这个函数返回一个句柄，我们随后会用到它，就像来打开文件那样。\nex29.c:18\n如果出现错误，我执行了通常的检查并退出，但是要注意最后我使用了dlerror来查明发生了什么错误。\nex29.c:20\n我使用了dlsym来获取lib中的函数，通过它的字面名称func_to_run。这是最强大的部分，因为我动态获取了一个函数指针，基于我从命令行argv获得的字符串。\nex29.c:23\n接着我调用func函数，获得返回值并进行检查。\nex29.c:26\n最后，我像关闭文件那样关闭了库。通常你需要在程序的整个运行期间保证它们打开，所以关闭操作并不非常实用，我只是在这里演示它。\n译者注：由于能够使用系统调用加载，动态库可以被多种语言的程序调用，而静态库只能被C及兼容C的程序调用。\n你会看到什么 link既然你已经知道这些文件做什么了，下面是我的shell会话，用于构建libex29.so和ex29并随后运行它。下面的代码中你可以学到如何手动构建：\n$ cc -c libex29.c -o libex29.o $ cc -shared -o libex29.so libex29.o $ cc -Wall -g -DNDEBUG ex29.c -ldl -o ex29 $ ex29 ./libex29.so print_a_message \"hello there\" -bash: ex29: command not found $ ./ex29 ./libex29.so print_a_message \"hello there\" A STRING: hello there $ ./ex29 ./libex29.so uppercase \"hello there\" HELLO THERE $ ./ex29 ./libex29.so lowercase \"HELLO tHeRe\" hello there $ ./ex29 ./libex29.so fail_on_purpose \"i fail\" [ERROR] (ex29.c:23: errno: None) Function fail_on_purpose return 1 for data: i fail $ ./ex29 ./libex29.so fail_on_purpose [ERROR] (ex29.c:11: errno: None) USAGE: ex29 libex29.so function data $ ./ex29 ./libex29.so adfasfasdf asdfadff [ERROR] (ex29.c:20: errno: None) Did not find adfasfasdf function in the library libex29.so: dlsym(0x1076009b0, adfasfasdf): symbol not found $ ./ex29 ./libex.so adfasfasdf asdfadfas [ERROR] (ex29.c:17: errno: No such file or directory) Failed to open the library libex.so: dlopen(libex.so, 2): image not found $ 需要注意，你可能需要在不同OS、不同OS的不同版本，以及不同OS的不同版本的不同编译器上执行构建，则需要修改构建共享库的方式。如果我构建libex29.so的方式在你的平台上不起作用，请告诉我，我会为其它平台添加一些注解。\n译者注：到处编写、到处调试、到处编译、到处发布。–vczh\n‍\n注\n有时候你像往常一样运行cc -Wall -g -DNDEBUG -ldl ex29.c -o ex29，并且认为它能够正常工作，但是没有。在一些平台上，参数的顺序会影响到它是否生效，这也没什么理由。在Debian或者Ubuntu中你需要执行cc -Wall -g -DNDEBUG ex29.c -ldl -o ex29，这是唯一的方式。所以虽然我在这里使用了OSX，但是以后如果你链接动态库的时候它找不到某个函数，要试着自己解决问题。\n这里面比较麻烦的事情是，实际平台的不同会影响到命令参数的顺序。将-ldl放到某个位置没有理由与其它位置不同。它只是一个选项，还需要了解这些简直是太气人了。\n如何使它崩溃 link打开lbex29.so，并且使用能够处理二进制的编辑器编辑它。修改一些字节，然后关闭。看看你是否能使用dlopen函数来打开它，即使你修改了它。\n附加题 link 你注意到我在libex29.c中写的不良代码了吗？我使用了一个for循环来检查'\\0'的结尾，修改它们使这些函数总是接收字符串长度，并在函数内部使用。 使用项目框架目录，来为这个练习创建新的项目。将libex29.c放入src/目录，修改Makefile使它能够构建build/libex29.so。 将ex29.c改为tests/ex29_tests.c，使它做为单元测试执行。使它能够正常工作，意思是你需要修改它让它加载build/libex29.so文件，并且运行上面我手写的测试。 阅读man dlopen文档，并且查询所有有关函数。尝试dlopen的其它选项，比如RTLD_NOW。 "
            }
        );
    index.add(
            {
                id:  40 ,
                href: "\/TechDocs\/docs\/c-guide\/ex30\/",
                title: "练习30：自动化测试",
                description: "原文：Exercise 30: Automated Testing 译者：飞龙 自动化测试经常用于例如Python和Ruby的其它语言，但是很少用于C。一部分原因是自动化加载和测试C的代码片段具有较高的难度。这一章中，我们会创建一个非常小型的测试“框架”，并且使用你的框架目录构建测试用例的示例。 我接下来打算使用，并且你会包含进框架目录的框架，叫做“minunit”，它以Jera Design所编写的一小段代码作为开始，之后我扩展了它，就像这样： #undef NDEBUG #ifndef _minunit_h #define _minunit_h #include #include #include #define mu_suite_start() char *message = NULL #define mu_assert(test, message) if (!(test)) { log_err(message); return message; } #define mu_run_test(test) debug(\"\\n-----%s\", \" \" #test); \\ message = test(); tests_run++; if (message) return message; #define RUN_TESTS(name) int main(int argc, char *argv[]) {\\ argc = 1; \\ debug(\"----- RUNNING: %s\", argv[0]);\\ printf(\"----\\nRUNNING: %s\\n\", argv[0]);\\ char *result = name();\\ if (result !",
                content: " 原文：Exercise 30: Automated Testing\n译者：飞龙\n自动化测试经常用于例如Python和Ruby的其它语言，但是很少用于C。一部分原因是自动化加载和测试C的代码片段具有较高的难度。这一章中，我们会创建一个非常小型的测试“框架”，并且使用你的框架目录构建测试用例的示例。\n我接下来打算使用，并且你会包含进框架目录的框架，叫做“minunit”，它以Jera Design所编写的一小段代码作为开始，之后我扩展了它，就像这样：\n#undef NDEBUG #ifndef _minunit_h #define _minunit_h #include #include #include #define mu_suite_start() char *message = NULL #define mu_assert(test, message) if (!(test)) { log_err(message); return message; } #define mu_run_test(test) debug(\"\\n-----%s\", \" \" #test); \\ message = test(); tests_run++; if (message) return message; #define RUN_TESTS(name) int main(int argc, char *argv[]) {\\ argc = 1; \\ debug(\"----- RUNNING: %s\", argv[0]);\\ printf(\"----\\nRUNNING: %s\\n\", argv[0]);\\ char *result = name();\\ if (result != 0) {\\ printf(\"FAILED: %s\\n\", result);\\ }\\ else {\\ printf(\"ALL TESTS PASSED\\n\");\\ }\\ printf(\"Tests run: %d\\n\", tests_run);\\ exit(result != 0);\\ } int tests_run; #endif 原始的内容所剩不多了，现在我使用dbg.h宏，并且在模板测试运行器的末尾创建了大量的宏。在这小段代码中我们创建了整套函数单元测试系统，一旦它结合上shell脚本来运行测试，你可以将其用于你的C代码。\n完成测试框架 link为了基础这个练习，你应该让你的src/libex29.c正常工作，并且完成练习29的附加题，是ex29.c加载程序并合理运行。练习29中我这事了一个附加题来使它像单元测试一样工作，但是现在我打算重新想你展示如何使用minunit.h来做这件事。\n首先我们需要创建一个简单的空单元测试，命名为tests/libex29_tests.c，在里面输入：\n#include \"minunit.h\" char *test_dlopen() { return NULL; } char *test_functions() { return NULL; } char *test_failures() { return NULL; } char *test_dlclose() { return NULL; } char *all_tests() { mu_suite_start(); mu_run_test(test_dlopen); mu_run_test(test_functions); mu_run_test(test_failures); mu_run_test(test_dlclose); return NULL; } RUN_TESTS(all_tests); 这份代码展示了tests/minunit.h中的RUN_TESTS宏，以及如何使用其他的测试运行器宏。我没有编写实际的测试函数，所以你只能看到单元测试的结构。我首先会分解这个文件：\nlibex29_tests.c:1\n包含minunit.h框架。\nlibex29_tests.c:3-7\n第一个测试。测试函数具有固定的结构，它们不带任何参数并且返回char *，成功时为NULL。这非常重要，因为其他宏用于向测试运行器返回错误信息。\nlibex29_tests.c:9-25\n与第一个测试相似的更多测试。\nlibex29_tests.c:27\n控制其他测试的运行器函数。它和其它测试用例格式一致，但是使用额外的东西来配置。\nlibex29_tests.c:28\n为mu_suite_start测试设置一些通用的东西。\nlibex29_tests.c:30\n这就是使用mu_run_test返回结果的地方。\nlibex29_tests.c:35\n在你运行所有测试之后，你应该返回NULL，就像普通的测试函数一样。\nlibex29_tests.c:38\n最后需要使用RUN_TESTS宏来启动main函数，让它运行all_tests启动器。\n这就是用于运行测试所有代码了，现在你需要尝试使它运行在项目框架中。下面是我的执行结果：\nnot printable 我首先执行make clean，之后我运行了构建，它将模板改造为libYOUR_LIBRARY.a和libYOUR_LIBRARY.so文件。要记住你需要在练习29的附加题中完成它。但如果你没有完成的话，下面是我所使用的Makefile的文件差异：\ndiff --git a/code/c-skeleton/Makefile b/code/c-skeleton/Makefile index 135d538..21b92bf 100644 --- a/code/c-skeleton/Makefile +++ b/code/c-skeleton/Makefile @@ -9,9 +9,10 @@ TEST_SRC=$(wildcard tests/*_tests.c) TESTS=$(patsubst %.c,%,$(TEST_SRC)) TARGET=build/libYOUR_LIBRARY.a +SO_TARGET=$(patsubst %.a,%.so,$(TARGET)) # The Target Build -all: $(TARGET) tests +all: $(TARGET) $(SO_TARGET) tests dev: CFLAGS=-g -Wall -Isrc -Wall -Wextra $(OPTFLAGS) dev: all @@ -21,6 +22,9 @@ $(TARGET): build $(OBJECTS) ar rcs $@ $(OBJECTS) ranlib $@ +$(SO_TARGET): $(TARGET) $(OBJECTS) + $(CC) -shared -o $@ $(OBJECTS) + build: @mkdir -p build @mkdir -p bin 完成这些改变后，你现在应该能够构建任何东西，并且你可以最后补完剩余的单元测试函数：\n#include \"minunit.h\" #include typedef int (*lib_function)(const char *data); char *lib_file = \"build/libYOUR_LIBRARY.so\"; void *lib = NULL; int check_function(const char *func_to_run, const char *data, int expected) { lib_function func = dlsym(lib, func_to_run); check(func != NULL, \"Did not find %s function in the library %s: %s\", func_to_run, lib_file, dlerror()); int rc = func(data); check(rc == expected, \"Function %s return %d for data: %s\", func_to_run, rc, data); return 1; error: return 0; } char *test_dlopen() { lib = dlopen(lib_file, RTLD_NOW); mu_assert(lib != NULL, \"Failed to open the library to test.\"); return NULL; } char *test_functions() { mu_assert(check_function(\"print_a_message\", \"Hello\", 0), \"print_a_message failed.\"); mu_assert(check_function(\"uppercase\", \"Hello\", 0), \"uppercase failed.\"); mu_assert(check_function(\"lowercase\", \"Hello\", 0), \"lowercase failed.\"); return NULL; } char *test_failures() { mu_assert(check_function(\"fail_on_purpose\", \"Hello\", 1), \"fail_on_purpose should fail.\"); return NULL; } char *test_dlclose() { int rc = dlclose(lib); mu_assert(rc == 0, \"Failed to close lib.\"); return NULL; } char *all_tests() { mu_suite_start(); mu_run_test(test_dlopen); mu_run_test(test_functions); mu_run_test(test_failures); mu_run_test(test_dlclose); return NULL; } RUN_TESTS(all_tests); 我希望你可以弄清楚它都干了什么，因为这里没有什么新的东西，除了check_function函数。这是一个通用的模式，其中我需要重复执行一段代码，然后通过为之创建宏或函数来使它自动化。这里我打算运行.so中所加载的函数，所以我创建了一个小型函数来完成它。\n附加题 link 这段代码能起作用，但是可能有点乱。清理框架目录，是它包含所有这些文件，但是移除任何和练习29有关的代码。你应该能够复制这个目录并且无需很多编辑操作就能开始新的项目。 研究runtests.sh，并且查询有关bash语法的资料，来弄懂它的作用。你能够编写这个脚本的C版本吗？ "
            }
        );
    index.add(
            {
                id:  41 ,
                href: "\/TechDocs\/docs\/c-guide\/ex31\/",
                title: "练习31：代码调试",
                description: "原文：Exercise 31: Debugging Code 译者：飞龙 我已经教给你一些关于我的强大的调试宏的技巧，并且你已经开始用它们了。当我调试代码时，我使用debug()宏，分析发生了什么以及跟踪问题。在这个练习中我打算教给你一些使用gdb的技巧，用于监视一个不会退出的简单程序。你会学到如何使用gdb附加到运行中的进程，并挂起它来观察发生了什么。在此之后我会给你一些用于gdb的小提示和小技巧。 调试输出、GDB或Valgrind link我主要按照一种“科学方法”的方式来调试，我会提出可能的所有原因，之后排除它们或证明它们导致了缺陷。许多程序员拥有的问题是它们对解决bug的恐慌和急躁使他们觉得这种方法会“拖慢”他们。它们并没有注意到，它们已经失败了，并且在收集无用的信息。我发现日志（调试输出）会强迫我科学地解决bug，并且在更多情况下易于收集信息。 此外，使用调试输出来作为我的首要调试工具的理由如下： 你可以使用变量的调试输出，来看到程序执行的整个轨迹，它让你跟踪变量是如何产生错误的。使用gdb的话，你必须为每个变量放置查看和调试语句，并且难以获得执行的实际轨迹。 调试输出存在于代码中，当你需要它们是你可以重新编译使它们回来。使用gdb的话，你每次调试都需要重新配置相同的信息。 当服务器工作不正常时，它的调试日志功能易于打开，并且在它运行中可以监视日志来查看哪里不对。系统管理员知道如何处理日志，他们不知道如何使用gdb。 打印信息更加容易。调试器通常由于它奇特的UI和前后矛盾显得难用且古怪。debug(\"Yo, dis right? %d\", my_stuff);就没有那么麻烦。 编写调试输出来发现缺陷，强迫你实际分析代码，并且使用科学方法。你可以认为它是，“我假设这里的代码是错误的”，你可以运行它来验证你的假设，如果这里没有错误那么你可以移动到其它地方。这看起来需要更长时间，但是实际上更快，因为你经历了“鉴别诊断”的过程，并排除所有可能的原因，直到你找到它。 调试输入更适于和单元测试一起运行。你可以实际上总是编译调试语句，单元测试时可以随时查看日志。如果你用gdb，你需要在gdb中重复运行单元测试，并跟踪他来查看发生了什么。 使用Valgrind可以得到和调试输出等价的内存相关的错误，所以你并不需要使用类似gdb的东西来寻找缺陷。 尽管所有原因显示我更倾向于debug而不是gdb，我还是在少数情况下回用到gdb，并且我认为你应该选择有助于你完成工作的工具。有时，你只能够连接到一个崩溃的程序并且四处转悠。或者，你得到了一个会崩溃的服务器，你只能够获得一些核心文件来一探究竟。这些货少数其它情况中，gdb是很好的办法。你最好准备尽可能多的工具来解决问题。 接下来我会通过对比gdb、调试输出和Valgrind来详细分析，像这样： Valgrind用于捕获所有内存错误。如果Valgrind中含有错误或Valgrind会严重拖慢程序，我会使用gdb。 调试输出用于诊断或修复有关逻辑或使用上的缺陷。在你使用Valgrind之前，这些共计90%的缺陷。 使用gdb解决剩下的“谜之bug”，或如要收集信息的紧急情况。如果Valgrind不起作用，并且我不能打印出所需信息，我就会使用gdb开始四处搜索。这里我仅仅使用gdb来收集信息。一旦我弄清发生了什么，我会回来编程单元测试来引发缺陷，之后编程打印语句来查找原因。 调试策略 link这一过程适用于你打算使用任何调试技巧，无论是Valgrind、调试输出，或者使用调试器。我打算以使用gdb的形式来描述他，因为似乎人们在使用调试器是会跳过它。但是应当对每个bug使用它，直到你只需要在非常困难的bug上用到。 创建一个小型文本文件叫做notes.txt，并且将它用作记录想法、bug和问题的“实验记录”。 在你使用gdb之前，写下你打算修复的bug，以及可能的产生原因。 对于每个原因，写下你所认为的，问题来源的函数或文件，或者仅仅写下你不知道。 现在启动gdb并且使用file:function挑选最可能的因素，之后在那里设置断点。 使用gdb运行程序，并且确认它是否是真正原因。查明它的最好方式就是看看你是否可以使用set命令，简单修复问题或者重现错误。 如果它不是真正原因，则在notes.txt中标记它不是，以及理由。移到下一个可能的原因，并且使最易于调试的，之后记录你收集到的信息。 这里你并没有注意到，它是最基本的科学方法。你写下一些假设，之后调试来证明或证伪它们。这让你洞察到更多可能的因素，最终使你找到他。这个过程有助于你避免重复步入同一个可能的因素，即使你发现它们并不可能。 你也可以使用调试输出来执行这个过程。唯一的不同就是你实际在源码中编写假设来推测问题所在，而不是notes.txt中。某种程度上，调试输出强制你科学地解决bug，因为你需要将假写为打印语句。 使用 GDB link我将在这个练习中调试下面这个程序，它只有一个不会正常终止的while循环。我在里面放置了一个usleep调用，使它循环起来更加有趣。 #include int main(int argc, char *argv[]) { int i = 0; while(i \u003c 100) { usleep(3000); } return 0; } 像往常一样编译，并且在gdb下启动它，例如：gdb ./ex31。 一旦它运行之后，我打算让你使用这些gdb命令和它交互，并且观察它们的作用以及如何使用它们。 help COMMAND 获得COMMAND的简单帮助。 break file.c:(line|function) 在你希望暂停之星的地方设置断点。你可以提供行号或者函数名称，来在文件中的那个地方暂停。 run ARGS",
                content: " 原文：Exercise 31: Debugging Code\n译者：飞龙\n我已经教给你一些关于我的强大的调试宏的技巧，并且你已经开始用它们了。当我调试代码时，我使用debug()宏，分析发生了什么以及跟踪问题。在这个练习中我打算教给你一些使用gdb的技巧，用于监视一个不会退出的简单程序。你会学到如何使用gdb附加到运行中的进程，并挂起它来观察发生了什么。在此之后我会给你一些用于gdb的小提示和小技巧。\n调试输出、GDB或Valgrind link我主要按照一种“科学方法”的方式来调试，我会提出可能的所有原因，之后排除它们或证明它们导致了缺陷。许多程序员拥有的问题是它们对解决bug的恐慌和急躁使他们觉得这种方法会“拖慢”他们。它们并没有注意到，它们已经失败了，并且在收集无用的信息。我发现日志（调试输出）会强迫我科学地解决bug，并且在更多情况下易于收集信息。\n此外，使用调试输出来作为我的首要调试工具的理由如下：\n你可以使用变量的调试输出，来看到程序执行的整个轨迹，它让你跟踪变量是如何产生错误的。使用gdb的话，你必须为每个变量放置查看和调试语句，并且难以获得执行的实际轨迹。 调试输出存在于代码中，当你需要它们是你可以重新编译使它们回来。使用gdb的话，你每次调试都需要重新配置相同的信息。 当服务器工作不正常时，它的调试日志功能易于打开，并且在它运行中可以监视日志来查看哪里不对。系统管理员知道如何处理日志，他们不知道如何使用gdb。 打印信息更加容易。调试器通常由于它奇特的UI和前后矛盾显得难用且古怪。debug(\"Yo, dis right? %d\", my_stuff);就没有那么麻烦。 编写调试输出来发现缺陷，强迫你实际分析代码，并且使用科学方法。你可以认为它是，“我假设这里的代码是错误的”，你可以运行它来验证你的假设，如果这里没有错误那么你可以移动到其它地方。这看起来需要更长时间，但是实际上更快，因为你经历了“鉴别诊断”的过程，并排除所有可能的原因，直到你找到它。 调试输入更适于和单元测试一起运行。你可以实际上总是编译调试语句，单元测试时可以随时查看日志。如果你用gdb，你需要在gdb中重复运行单元测试，并跟踪他来查看发生了什么。 使用Valgrind可以得到和调试输出等价的内存相关的错误，所以你并不需要使用类似gdb的东西来寻找缺陷。 尽管所有原因显示我更倾向于debug而不是gdb，我还是在少数情况下回用到gdb，并且我认为你应该选择有助于你完成工作的工具。有时，你只能够连接到一个崩溃的程序并且四处转悠。或者，你得到了一个会崩溃的服务器，你只能够获得一些核心文件来一探究竟。这些货少数其它情况中，gdb是很好的办法。你最好准备尽可能多的工具来解决问题。\n接下来我会通过对比gdb、调试输出和Valgrind来详细分析，像这样：\nValgrind用于捕获所有内存错误。如果Valgrind中含有错误或Valgrind会严重拖慢程序，我会使用gdb。 调试输出用于诊断或修复有关逻辑或使用上的缺陷。在你使用Valgrind之前，这些共计90%的缺陷。 使用gdb解决剩下的“谜之bug”，或如要收集信息的紧急情况。如果Valgrind不起作用，并且我不能打印出所需信息，我就会使用gdb开始四处搜索。这里我仅仅使用gdb来收集信息。一旦我弄清发生了什么，我会回来编程单元测试来引发缺陷，之后编程打印语句来查找原因。 调试策略 link这一过程适用于你打算使用任何调试技巧，无论是Valgrind、调试输出，或者使用调试器。我打算以使用gdb的形式来描述他，因为似乎人们在使用调试器是会跳过它。但是应当对每个bug使用它，直到你只需要在非常困难的bug上用到。\n创建一个小型文本文件叫做notes.txt，并且将它用作记录想法、bug和问题的“实验记录”。 在你使用gdb之前，写下你打算修复的bug，以及可能的产生原因。 对于每个原因，写下你所认为的，问题来源的函数或文件，或者仅仅写下你不知道。 现在启动gdb并且使用file:function挑选最可能的因素，之后在那里设置断点。 使用gdb运行程序，并且确认它是否是真正原因。查明它的最好方式就是看看你是否可以使用set命令，简单修复问题或者重现错误。 如果它不是真正原因，则在notes.txt中标记它不是，以及理由。移到下一个可能的原因，并且使最易于调试的，之后记录你收集到的信息。 这里你并没有注意到，它是最基本的科学方法。你写下一些假设，之后调试来证明或证伪它们。这让你洞察到更多可能的因素，最终使你找到他。这个过程有助于你避免重复步入同一个可能的因素，即使你发现它们并不可能。\n你也可以使用调试输出来执行这个过程。唯一的不同就是你实际在源码中编写假设来推测问题所在，而不是notes.txt中。某种程度上，调试输出强制你科学地解决bug，因为你需要将假写为打印语句。\n使用 GDB link我将在这个练习中调试下面这个程序，它只有一个不会正常终止的while循环。我在里面放置了一个usleep调用，使它循环起来更加有趣。\n#include int main(int argc, char *argv[]) { int i = 0; while(i \u003c 100) { usleep(3000); } return 0; } 像往常一样编译，并且在gdb下启动它，例如：gdb ./ex31。\n一旦它运行之后，我打算让你使用这些gdb命令和它交互，并且观察它们的作用以及如何使用它们。\nhelp COMMAND\n获得COMMAND的简单帮助。\nbreak file.c:(line|function)\n在你希望暂停之星的地方设置断点。你可以提供行号或者函数名称，来在文件中的那个地方暂停。\nrun ARGS\n运行程序，使用ARGS作为命令行参数。\ncont\n继续执行程序，直到断点或错误。\nstep\n单步执行代码，但是会进入函数内部。使用它来跟踪函数内部，来观察它做了什么。\nnext\n就像是step，但是他会运行函数并步过它们。\nbacktrace (or bt)\n执行“跟踪回溯”，它会转储函数到当前执行点的执行轨迹。对于查明如何执行到这里非常有用，因为它也打印出传给每个函数的参数。它和Valgrind报告内存错误的方式很接近。\nset var X = Y\n将变量X设置为Y。\nprint X\n打印出X的值，你通常可以使用C的语法来访问指针的值或者结构体的内容。\nENTER\n重复上一条命令。\nquit\n退出gdb。\n这些都是我使用gdb时的主要命令。你现在的任务是玩转它们和ex31，你会对它的输出更加熟悉。\n一旦你熟悉了gdb之后，你会希望多加使用它。尝试在更复杂的程序，例如devpkg上使用它，来观察你是否能够改函数的执行或分析出程序在做什么。\n附加到进程 linkgdb最实用的功能就是附加到运行中的程序，并且就地调试它的能力。当你拥有一个崩溃的服务器或GUI程序，你通常不需要像之前那样在gdb下运行它。而是可以直接启动它，希望它不要马上崩溃，之后附加到它并设置断点。练习的这一部分中我会向你展示怎么做。\n当你退出gdb之后，如果你停止了ex31我希望你重启它，之后开启另一个中断窗口以便于启动gdb并附加。进程附加就是你让gdb连接到已经运行的程序，以便于你实时监测它。它会挂起程序来让你单步执行，当你执行完之后程序会像往常一样恢复运行。\n下面是一段会话，我对ex31做了上述事情，单步执行它，之后修改while循环并使它退出。\n$ ps ax | grep ex31 10026 s000 S+ 0:00.11 ./ex31 10036 s001 R+ 0:00.00 grep ex31 $ gdb ./ex31 10026 GNU gdb 6.3.50-20050815 (Apple version gdb-1705) (Fri Jul 1 10:50:06 UTC 2011) Copyright 2004 Free Software Foundation, Inc. GDB is free software, covered by the GNU General Public License, and you are welcome to change it and/or distribute copies of it under certain conditions. Type \"show copying\" to see the conditions. There is absolutely no warranty for GDB. Type \"show warranty\" for details. This GDB was configured as \"x86_64-apple-darwin\"...Reading symbols for shared libraries .. done /Users/zedshaw/projects/books/learn-c-the-hard-way/code/10026: No such file or directory Attaching to program: `/Users/zedshaw/projects/books/learn-c-the-hard-way/code/ex31', process 10026. Reading symbols for shared libraries + done Reading symbols for shared libraries ++........................ done Reading symbols for shared libraries + done 0x00007fff862c9e42 in __semwait_signal () (gdb) break 8 Breakpoint 1 at 0x107babf14: file ex31.c, line 8. (gdb) break ex31.c:11 Breakpoint 2 at 0x107babf1c: file ex31.c, line 12. (gdb) cont Continuing. Breakpoint 1, main (argc=1, argv=0x7fff677aabd8) at ex31.c:8 8 while(i \u003c 100) { (gdb) p i $1 = 0 (gdb) cont Continuing. Breakpoint 1, main (argc=1, argv=0x7fff677aabd8) at ex31.c:8 8 while(i \u003c 100) { (gdb) p i $2 = 0 (gdb) list 3 4 int main(int argc, char *argv[]) 5 { 6 int i = 0; 7 8 while(i \u003c 100) { 9 usleep(3000); 10 } 11 12 return 0; (gdb) set var i = 200 (gdb) p i $3 = 200 (gdb) next Breakpoint 2, main (argc=1, argv=0x7fff677aabd8) at ex31.c:12 12 return 0; (gdb) cont Continuing. Program exited normally. (gdb) quit $ 注\n在OSX上你可能会看到输入root密码的GUI输入框，并且即使你输入了密码还是会得到来自gdb的“Unable to access task for process-id XXX: (os/kern) failure.”的错误。这种情况下，你需要停止gdb和ex31程序，并重新启动程序使它工作，只要你成功输入了root密码。\n我会遍历整个会话，并且解释我做了什么：\ngdb:1\n使用ps来寻找我想要附加的ex31的进程ID。\ngdb:5\n我使用gdb ./ex31 PID来附加到进程，其中PID替换为我所拥有的进程ID。\ngdb:6-19\ngdb打印出了一堆关于协议的信息，接着它读取了所有东西。\ngdb:21\n程序被附加，并且在当前执行点上停止。所以现在我在文件中的第8行使用break设置了断点。我假设我这么做的时候，已经在这个我想中断的文件中了。\ngdb:24\n执行break的更好方式，是提供file.c line的格式，便于你确保定位到了正确的地方。我在这个break中这样做。\ngdb:27\n我使用cont来继续运行，直到我命中了断点。\ngdb:30-31\n我已到达断点，于是gdb打印出我需要了解的变量（argc和argv），以及停下来的位置，之后打印出断点的行号。\ngdb:33-34\n我使用print的缩写p来打印出i变量的值，它是0。\ngdb:36\n继续运行来查看i是否改变。\ngdb:42\n再次打印出i，显然它没有变化。\ngdb:45-55\n使用list来查看代码是什么，之后我意识到它不可能退出，因为我没有自增i。\ngdb:57\n确认我的假设是正确的，即i需要使用set命令来修改为i = 200。这是gdb最优秀的特性之一，让你“修改”程序来让你快速知道你是否正确。\ngdb:59\n打印i来确保它已改变。\ngdb:62\n使用next来移到下一段代码，并且我发现命中了ex31.c:12的断点，所以这意味着while循环已退出。我的假设正确，我需要修改i。\ngdb:67\n使用cont来继续运行，程序像往常一样退出。\ngdb:71\n最后我使用quit来退出gdb。\nGDB 技巧 link下面是你可以用于GDB的一些小技巧：\ngdb –args\n通常gdb获得你提供的变量并假设它们用于它自己。使用--args来向程序传递它们。\nthread apply all bt\n转储所有线程的执行轨迹，非常有用。\ngdb –batch –ex r –ex bt –ex q –args\n运行程序，当它崩溃时你会得到执行轨迹。\n?\n如果你有其它技巧，在评论中写下它吧。\n附加题 link 找到一个图形化的调试器，将它与原始的gdb相比。它们在本地调试程序时非常有用，但是对于在服务器上调试没有任何意义。 你可以开启OS上的“核心转储”，当程序崩溃时你会得到一个核心文件。这个核心文件就像是对程序的解剖，便于你了解崩溃时发生了什么，以及由什么原因导致。修改ex31.c使它在几个迭代之后崩溃，之后尝试得到它的核心转储并分析。 "
            }
        );
    index.add(
            {
                id:  42 ,
                href: "\/TechDocs\/docs\/c-guide\/ex32\/",
                title: "练习32：双向链表",
                description: "原文：Exercise 32: Double Linked Lists\n译者：飞龙\n这本书的目的是教给你计算机实际上如何工作，这也包括多种数据结构和算法函数。计算机自己其实并没有太大用处。为了让它们做一些有用的事情，你需要构建数据，之后在这些结构上组织处理。其它编程语言带有实现所有这些结构的库，或者带有直接的语法来创建它们。C需要你手动实现所有数据结构，这使它成为最“完美”的语言，让你知道它们的工作原理。\n我的目标是交给你这些数据结构，以及相关算法的知识，来帮助你完成下面这三件事：\n理解Python、Ruby或JavaScript的data = {\"name\": \"Zed\"}到底做了什么。 使用数据结构来解决问题，使你成为更好的C程序员。 学习数据结构和算法的核心部分，让你知道在特定条件下哪个最好。 数据结构是什么。 link“数据结构”这个名称自己就能够解释。它是具有特性模型的数据组织方法。这一模型可能设计用于以新的方法处理数据，也可能只是用于将它们更高效地储存在磁盘上。这本书中我会遵循一些简单的模式来构建可用的数据结构：\n定义一个结构的主要“外部结构”。 定义一个结构的内容，通常是带有链接的节点。 创建函数操作它们的函数。 C中还有其它样式的数据结构，但是这个模式效果很好，并且对于你创建的大部分数据结构都适用。\n构建库 link对于这本书的剩余部分，当你完成这本书之后，你将会创建一个可用的库。这个库会包含下列元素：\n为每个数据结构编写的头文件.h。 为算法编写的实现文件.c。 用于测试它们确保有效的单元测试。 从头文件自动生成的文档。 你已经实现了c-skeleton（项目框架目录），使用它来创建一个liblcthw项目：\n$ cp -r c-skeleton liblcthw $ cd liblcthw/ $ ls LICENSE Makefile README.md bin build src tests $ vim Makefile $ ls src/ dbg.h libex29.c libex29.o $ mkdir src/lcthw $ mv src/dbg.h src/lcthw $ vim tests/minunit.h $ rm src/libex29.* tests/libex29* $ make clean rm -rf build tests/libex29_tests rm -f tests/tests.",
                content: " 原文：Exercise 32: Double Linked Lists\n译者：飞龙\n这本书的目的是教给你计算机实际上如何工作，这也包括多种数据结构和算法函数。计算机自己其实并没有太大用处。为了让它们做一些有用的事情，你需要构建数据，之后在这些结构上组织处理。其它编程语言带有实现所有这些结构的库，或者带有直接的语法来创建它们。C需要你手动实现所有数据结构，这使它成为最“完美”的语言，让你知道它们的工作原理。\n我的目标是交给你这些数据结构，以及相关算法的知识，来帮助你完成下面这三件事：\n理解Python、Ruby或JavaScript的data = {\"name\": \"Zed\"}到底做了什么。 使用数据结构来解决问题，使你成为更好的C程序员。 学习数据结构和算法的核心部分，让你知道在特定条件下哪个最好。 数据结构是什么。 link“数据结构”这个名称自己就能够解释。它是具有特性模型的数据组织方法。这一模型可能设计用于以新的方法处理数据，也可能只是用于将它们更高效地储存在磁盘上。这本书中我会遵循一些简单的模式来构建可用的数据结构：\n定义一个结构的主要“外部结构”。 定义一个结构的内容，通常是带有链接的节点。 创建函数操作它们的函数。 C中还有其它样式的数据结构，但是这个模式效果很好，并且对于你创建的大部分数据结构都适用。\n构建库 link对于这本书的剩余部分，当你完成这本书之后，你将会创建一个可用的库。这个库会包含下列元素：\n为每个数据结构编写的头文件.h。 为算法编写的实现文件.c。 用于测试它们确保有效的单元测试。 从头文件自动生成的文档。 你已经实现了c-skeleton（项目框架目录），使用它来创建一个liblcthw项目：\n$ cp -r c-skeleton liblcthw $ cd liblcthw/ $ ls LICENSE Makefile README.md bin build src tests $ vim Makefile $ ls src/ dbg.h libex29.c libex29.o $ mkdir src/lcthw $ mv src/dbg.h src/lcthw $ vim tests/minunit.h $ rm src/libex29.* tests/libex29* $ make clean rm -rf build tests/libex29_tests rm -f tests/tests.log find . -name \"*.gc*\" -exec rm {} \\; rm -rf `find . -name \"*.dSYM\" -print` $ ls tests/ minunit.h runtests.sh $ 这个会话中我执行了下列事情：\n复制了c-skeleton。 编辑Makefile，将libYOUR_LIBRARY.a改为liblcthw.a作为新的TARGET。 创建src/lcthw目录，我们会在里面放入代码。 移动src/dbg.h文件到新的目录中。 编辑 tests/minunit.h，使它使用所包含的#include 。 移除libex29.*中我们不需要的源文件和测试文件。 清理所有遗留的东西。 执行完之后你就准备好开始构建库了，我打算构建第一个数据结构是双向链表。\n双向链表 link我们将要向liblcthw添加的第一个数据结构是双向链表。这是你能够构建的最简单的数据结构，并且它拥有针对特定操作的实用属性。单向链表通过指向下一个或上一个元素的节点来工作。“双向”链表持有全部这两个指针，而“单向”链表只持有下一个元素的指针。\n由于每个节点都有下一个和上一个元素的指针，并且你可以跟踪联保的第一个和最后的元素，你就可以快速地执行一些操作。任何涉及到插入和删除元素的操作会非常快。它对大多数人来说也易于实现。\n链表的主要缺点是，遍历它涉及到处理沿途每个单个的指针。这意味着搜索、多数排序以及迭代元素会表较慢。这也意味着你不能直接跳过链表的随机一部分。如果换成数组，你就可以直接索引到它的中央，但是链表不行。也就是说如果你想要访问第十个元素，你必须经过1~9。\n定义 link正如在这个练习的介绍部分所说，整个过程的第一步，是编程一个头文件，带有正确的C结构定义。\n#ifndef lcthw_List_h #define lcthw_List_h #include struct ListNode; typedef struct ListNode { struct ListNode *next; struct ListNode *prev; void *value; } ListNode; typedef struct List { int count; ListNode *first; ListNode *last; } List; List *List_create(); void List_destroy(List *list); void List_clear(List *list); void List_clear_destroy(List *list); #define List_count(A) ((A)-\u003ecount) #define List_first(A) ((A)-\u003efirst != NULL ? (A)-\u003efirst-\u003evalue : NULL) #define List_last(A) ((A)-\u003elast != NULL ? (A)-\u003elast-\u003evalue : NULL) void List_push(List *list, void *value); void *List_pop(List *list); void List_unshift(List *list, void *value); void *List_shift(List *list); void *List_remove(List *list, ListNode *node); #define LIST_FOREACH(L, S, M, V) ListNode *_node = NULL;\\ ListNode *V = NULL;\\ for(V = _node = L-\u003eS; _node != NULL; V = _node = _node-\u003eM) #endif 我所做的第一件事就是创建两个结构，ListNode和包含这些节点的List。这创建了是将在函数中使用的数据结构，以及随后定义的宏。如果你浏览这些函数，它们看起来非常简单。当我讲到实现时，我会解释他们，但我更希望你能猜出它们的作用。\n这些数据结构的工作方式，就是每个ListNode都有三个成员。\n值，它是无类型的指针，存储我们想在链表中放置的东西。 ListNode *next指针，它指向另一个储存下一个元素的ListNode 。 ListNode *prev指针，它指向另一个储存上一个元素的ListNode 。 List结构只是这些ListNode结构的容器，它们互联链接组成链型。它跟踪链表的count，first和last元素。\n最后，看一看src/lcthw/list.h:37，其中我定义了LIST_FOREACH宏。这是个常见的习语，你可以创建一个宏来生成迭代代码，使用者就不会弄乱了。正确使用这类执行过程来处理数据结构十分困难，所以可以编写宏来帮助使用者。当我讲到实现时，你可以看到我如何使用它。\n实现 link一旦你理解了它们之后，你很可能理解了双向链表如何工作。它只是带有两个指针的节点，指向链表中前一个和后一个元素。接下来你可以编写src/lcthw/list.c中的代码，来理解每个操作如何实现。\n#include #include List *List_create() { return calloc(1, sizeof(List)); } void List_destroy(List *list) { LIST_FOREACH(list, first, next, cur) { if(cur-\u003eprev) { free(cur-\u003eprev); } } free(list-\u003elast); free(list); } void List_clear(List *list) { LIST_FOREACH(list, first, next, cur) { free(cur-\u003evalue); } } void List_clear_destroy(List *list) { List_clear(list); List_destroy(list); } void List_push(List *list, void *value) { ListNode *node = calloc(1, sizeof(ListNode)); check_mem(node); node-\u003evalue = value; if(list-\u003elast == NULL) { list-\u003efirst = node; list-\u003elast = node; } else { list-\u003elast-\u003enext = node; node-\u003eprev = list-\u003elast; list-\u003elast = node; } list-\u003ecount++; error: return; } void *List_pop(List *list) { ListNode *node = list-\u003elast; return node != NULL ? List_remove(list, node) : NULL; } void List_unshift(List *list, void *value) { ListNode *node = calloc(1, sizeof(ListNode)); check_mem(node); node-\u003evalue = value; if(list-\u003efirst == NULL) { list-\u003efirst = node; list-\u003elast = node; } else { node-\u003enext = list-\u003efirst; list-\u003efirst-\u003eprev = node; list-\u003efirst = node; } list-\u003ecount++; error: return; } void *List_shift(List *list) { ListNode *node = list-\u003efirst; return node != NULL ? List_remove(list, node) : NULL; } void *List_remove(List *list, ListNode *node) { void *result = NULL; check(list-\u003efirst \u0026\u0026 list-\u003elast, \"List is empty.\"); check(node, \"node can't be NULL\"); if(node == list-\u003efirst \u0026\u0026 node == list-\u003elast) { list-\u003efirst = NULL; list-\u003elast = NULL; } else if(node == list-\u003efirst) { list-\u003efirst = node-\u003enext; check(list-\u003efirst != NULL, \"Invalid list, somehow got a first that is NULL.\"); list-\u003efirst-\u003eprev = NULL; } else if (node == list-\u003elast) { list-\u003elast = node-\u003eprev; check(list-\u003elast != NULL, \"Invalid list, somehow got a next that is NULL.\"); list-\u003elast-\u003enext = NULL; } else { ListNode *after = node-\u003enext; ListNode *before = node-\u003eprev; after-\u003eprev = before; before-\u003enext = after; } list-\u003ecount--; result = node-\u003evalue; free(node); error: return result; } 我实现了双向链表上的所有操作，它们不能用简单的宏来完成。比起覆盖文件中的每一行，我打算为list.h和list.c中的每个操作提供一个高阶的概览。你需要自己阅读代码。\nlist.h:List_count\n返回链表中元素数量，它在元素添加或移除时维护。\nlist.h:List_first\n返回链表的首个元素，但是并不移除它。\nlist.h:List_last\n返回链表的最后一个元素，但是不移除它。\nlist.h:LIST_FOREACH\n遍历链表中的元素。\nlist.c:List_create\n简单地创建主要的List结构。\nlist.c:List_destroy\n销毁List以及其中含有的所有元素。\nlist.c:List_clear\n为释放每个节点中的值（而不是节点本身）创建的辅助函数。\nlist.c:List_clear_destroy\n清理并销毁链表。它并不十分搞笑因为它对每个元素遍历两次。\nlist.c:List_push\n第一个操作演示了链表的有点。它向链表尾添加新的元素，由于只是一些指针赋值，所以非常快。\nlist.c:List_pop\nList_push的反向版本，它去除最后一个元素并返回它。\nlist.c:List_unshift\n亦可以轻易对链表执行的另一件事，就是快速地向链表头部添加元素。由于找不到合适的词，这里我把它称为unshift。\nlist.c:List_shift\n类似List_pop，但是它移除链表的首个元素并返回。\nlist.c:List_remove\n当你执行List_pop或List_shift时，它执行实际的移除操作。在数据结构中移除数据总是看似比较困难，这个函数也不例外。它需要处理一些条件，取决于被移除的位置，在开头、在结尾、开头并且结尾，或者在中间。\n这些函数大多数都没什么特别的，你应该能够轻易描述出来，并且根据代码来理解它。你应该完全专注于List_destroy中的LIST_FOREACH如何使用来理解它如何简化通常的操作。\n测试 link在你编译它们之前，需要创建测试来确保它们正确执行。\n#include \"minunit.h\" #include #include static List *list = NULL; char *test1 = \"test1 data\"; char *test2 = \"test2 data\"; char *test3 = \"test3 data\"; char *test_create() { list = List_create(); mu_assert(list != NULL, \"Failed to create list.\"); return NULL; } char *test_destroy() { List_clear_destroy(list); return NULL; } char *test_push_pop() { List_push(list, test1); mu_assert(List_last(list) == test1, \"Wrong last value.\"); List_push(list, test2); mu_assert(List_last(list) == test2, \"Wrong last value\"); List_push(list, test3); mu_assert(List_last(list) == test3, \"Wrong last value.\"); mu_assert(List_count(list) == 3, \"Wrong count on push.\"); char *val = List_pop(list); mu_assert(val == test3, \"Wrong value on pop.\"); val = List_pop(list); mu_assert(val == test2, \"Wrong value on pop.\"); val = List_pop(list); mu_assert(val == test1, \"Wrong value on pop.\"); mu_assert(List_count(list) == 0, \"Wrong count after pop.\"); return NULL; } char *test_unshift() { List_unshift(list, test1); mu_assert(List_first(list) == test1, \"Wrong first value.\"); List_unshift(list, test2); mu_assert(List_first(list) == test2, \"Wrong first value\"); List_unshift(list, test3); mu_assert(List_first(list) == test3, \"Wrong last value.\"); mu_assert(List_count(list) == 3, \"Wrong count on unshift.\"); return NULL; } char *test_remove() { // we only need to test the middle remove case since push/shift // already tests the other cases char *val = List_remove(list, list-\u003efirst-\u003enext); mu_assert(val == test2, \"Wrong removed element.\"); mu_assert(List_count(list) == 2, \"Wrong count after remove.\"); mu_assert(List_first(list) == test3, \"Wrong first after remove.\"); mu_assert(List_last(list) == test1, \"Wrong last after remove.\"); return NULL; } char *test_shift() { mu_assert(List_count(list) != 0, \"Wrong count before shift.\"); char *val = List_shift(list); mu_assert(val == test3, \"Wrong value on shift.\"); val = List_shift(list); mu_assert(val == test1, \"Wrong value on shift.\"); mu_assert(List_count(list) == 0, \"Wrong count after shift.\"); return NULL; } char *all_tests() { mu_suite_start(); mu_run_test(test_create); mu_run_test(test_push_pop); mu_run_test(test_unshift); mu_run_test(test_remove); mu_run_test(test_shift); mu_run_test(test_destroy); return NULL; } RUN_TESTS(all_tests); 它简单地遍历了每个操作，并且确保它们有效。我在测试中做了简化，对于整个程序我只创建了一个List *list，这解决了为每个测试构建一个List的麻烦，但它同时意味着一些测试会受到之前测试的影响。这里我试着是每个测试不改变链表，或实际使用上一个测试的结果。\n你会看到什么 link如果你正确完成了每件事，当你执行构建并且运行单元测试是，你会看到：\n$ make cc -g -O2 -Wall -Wextra -Isrc -rdynamic -DNDEBUG -fPIC -c -o src/lcthw/list.o src/lcthw/list.c ar rcs build/liblcthw.a src/lcthw/list.o ranlib build/liblcthw.a cc -shared -o build/liblcthw.so src/lcthw/list.o cc -g -O2 -Wall -Wextra -Isrc -rdynamic -DNDEBUG build/liblcthw.a tests/list_tests.c -o tests/list_tests sh ./tests/runtests.sh Running unit tests: ---- RUNNING: ./tests/list_tests ALL TESTS PASSED Tests run: 6 tests/list_tests PASS $ 确保6个测试运行完毕，以及构建时没有警告或错误，并且成功构建了build/liblcthw.a和build/liblcthw.so文件。\n如何改进 link我打算告诉你如何改进代码，而不是使它崩溃。\n你可以使用LIST_FOREACH并在循环中调用free来使List_clear_destroy更高效。 你可以为一些先决条件添加断言，使其部结构NULL值作为List *list的参数。 你可以添加不变了，来检查列表的内容始终正确，例如count永远不会\u003c 0，如果count \u003e 0，first不为NULL。 你可以向头文件添加文档，在每个结构、函数和宏之前添加描述其作用的注释。 这些改进执行了防御性编程实践，并且“加固”了代码来避免错误或使用不当。马上去做这些事情，之后找到尽可能多的办法来改进代码。\n附加题 link 研究双向和单向链表，以及什么情况下其中一种优于另一种。 研究双向链表的限制。例如，虽然它们对于插入和删除元素很高效，但是对于变量元素比较慢。 还缺少什么你能想到的操作？比如复制、连接、分割等等。实现这些操作，并且为它们编写单元测试。 "
            }
        );
    index.add(
            {
                id:  43 ,
                href: "\/TechDocs\/docs\/c-guide\/ex33\/",
                title: "练习33：链表算法",
                description: "原文：Exercise 33: Linked List Algorithms 译者：飞龙 我将想你介绍涉及到排序的两个算法，你可以用它们操作链表。我首先要警告你，如果你打算对数据排序，不要使用链表，它们对于排序十分麻烦，并且有更好的数据结构作为替代。我向你介绍这两种算法只是因为它们难以在链表上完成，并且让你思考如何高效操作它们。 为了编写这本书，我打算将算法放在两个不同的文件中，list_algos.h和list_algos.c，之后在list_algos_test.c中编写测试。现在你要按照我的结构，因为它足以把事情做好，但是如果你使用其它的库要记住这并不是通用的结构。 这个练习中我打算给你一些额外的挑战，并且希望你不要作弊。我打算先给你单元测试，并且让你打下来。之后让你基于它们在维基百科中的描述，尝试实现这个两个算法，之后看看你的代码是否和我的类似。 冒泡排序和归并排序 link互联网的强大之处，就是我可以仅仅给你冒泡排序和归并排序的链接，来让你学习它们。是的，这省了我很多字。现在我要告诉你如何使用它们的伪代码来实现它们。你可以像这样来实现算法： 阅读描述，并且观察任何可视化的图表。 使用方框和线条在纸上画出算法，或者使用一些带有数字的卡片（比如扑克牌），尝试手动执行算法。这会向你形象地展示算法的执行过程。 在list_algos.c文案总创建函数的主干，并且创建list_algos.h文件，之后创建测试代码。 编写第一个测试并且编译所有东西。 回到维基百科页面，复制粘贴伪代码到你创建的函数中（不是C代码）。 将伪代码翻译成良好的C代码，就像我教你的那样，使用你的单元测试来保证它有效。 为边界情况补充一些测试，例如空链表，排序号的链表，以及其它。 对下一个算法重复这些过程并测试。 我只是告诉你理解大多数算法的秘密，直到你碰到一些更加麻烦的算法。这里你只是按照维基百科来实现冒泡排序和归并排序，它们是一个好的起始。 单元测试 link下面是你应该通过的单元测试： #include \"minunit.h\" #include #include #include char *values[] = {\"XXXX\", \"1234\", \"abcd\", \"xjvef\", \"NDSS\"}; #define NUM_VALUES 5 List *create_words() { int i = 0; List *words = List_create(); for(i = 0; i \u003c NUM_VALUES; i++) { List_push(words, values[i]); } return words; } int is_sorted(List *words) { LIST_FOREACH(words, first, next, cur) { if(cur-\u003enext \u0026\u0026 strcmp(cur-\u003evalue, cur-\u003enext-\u003evalue) \u003e 0) { debug(\"%s %s\", (char *)cur-\u003evalue, (char *)cur-\u003enext-\u003evalue); return 0; } } return 1; } char *test_bubble_sort() { List *words = create_words(); // should work on a list that needs sorting int rc = List_bubble_sort(words, (List_compare)strcmp); mu_assert(rc == 0, \"Bubble sort failed.",
                content: " 原文：Exercise 33: Linked List Algorithms\n译者：飞龙\n我将想你介绍涉及到排序的两个算法，你可以用它们操作链表。我首先要警告你，如果你打算对数据排序，不要使用链表，它们对于排序十分麻烦，并且有更好的数据结构作为替代。我向你介绍这两种算法只是因为它们难以在链表上完成，并且让你思考如何高效操作它们。\n为了编写这本书，我打算将算法放在两个不同的文件中，list_algos.h和list_algos.c，之后在list_algos_test.c中编写测试。现在你要按照我的结构，因为它足以把事情做好，但是如果你使用其它的库要记住这并不是通用的结构。\n这个练习中我打算给你一些额外的挑战，并且希望你不要作弊。我打算先给你单元测试，并且让你打下来。之后让你基于它们在维基百科中的描述，尝试实现这个两个算法，之后看看你的代码是否和我的类似。\n冒泡排序和归并排序 link互联网的强大之处，就是我可以仅仅给你冒泡排序和归并排序的链接，来让你学习它们。是的，这省了我很多字。现在我要告诉你如何使用它们的伪代码来实现它们。你可以像这样来实现算法：\n阅读描述，并且观察任何可视化的图表。 使用方框和线条在纸上画出算法，或者使用一些带有数字的卡片（比如扑克牌），尝试手动执行算法。这会向你形象地展示算法的执行过程。 在list_algos.c文案总创建函数的主干，并且创建list_algos.h文件，之后创建测试代码。 编写第一个测试并且编译所有东西。 回到维基百科页面，复制粘贴伪代码到你创建的函数中（不是C代码）。 将伪代码翻译成良好的C代码，就像我教你的那样，使用你的单元测试来保证它有效。 为边界情况补充一些测试，例如空链表，排序号的链表，以及其它。 对下一个算法重复这些过程并测试。 我只是告诉你理解大多数算法的秘密，直到你碰到一些更加麻烦的算法。这里你只是按照维基百科来实现冒泡排序和归并排序，它们是一个好的起始。\n单元测试 link下面是你应该通过的单元测试：\n#include \"minunit.h\" #include #include #include char *values[] = {\"XXXX\", \"1234\", \"abcd\", \"xjvef\", \"NDSS\"}; #define NUM_VALUES 5 List *create_words() { int i = 0; List *words = List_create(); for(i = 0; i \u003c NUM_VALUES; i++) { List_push(words, values[i]); } return words; } int is_sorted(List *words) { LIST_FOREACH(words, first, next, cur) { if(cur-\u003enext \u0026\u0026 strcmp(cur-\u003evalue, cur-\u003enext-\u003evalue) \u003e 0) { debug(\"%s %s\", (char *)cur-\u003evalue, (char *)cur-\u003enext-\u003evalue); return 0; } } return 1; } char *test_bubble_sort() { List *words = create_words(); // should work on a list that needs sorting int rc = List_bubble_sort(words, (List_compare)strcmp); mu_assert(rc == 0, \"Bubble sort failed.\"); mu_assert(is_sorted(words), \"Words are not sorted after bubble sort.\"); // should work on an already sorted list rc = List_bubble_sort(words, (List_compare)strcmp); mu_assert(rc == 0, \"Bubble sort of already sorted failed.\"); mu_assert(is_sorted(words), \"Words should be sort if already bubble sorted.\"); List_destroy(words); // should work on an empty list words = List_create(words); rc = List_bubble_sort(words, (List_compare)strcmp); mu_assert(rc == 0, \"Bubble sort failed on empty list.\"); mu_assert(is_sorted(words), \"Words should be sorted if empty.\"); List_destroy(words); return NULL; } char *test_merge_sort() { List *words = create_words(); // should work on a list that needs sorting List *res = List_merge_sort(words, (List_compare)strcmp); mu_assert(is_sorted(res), \"Words are not sorted after merge sort.\"); List *res2 = List_merge_sort(res, (List_compare)strcmp); mu_assert(is_sorted(res), \"Should still be sorted after merge sort.\"); List_destroy(res2); List_destroy(res); List_destroy(words); return NULL; } char *all_tests() { mu_suite_start(); mu_run_test(test_bubble_sort); mu_run_test(test_merge_sort); return NULL; } RUN_TESTS(all_tests); 建议你从冒泡排序开始，使它正确，之后再测试归并。我所做的就是编写函数原型和主干，让这三个文件能够编译，但不能通过测试。之后你将实现填充进入之后才能够工作。\n实现 link你作弊了吗？之后的练习中，我只会给你单元测试，并且让自己实现它。对于你来说，不看这段代码知道你自己实现它是一种很好的练习。下面是list_algos.c和list_algos.h的代码：\n#ifndef lcthw_List_algos_h #define lcthw_List_algos_h #include typedef int (*List_compare)(const void *a, const void *b); int List_bubble_sort(List *list, List_compare cmp); List *List_merge_sort(List *list, List_compare cmp); #endif #include #include inline void ListNode_swap(ListNode *a, ListNode *b) { void *temp = a-\u003evalue; a-\u003evalue = b-\u003evalue; b-\u003evalue = temp; } int List_bubble_sort(List *list, List_compare cmp) { int sorted = 1; if(List_count(list) \u003c= 1) { return 0; // already sorted } do { sorted = 1; LIST_FOREACH(list, first, next, cur) { if(cur-\u003enext) { if(cmp(cur-\u003evalue, cur-\u003enext-\u003evalue) \u003e 0) { ListNode_swap(cur, cur-\u003enext); sorted = 0; } } } } while(!sorted); return 0; } inline List *List_merge(List *left, List *right, List_compare cmp) { List *result = List_create(); void *val = NULL; while(List_count(left) \u003e 0 || List_count(right) \u003e 0) { if(List_count(left) \u003e 0 \u0026\u0026 List_count(right) \u003e 0) { if(cmp(List_first(left), List_first(right)) \u003c= 0) { val = List_shift(left); } else { val = List_shift(right); } List_push(result, val); } else if(List_count(left) \u003e 0) { val = List_shift(left); List_push(result, val); } else if(List_count(right) \u003e 0) { val = List_shift(right); List_push(result, val); } } return result; } List *List_merge_sort(List *list, List_compare cmp) { if(List_count(list) \u003c= 1) { return list; } List *left = List_create(); List *right = List_create(); int middle = List_count(list) / 2; LIST_FOREACH(list, first, next, cur) { if(middle \u003e 0) { List_push(left, cur-\u003evalue); } else { List_push(right, cur-\u003evalue); } middle--; } List *sort_left = List_merge_sort(left, cmp); List *sort_right = List_merge_sort(right, cmp); if(sort_left != left) List_destroy(left); if(sort_right != right) List_destroy(right); return List_merge(sort_left, sort_right, cmp); } 冒泡排序并不难以理解，虽然它非常慢。归并排序更为复杂，实话讲如果我想要牺牲可读性的话，我会花一点时间来优化代码。\n归并排序有另一种“自底向上”的实现方式，但是它太难了，我就没有选择它。就像我刚才说的那样，在链表上编写排序算法没有什么意思。你可以把时间都花在使它更快，它比起其他可排序的数据结构会相当版。链表的本质决定了如果你需要对数据进行排序，你就不要使用它们（尤其是单向的）。\n你会看到什么 link如果一切都正常工作，你会看到这些：\n$ make clean all rm -rf build src/lcthw/list.o src/lcthw/list_algos.o tests/list_algos_tests tests/list_tests rm -f tests/tests.log find . -name \"*.gc*\" -exec rm {} \\; rm -rf `find . -name \"*.dSYM\" -print` cc -g -O2 -Wall -Wextra -Isrc -rdynamic -DNDEBUG -fPIC -c -o src/lcthw/list.o src/lcthw/list.c cc -g -O2 -Wall -Wextra -Isrc -rdynamic -DNDEBUG -fPIC -c -o src/lcthw/list_algos.o src/lcthw/list_algos.c ar rcs build/liblcthw.a src/lcthw/list.o src/lcthw/list_algos.o ranlib build/liblcthw.a cc -shared -o build/liblcthw.so src/lcthw/list.o src/lcthw/list_algos.o cc -g -O2 -Wall -Wextra -Isrc -rdynamic -DNDEBUG build/liblcthw.a tests/list_algos_tests.c -o tests/list_algos_tests cc -g -O2 -Wall -Wextra -Isrc -rdynamic -DNDEBUG build/liblcthw.a tests/list_tests.c -o tests/list_tests sh ./tests/runtests.sh Running unit tests: ---- RUNNING: ./tests/list_algos_tests ALL TESTS PASSED Tests run: 2 tests/list_algos_tests PASS ---- RUNNING: ./tests/list_tests ALL TESTS PASSED Tests run: 6 tests/list_tests PASS $ 这个练习之后我就不会向你展示这样的输出了，除非有必要向你展示它的工作原理。你应该能知道我运行了测试，并且通过了所有测试。\n如何改进 link退回去查看算法描述，有一些方法可用于改进这些实现，其中一些是很显然的：\n归并排序做了大量的链表复制和创建操作，寻找减少它们的办法。 归并排序的维基百科描述提到了一些优化，实现它们。 你能使用List_split和List_join（如果你实现了的话）来改进归并排序嘛？ 浏览所有防御性编程原则，检查并提升这一实现的健壮性，避免NULL指针，并且创建一个可选的调试级别的不变量，在排序后实现is_sorted的功能。 附加题 link 创建单元测试来比较这两个算法的性能。你需要man 3 time来查询基本的时间函数，并且需要运行足够的迭代次数，至少以几秒钟作为样本。 改变需要排序的链表中的数据总量，看看耗时如何变化。 寻找方法来创建不同长度的随机链表，并且测量需要多少时间，之后将它可视化并与算法的描述对比。 尝试解释为什么对链表排序十分麻烦。 实现List_insert_sorted（有序链表），它使用List_compare，接收一个值，将其插入到正确的位置，使链表有序。它与创建链表后再进行排序相比怎么样？ 尝试实现维基百科上“自底向上”的归并排序。上面的代码已经是C写的了，所以很容易重新创建，但是要试着理解它的工作原理，并与这里的低效版本对比。 "
            }
        );
    index.add(
            {
                id:  44 ,
                href: "\/TechDocs\/docs\/c-guide\/ex34\/",
                title: "练习34：动态数组",
                description: "原文：Exercise 34: Dynamic Array 译者：飞龙 动态数组是自增长的数组，它与链表有很多相同的特性。它通常占据更少的空间，跑得更快，还有一些其它的优势属性。这个练习会涉及到它的一些缺点，比如从开头移除元素会很慢，并给出解决方案（只从末尾移除）。 动态数组简单地实现为void **指针的数组，它是预分配内存的，并且指向数据。在链表中你创建了完整的结构体来储存void *value指针，但是动态数组中你只需要一个储存它们的单个数组。也就是说，你并不需要创建任何其它的指针储存上一个或下一个元素。它们可以直接索引。 我会给你头文件作为起始，你需要为实现打下它们： #ifndef _DArray_h #define _DArray_h #include #include #include typedef struct DArray { int end; int max; size_t element_size; size_t expand_rate; void **contents; } DArray; DArray *DArray_create(size_t element_size, size_t initial_max); void DArray_destroy(DArray *array); void DArray_clear(DArray *array); int DArray_expand(DArray *array); int DArray_contract(DArray *array); int DArray_push(DArray *array, void *el); void *DArray_pop(DArray *array); void DArray_clear_destroy(DArray *array); #define DArray_last(A) ((A)-\u003econtents[(A)-\u003eend - 1]) #define DArray_first(A) ((A)-\u003econtents[0]) #define DArray_end(A) ((A)-\u003eend) #define DArray_count(A) DArray_end(A) #define DArray_max(A) ((A)-\u003emax) #define DEFAULT_EXPAND_RATE 300 static inline void DArray_set(DArray *array, int i, void *el) { check(i \u003c array-\u003emax, \"darray attempt to set past max\"); if(i \u003e array-\u003eend) array-\u003eend = i; array-\u003econtents[i] = el; error: return; } static inline void *DArray_get(DArray *array, int i) { check(i \u003c array-\u003emax, \"darray attempt to get past max\"); return array-\u003econtents[i]; error: return NULL; } static inline void *DArray_remove(DArray *array, int i) { void *el = array-\u003econtents[i]; array-\u003econtents[i] = NULL; return el; } static inline void *DArray_new(DArray *array) { check(array-\u003eelement_size \u003e 0, \"Can't use DArray_new on 0 size darrays.",
                content: " 原文：Exercise 34: Dynamic Array\n译者：飞龙\n动态数组是自增长的数组，它与链表有很多相同的特性。它通常占据更少的空间，跑得更快，还有一些其它的优势属性。这个练习会涉及到它的一些缺点，比如从开头移除元素会很慢，并给出解决方案（只从末尾移除）。\n动态数组简单地实现为void **指针的数组，它是预分配内存的，并且指向数据。在链表中你创建了完整的结构体来储存void *value指针，但是动态数组中你只需要一个储存它们的单个数组。也就是说，你并不需要创建任何其它的指针储存上一个或下一个元素。它们可以直接索引。\n我会给你头文件作为起始，你需要为实现打下它们：\n#ifndef _DArray_h #define _DArray_h #include #include #include typedef struct DArray { int end; int max; size_t element_size; size_t expand_rate; void **contents; } DArray; DArray *DArray_create(size_t element_size, size_t initial_max); void DArray_destroy(DArray *array); void DArray_clear(DArray *array); int DArray_expand(DArray *array); int DArray_contract(DArray *array); int DArray_push(DArray *array, void *el); void *DArray_pop(DArray *array); void DArray_clear_destroy(DArray *array); #define DArray_last(A) ((A)-\u003econtents[(A)-\u003eend - 1]) #define DArray_first(A) ((A)-\u003econtents[0]) #define DArray_end(A) ((A)-\u003eend) #define DArray_count(A) DArray_end(A) #define DArray_max(A) ((A)-\u003emax) #define DEFAULT_EXPAND_RATE 300 static inline void DArray_set(DArray *array, int i, void *el) { check(i \u003c array-\u003emax, \"darray attempt to set past max\"); if(i \u003e array-\u003eend) array-\u003eend = i; array-\u003econtents[i] = el; error: return; } static inline void *DArray_get(DArray *array, int i) { check(i \u003c array-\u003emax, \"darray attempt to get past max\"); return array-\u003econtents[i]; error: return NULL; } static inline void *DArray_remove(DArray *array, int i) { void *el = array-\u003econtents[i]; array-\u003econtents[i] = NULL; return el; } static inline void *DArray_new(DArray *array) { check(array-\u003eelement_size \u003e 0, \"Can't use DArray_new on 0 size darrays.\"); return calloc(1, array-\u003eelement_size); error: return NULL; } #define DArray_free(E) free((E)) #endif 这个头文件向你展示了static inline的新技巧，它就类似#define宏的工作方式，但是它们更清楚，并且易于编写。如果你需要创建一块代码作为宏，并且不需要代码生成，可以使用static inline函数。\n为链表生成for循环的LIST_FOREACH不可能写为static inline函数，因为它需要生成循环的内部代码块。实现它的唯一方式是灰调函数，但是这不够块，并且难以使用。\n之后我会修改代码，并且让你创建DArray的单元测试。\n#include \"minunit.h\" #include static DArray *array = NULL; static int *val1 = NULL; static int *val2 = NULL; char *test_create() { array = DArray_create(sizeof(int), 100); mu_assert(array != NULL, \"DArray_create failed.\"); mu_assert(array-\u003econtents != NULL, \"contents are wrong in darray\"); mu_assert(array-\u003eend == 0, \"end isn't at the right spot\"); mu_assert(array-\u003eelement_size == sizeof(int), \"element size is wrong.\"); mu_assert(array-\u003emax == 100, \"wrong max length on initial size\"); return NULL; } char *test_destroy() { DArray_destroy(array); return NULL; } char *test_new() { val1 = DArray_new(array); mu_assert(val1 != NULL, \"failed to make a new element\"); val2 = DArray_new(array); mu_assert(val2 != NULL, \"failed to make a new element\"); return NULL; } char *test_set() { DArray_set(array, 0, val1); DArray_set(array, 1, val2); return NULL; } char *test_get() { mu_assert(DArray_get(array, 0) == val1, \"Wrong first value.\"); mu_assert(DArray_get(array, 1) == val2, \"Wrong second value.\"); return NULL; } char *test_remove() { int *val_check = DArray_remove(array, 0); mu_assert(val_check != NULL, \"Should not get NULL.\"); mu_assert(*val_check == *val1, \"Should get the first value.\"); mu_assert(DArray_get(array, 0) == NULL, \"Should be gone.\"); DArray_free(val_check); val_check = DArray_remove(array, 1); mu_assert(val_check != NULL, \"Should not get NULL.\"); mu_assert(*val_check == *val2, \"Should get the first value.\"); mu_assert(DArray_get(array, 1) == NULL, \"Should be gone.\"); DArray_free(val_check); return NULL; } char *test_expand_contract() { int old_max = array-\u003emax; DArray_expand(array); mu_assert((unsigned int)array-\u003emax == old_max + array-\u003eexpand_rate, \"Wrong size after expand.\"); DArray_contract(array); mu_assert((unsigned int)array-\u003emax == array-\u003eexpand_rate + 1, \"Should stay at the expand_rate at least.\"); DArray_contract(array); mu_assert((unsigned int)array-\u003emax == array-\u003eexpand_rate + 1, \"Should stay at the expand_rate at least.\"); return NULL; } char *test_push_pop() { int i = 0; for(i = 0; i \u003c 1000; i++) { int *val = DArray_new(array); *val = i * 333; DArray_push(array, val); } mu_assert(array-\u003emax == 1201, \"Wrong max size.\"); for(i = 999; i \u003e= 0; i--) { int *val = DArray_pop(array); mu_assert(val != NULL, \"Shouldn't get a NULL.\"); mu_assert(*val == i * 333, \"Wrong value.\"); DArray_free(val); } return NULL; } char * all_tests() { mu_suite_start(); mu_run_test(test_create); mu_run_test(test_new); mu_run_test(test_set); mu_run_test(test_get); mu_run_test(test_remove); mu_run_test(test_expand_contract); mu_run_test(test_push_pop); mu_run_test(test_destroy); return NULL; } RUN_TESTS(all_tests); 这向你展示了所有操作都如何使用，它会使DArray的实现变得容易：\n#include #include DArray *DArray_create(size_t element_size, size_t initial_max) { DArray *array = malloc(sizeof(DArray)); check_mem(array); array-\u003emax = initial_max; check(array-\u003emax \u003e 0, \"You must set an initial_max \u003e 0.\"); array-\u003econtents = calloc(initial_max, sizeof(void *)); check_mem(array-\u003econtents); array-\u003eend = 0; array-\u003eelement_size = element_size; array-\u003eexpand_rate = DEFAULT_EXPAND_RATE; return array; error: if(array) free(array); return NULL; } void DArray_clear(DArray *array) { int i = 0; if(array-\u003eelement_size \u003e 0) { for(i = 0; i \u003c array-\u003emax; i++) { if(array-\u003econtents[i] != NULL) { free(array-\u003econtents[i]); } } } } static inline int DArray_resize(DArray *array, size_t newsize) { array-\u003emax = newsize; check(array-\u003emax \u003e 0, \"The newsize must be \u003e 0.\"); void *contents = realloc(array-\u003econtents, array-\u003emax * sizeof(void *)); // check contents and assume realloc doesn't harm the original on error check_mem(contents); array-\u003econtents = contents; return 0; error: return -1; } int DArray_expand(DArray *array) { size_t old_max = array-\u003emax; check(DArray_resize(array, array-\u003emax + array-\u003eexpand_rate) == 0, \"Failed to expand array to new size: %d\", array-\u003emax + (int)array-\u003eexpand_rate); memset(array-\u003econtents + old_max, 0, array-\u003eexpand_rate + 1); return 0; error: return -1; } int DArray_contract(DArray *array) { int new_size = array-\u003eend \u003c (int)array-\u003eexpand_rate ? (int)array-\u003eexpand_rate : array-\u003eend; return DArray_resize(array, new_size + 1); } void DArray_destroy(DArray *array) { if(array) { if(array-\u003econtents) free(array-\u003econtents); free(array); } } void DArray_clear_destroy(DArray *array) { DArray_clear(array); DArray_destroy(array); } int DArray_push(DArray *array, void *el) { array-\u003econtents[array-\u003eend] = el; array-\u003eend++; if(DArray_end(array) \u003e= DArray_max(array)) { return DArray_expand(array); } else { return 0; } } void *DArray_pop(DArray *array) { check(array-\u003eend - 1 \u003e= 0, \"Attempt to pop from empty array.\"); void *el = DArray_remove(array, array-\u003eend - 1); array-\u003eend--; if(DArray_end(array) \u003e (int)array-\u003eexpand_rate \u0026\u0026 DArray_end(array) % array-\u003eexpand_rate) { DArray_contract(array); } return el; error: return NULL; } 这占你展示了另一种处理复杂代码的方法，观察头文件并阅读单元测试，而不是一头扎进.c实现中。这种“具体的抽象”让你理解代码如何一起工作，并且更容易记住。\n优点和缺点 linkDArray在你需要这些操作时占优势。\n迭代。你可以仅仅使用基本的for循环，使用DArray_count和DArray_get来完成任务。不需要任何特殊的宏。并且由于不处理指针，它非常快。 索引。你可以使用DArray_get和DArray_set来随机访问任何元素，但是List上你就必须经过第N个元素来访问第N+1个元素。 销毁。你只需要以两个操作销毁结构体和content。但是List需要一些列的free调用同时遍历每个元素。 克隆。你只需要复制结构体和content，用两步复制整个结构。List需要遍历所有元素并且复制每个ListNode和值。 排序。你已经见过了，如果你需要对数据排序，List非常麻烦。DArray上可以实现所有高效的排序算法，因为你可以随机访问任何元素。 大量数据。如果你需要储存大量数据，DArray由于基于content，比起相同数量的ListNode占用更少空间而占优。 然而List在这些操作上占优势。\n在开头插入和移除元素。DArray需要特殊的优化来高效地完成它，并且通常还需要一些复制操作。 分割和连接。List只需要复制一些指针就能完成，但是DArray需要复制涉及到的所有数组。 少量数据。如果你只需要存储几个元素，通常使用List所需的空间要少于DArray，因为DArray需要考虑到日后的添加而扩展背后的空间，但是List只需要元素所需的空间。 考虑到这些，我更倾向使用DArray来完成其它人使用List所做的大部分事情。对于任何需要少量节点并且在两端插入删除的，我会使用List。我会想你展示两个相似的数据结构，叫做Stack和Queue，它们也很重要。\n如何改进 link像往常一样，浏览每个函数和操作，并且执行防御性编程检查，以及添加先决条件、不变量等任何可以使实现更健壮的东西。\n附加题 link 改进单元测试来覆盖耕作操作，并使用for循环来测试迭代。 研究DArray上如何实现冒泡排序和归并排序，但是不要马上实现它们。我会在下一张实现DArray的算法，之后你可以完成它。 为一些常用的操作编写一些性能测试，并与List中的相同操作比较。你已经做过很多次了，但是这次需要编写重复执行所涉及操作的单元测试，之后在主运行器中计时。 观察DArray_expand如何使用固定增长（size + 300）来实现。通常动态数组都以倍数增长（size * 2）的方式实现，但是我发现它会花费无用的内存并且没有真正取得性能收益。测试我的断言，并且看看什么情况下需要倍数增长而不是固定增长。 "
            }
        );
    index.add(
            {
                id:  45 ,
                href: "\/TechDocs\/docs\/c-guide\/ex35\/",
                title: "练习35：排序和搜索",
                description: "原文：Exercise 35: Sorting And Searching 译者：飞龙 这个练习中我打算涉及到四个排序算法和一个搜索算法。排序算法是快速排序、堆排序、归并排序和基数排序。之后在你完成基数排序之后，我打算想你展示二分搜索。 然而，我是一个懒人，大多数C标准库都实现了堆排序、快速排序和归并排序算法，你可以直接使用它们： #include #include int DArray_qsort(DArray *array, DArray_compare cmp) { qsort(array-\u003econtents, DArray_count(array), sizeof(void *), cmp); return 0; } int DArray_heapsort(DArray *array, DArray_compare cmp) { return heapsort(array-\u003econtents, DArray_count(array), sizeof(void *), cmp); } int DArray_mergesort(DArray *array, DArray_compare cmp) { return mergesort(array-\u003econtents, DArray_count(array), sizeof(void *), cmp); } 这就是darray_algos.c文件的整个实现，它在大多数现代Unix系统上都能运行。它们的每一个都使用DArray_compare对contents中储存的无类型指针进行排序。我也要向你展示这个头文件： #ifndef darray_algos_h #define darray_algos_h #include typedef int (*DArray_compare)(const void *a, const void *b); int DArray_qsort(DArray *array, DArray_compare cmp); int DArray_heapsort(DArray *array, DArray_compare cmp); int DArray_mergesort(DArray *array, DArray_compare cmp); #endif 大小几乎一样，你也应该能预料到。接下来你可以了解单元测试中这三个函数如何使用：",
                content: " 原文：Exercise 35: Sorting And Searching\n译者：飞龙\n这个练习中我打算涉及到四个排序算法和一个搜索算法。排序算法是快速排序、堆排序、归并排序和基数排序。之后在你完成基数排序之后，我打算想你展示二分搜索。\n然而，我是一个懒人，大多数C标准库都实现了堆排序、快速排序和归并排序算法，你可以直接使用它们：\n#include #include int DArray_qsort(DArray *array, DArray_compare cmp) { qsort(array-\u003econtents, DArray_count(array), sizeof(void *), cmp); return 0; } int DArray_heapsort(DArray *array, DArray_compare cmp) { return heapsort(array-\u003econtents, DArray_count(array), sizeof(void *), cmp); } int DArray_mergesort(DArray *array, DArray_compare cmp) { return mergesort(array-\u003econtents, DArray_count(array), sizeof(void *), cmp); } 这就是darray_algos.c文件的整个实现，它在大多数现代Unix系统上都能运行。它们的每一个都使用DArray_compare对contents中储存的无类型指针进行排序。我也要向你展示这个头文件：\n#ifndef darray_algos_h #define darray_algos_h #include typedef int (*DArray_compare)(const void *a, const void *b); int DArray_qsort(DArray *array, DArray_compare cmp); int DArray_heapsort(DArray *array, DArray_compare cmp); int DArray_mergesort(DArray *array, DArray_compare cmp); #endif 大小几乎一样，你也应该能预料到。接下来你可以了解单元测试中这三个函数如何使用：\n#include \"minunit.h\" #include int testcmp(char **a, char **b) { return strcmp(*a, *b); } DArray *create_words() { DArray *result = DArray_create(0, 5); char *words[] = {\"asdfasfd\", \"werwar\", \"13234\", \"asdfasfd\", \"oioj\"}; int i = 0; for(i = 0; i \u003c 5; i++) { DArray_push(result, words[i]); } return result; } int is_sorted(DArray *array) { int i = 0; for(i = 0; i \u003c DArray_count(array) - 1; i++) { if(strcmp(DArray_get(array, i), DArray_get(array, i+1)) \u003e 0) { return 0; } } return 1; } char *run_sort_test(int (*func)(DArray *, DArray_compare), const char *name) { DArray *words = create_words(); mu_assert(!is_sorted(words), \"Words should start not sorted.\"); debug(\"--- Testing %s sorting algorithm\", name); int rc = func(words, (DArray_compare)testcmp); mu_assert(rc == 0, \"sort failed\"); mu_assert(is_sorted(words), \"didn't sort it\"); DArray_destroy(words); return NULL; } char *test_qsort() { return run_sort_test(DArray_qsort, \"qsort\"); } char *test_heapsort() { return run_sort_test(DArray_heapsort, \"heapsort\"); } char *test_mergesort() { return run_sort_test(DArray_mergesort, \"mergesort\"); } char * all_tests() { mu_suite_start(); mu_run_test(test_qsort); mu_run_test(test_heapsort); mu_run_test(test_mergesort); return NULL; } RUN_TESTS(all_tests); 你需要注意的事情是第四行testcmp的定义，它困扰了我一整天。你必须使用char **而不是char *，因为qsort会向你提供指向content数组中指针的指针。原因是qsort会打扫数组，使用你的比较函数来处理数组中每个元素的指针。因为我在contents中存储指针，所以你需要使用指针的指针。\n有了这些之后，你只需要实现三个困难的搜索算法，每个大约20行。你应该在这里停下来，不过这本书的一部分就是学习这些算法的原理，附加题会涉及到实现这些算法。\n基数排序和二分搜索 link既然你打算自己实现快速排序、堆排序和归并排序，我打算向你展示一个流行的算法叫做基数排序。它的实用性很小，只能用于整数数组，并且看上去像魔法一样。这里我打算常见一个特殊的数据结构，叫做RadixMap，用于将一个整数映射为另一个。\n下面是为新算法创建的头文件，其中也含有数据结构：\n#ifndef _radixmap_h #include typedef union RMElement { uint64_t raw; struct { uint32_t key; uint32_t value; } data; } RMElement; typedef struct RadixMap { size_t max; size_t end; uint32_t counter; RMElement *contents; RMElement *temp; } RadixMap; RadixMap *RadixMap_create(size_t max); void RadixMap_destroy(RadixMap *map); void RadixMap_sort(RadixMap *map); RMElement *RadixMap_find(RadixMap *map, uint32_t key); int RadixMap_add(RadixMap *map, uint32_t key, uint32_t value); int RadixMap_delete(RadixMap *map, RMElement *el); #endif 你看到了其中有许多和Dynamic Array或List数据结构相同的操作，不同就在于我只处理固定32位大小的uint32_t正忽视。我也会想你介绍C语言的一个新概念，叫做union。\nC联合体 link联合体是使用不同方式引用内存中同一块区域的方法。它们的工作方式，就像你把它定义为sturct，然而，每个元素共享同一片内存区域。你可以认为，联合体是内存中的一幅画，所有颜色不同的元素都重叠在它上面。\n它可以用于节约内存，或在不同格式之间转换内存块。它的第一个用途就是实现“可变类型”，你可以创建一个带有类型“标签”的结构体，之后在其中创建含有多种类型的联合体。用于在内存的不同格式之间转换时，只需要定义两个结构体，访问正确的那个类型。\n首先让我向你展示如何使用C联合体构造可变类型：\n#include typedef enum { TYPE_INT, TYPE_FLOAT, TYPE_STRING, } VariantType; struct Variant { VariantType type; union { int as_integer; float as_float; char *as_string; } data; }; typedef struct Variant Variant; void Variant_print(Variant *var) { switch(var-\u003etype) { case TYPE_INT: printf(\"INT: %d\\n\", var-\u003edata.as_integer); break; case TYPE_FLOAT: printf(\"FLOAT: %f\\n\", var-\u003edata.as_float); break; case TYPE_STRING: printf(\"STRING: %s\\n\", var-\u003edata.as_string); break; default: printf(\"UNKNOWN TYPE: %d\", var-\u003etype); } } int main(int argc, char *argv[]) { Variant a_int = {.type = TYPE_INT, .data.as_integer = 100}; Variant a_float = {.type = TYPE_FLOAT, .data.as_float = 100.34}; Variant a_string = {.type = TYPE_STRING, .data.as_string = \"YO DUDE!\"}; Variant_print(\u0026a_int); Variant_print(\u0026a_float); Variant_print(\u0026a_string); // here's how you access them a_int.data.as_integer = 200; a_float.data.as_float = 2.345; a_string.data.as_string = \"Hi there.\"; Variant_print(\u0026a_int); Variant_print(\u0026a_float); Variant_print(\u0026a_string); return 0; } 你可以在许多动态语言实现中发现它。对于为语言中所有基本类型，代码中首先定义了一些带有变迁的可变类型，之后通常给你所创建的类型打上object标签。这样的好处就是Variant通常只需要VariantType type标签的空间，加上联合体最大成员的空间，因为C将Variant.data的每个元素堆起来，它们是重叠的，只保证有足够的空间放下最大的元素。\nradixmap.h文件中我创建了RMElement联合体，用于在类型之间转换内存块。这里，我希望存储uint64_t定长整数用于排序目录，但是我也希望使用两个uint32_t用于表示数据的key和value对。通过使用联合体我就能够使用所需的两种不同方法来访问内存。\n实现 link接下来是实际的RadixMap对于这些操作的实现：\n/* * Based on code by Andre Reinald then heavily modified by Zed A. Shaw. */ #include #include #include #include #include RadixMap *RadixMap_create(size_t max) { RadixMap *map = calloc(sizeof(RadixMap), 1); check_mem(map); map-\u003econtents = calloc(sizeof(RMElement), max + 1); check_mem(map-\u003econtents); map-\u003etemp = calloc(sizeof(RMElement), max + 1); check_mem(map-\u003etemp); map-\u003emax = max; map-\u003eend = 0; return map; error: return NULL; } void RadixMap_destroy(RadixMap *map) { if(map) { free(map-\u003econtents); free(map-\u003etemp); free(map); } } #define ByteOf(x,y) (((uint8_t *)x)[(y)]) static inline void radix_sort(short offset, uint64_t max, uint64_t *source, uint64_t *dest) { uint64_t count[256] = {0}; uint64_t *cp = NULL; uint64_t *sp = NULL; uint64_t *end = NULL; uint64_t s = 0; uint64_t c = 0; // count occurences of every byte value for (sp = source, end = source + max; sp \u003c end; sp++) { count[ByteOf(sp, offset)]++; } // transform count into index by summing elements and storing into same array for (s = 0, cp = count, end = count + 256; cp \u003c end; cp++) { c = *cp; *cp = s; s += c; } // fill dest with the right values in the right place for (sp = source, end = source + max; sp \u003c end; sp++) { cp = count + ByteOf(sp, offset); dest[*cp] = *sp; ++(*cp); } } void RadixMap_sort(RadixMap *map) { uint64_t *source = \u0026map-\u003econtents[0].raw; uint64_t *temp = \u0026map-\u003etemp[0].raw; radix_sort(0, map-\u003eend, source, temp); radix_sort(1, map-\u003eend, temp, source); radix_sort(2, map-\u003eend, source, temp); radix_sort(3, map-\u003eend, temp, source); } RMElement *RadixMap_find(RadixMap *map, uint32_t to_find) { int low = 0; int high = map-\u003eend - 1; RMElement *data = map-\u003econtents; while (low \u003c= high) { int middle = low + (high - low)/2; uint32_t key = data[middle].data.key; if (to_find \u003c key) { high = middle - 1; } else if (to_find \u003e key) { low = middle + 1; } else { return \u0026data[middle]; } } return NULL; } int RadixMap_add(RadixMap *map, uint32_t key, uint32_t value) { check(key \u003c UINT32_MAX, \"Key can't be equal to UINT32_MAX.\"); RMElement element = {.data = {.key = key, .value = value}}; check(map-\u003eend + 1 \u003c map-\u003emax, \"RadixMap is full.\"); map-\u003econtents[map-\u003eend++] = element; RadixMap_sort(map); return 0; error: return -1; } int RadixMap_delete(RadixMap *map, RMElement *el) { check(map-\u003eend \u003e 0, \"There is nothing to delete.\"); check(el != NULL, \"Can't delete a NULL element.\"); el-\u003edata.key = UINT32_MAX; if(map-\u003eend \u003e 1) { // don't bother resorting a map of 1 length RadixMap_sort(map); } map-\u003eend--; return 0; error: return -1; } 像往常一样键入它并使它通过单元测试，之后我会解释它。尤其要注意radix_sort函数，我实现它的方法非常特别。\n#include \"minunit.h\" #include #include static int make_random(RadixMap *map) { size_t i = 0; for (i = 0; i \u003c map-\u003emax - 1; i++) { uint32_t key = (uint32_t)(rand() | (rand() \u003c\u003c 16)); check(RadixMap_add(map, key, i) == 0, \"Failed to add key %u.\", key); } return i; error: return 0; } static int check_order(RadixMap *map) { RMElement d1, d2; unsigned int i = 0; // only signal errors if any (should not be) for (i = 0; map-\u003eend \u003e 0 \u0026\u0026 i \u003c map-\u003eend-1; i++) { d1 = map-\u003econtents[i]; d2 = map-\u003econtents[i+1]; if(d1.data.key \u003e d2.data.key) { debug(\"FAIL:i=%u, key: %u, value: %u, equals max? %d\\n\", i, d1.data.key, d1.data.value, d2.data.key == UINT32_MAX); return 0; } } return 1; } static int test_search(RadixMap *map) { unsigned i = 0; RMElement *d = NULL; RMElement *found = NULL; for(i = map-\u003eend / 2; i \u003c map-\u003eend; i++) { d = \u0026map-\u003econtents[i]; found = RadixMap_find(map, d-\u003edata.key); check(found != NULL, \"Didn't find %u at %u.\", d-\u003edata.key, i); check(found-\u003edata.key == d-\u003edata.key, \"Got the wrong result: %p:%u looking for %u at %u\", found, found-\u003edata.key, d-\u003edata.key, i); } return 1; error: return 0; } // test for big number of elements static char *test_operations() { size_t N = 200; RadixMap *map = RadixMap_create(N); mu_assert(map != NULL, \"Failed to make the map.\"); mu_assert(make_random(map), \"Didn't make a random fake radix map.\"); RadixMap_sort(map); mu_assert(check_order(map), \"Failed to properly sort the RadixMap.\"); mu_assert(test_search(map), \"Failed the search test.\"); mu_assert(check_order(map), \"RadixMap didn't stay sorted after search.\"); while(map-\u003eend \u003e 0) { RMElement *el = RadixMap_find(map, map-\u003econtents[map-\u003eend / 2].data.key); mu_assert(el != NULL, \"Should get a result.\"); size_t old_end = map-\u003eend; mu_assert(RadixMap_delete(map, el) == 0, \"Didn't delete it.\"); mu_assert(old_end - 1 == map-\u003eend, \"Wrong size after delete.\"); // test that the end is now the old value, but uint32 max so it trails off mu_assert(check_order(map), \"RadixMap didn't stay sorted after delete.\"); } RadixMap_destroy(map); return NULL; } char *all_tests() { mu_suite_start(); srand(time(NULL)); mu_run_test(test_operations); return NULL; } RUN_TESTS(all_tests); 我不应该向你解释关于测试的过多东西，它只是模拟将随机正是放入RadixMap，确保你可以可靠地将其取出。也不是非常有趣。\n在radixmap.c中的大多数操作都易于理解，如果你阅读代码的话。下面是每个基本函数作用及其工作原理的描述：\nRadixMap_create\n像往常一样，我分配了结构体所需的内存，结构体在radixmap.h中定义。当后面涉及到radix_sort时我会使用temp和contents。\nRadixMap_destroy\n同样，销毁我所创建的东西。\nradix_sort\n这个数据结构的灵魂，我会在下一节中解释其作用。\nRadixMap_sort\n它使用了radix_sort函数来实际对contents进行排序。\nRadixMap_find\n使用二分搜索算法来寻找提供的key，我之后会解释它的原理。\nRadixMap_add\n使用RadixMap_sort函数，它会在末尾添加key和value，然后简单地重新排序使一切元素都有序。一旦排序完，RadixMap_find会正确工作，因为它是二分搜索。\nRadixMap_delete\n工作方式类似RadixMap_add，除了“删除”结构中的元素，通过将它们的值设为无符号的32为整数的最大值，也就是UINT32_MAX。这意味着你不能使用这个值作为合法的键，但是它是元素删除变得容易。简单设置它之后排序，它会被移动到末尾，这就算删除了。\n学习我所描述的代码，接下来还剩RadixMap_sort，radix_sort和RadixMap_find需要了解。\nRadixMap_find 和二分搜索 link我首先以二分搜索如何实现开始。二分搜索是一种简单算法，大多数人都可以直观地理解。实际上，你可以取一叠游戏卡片（或带有数字的卡片）来手动操作。下面是该函数的工作方式，也是二分搜索的原理：\n基于数组大小设置上界和下界。 获取上下界之间的中间元素。 如果键小于这个元素的值，就一定在它前面，所以上界设置为中间元素。 如果键大于这个元素的值，就一定在它后面，所以下界设置为中间元素。 继续循环直到上界和下界越过了彼此。如果退出了循环则没有找到。 你实际上所做的事情是，通过挑选中间的值来比较，猜出key可能的位置。由于数据是有序的，你知道key一定会在它前面或者后面，这样就能把搜索区域分成两半。之后你继续搜索知道找到他，或者越过了边界并穷尽了搜索空间。\nRadixMap_sort 和 radix_sort link如果你事先手动模拟基数排序，它就很易于理解。这个算法利用了一个现象，数字都以十进制字符的序列来表示，按照“不重要”到“重要”的顺序排列。之后它通过十进制字符来选取数字并且将它们储存在桶中，当它处理完所有字符时，数字就排好序了。一开始它看上去像是魔法，浏览代码也的确如此，但是你要尝试手动执行它。\n为了解释这个算法，需要先写下一组三位的十进制数，以随机的顺序，假设就是223、912、275、100、633、120 和 380。\n按照它们的个位，将数字放入桶中：[380, 100, 120], [912], [633, 223], [275]。 现在遍历每个桶中的数字，接着按十位排序：[100], [912], [120, 223], [633], [275], [380]。 现在每个桶都包含了按照个位和十位排序后的数字。接着我需要按照这个顺序遍历，并把它们放入最后百位的桶中：[100, 120], [223, 275], [380], [633], [912]。 到现在为止，每个数字都按照百位、十位和个位排序，并且如果我按照顺序遍历每个桶，我会得到最终排序的结果：100, 120, 223, 275, 380, 633, 912。 确保你多次重复了这个过程，便于你理解它如何工作。这实在是一种机智的算法，并且最重要的是它对于任何大小的数字都有效。所以你可以用它来排序比较大的数字，因为你一次只是处理一位。\n在我的环境下，“字符”是独立的8位字节，所以我需要256个桶来储存这些数字按照字节的分布结果。我需要一种方法来储存它，并且不需要花费太多的空间。如果你查看radix_sort，首先我会构建count直方图，便于我了解对于给定的offset，每个字节的频率。\n一旦我知道了每一种字节的数量（共有256种），我就可以将目标数组用于存储这些值的分布。比如，如果0x00的数量为10个，我就可以将它们放在目标数组的前10个位置中。这可以让我索引到它们在目标数组中的位置，这就是radix_sort中的第二个for循环。\n最后，当我知道它们在目标数组中储存在哪里，我只是遍历source数组对于当前offset的所有字节，并且将数值按顺序放入它们的位置中。ByteOf宏的使用有助于保持代码整洁，因为它需要一些指针的黑魔法，但是最后当for循环结束之后，所有整数都会按照它们的字节放入桶中。\n我在RadixMap_sort中对这些64位的整数按照它们的前32位进行排序，这非常有意思。还记得我是如何将键和值放入RMElement类型的联合体了吗？这意味着如果要按照键来对这个数组排序，我只需要对每个整数前4个字节（32位/8位每字节）进行排序。\n如果你观察RadixMap_sort，你会看到我获取了contents和temp的便利指针，用于源数组和目标数组，之后我四次调用radix_sort。每次调用我将源数组和目标数组替换为下一字节的情况。当我完成时，radix_sort就完成了任务，并且contents中也有了最后的结果。\n如何改进 link这个实现有个很大的缺点，就是它遍历了整个数组四次。它执行地很快，但是如果你通过需要排序的数值大小来限制排序的总量，会更好一些。\n有两个方法可以用于改进这个实现：\n使用二分搜索来寻找新元素的最小位置，只对这个位置到微末之间进行排序。你需要找到它，将新元素放到末尾，之后对它们之间进行排序。大多数情况下这会显著地缩减排序范围。 跟踪当前所使用的最大的键，之后只对足够的位数进行排序，来处理这个键。你也可以跟踪最小的数值，之后只对范围中必要的字节进行排序。为了这样做，你需要关心CPU的整数存储顺序（大小端序）。 附加题 link 实现快速排序、堆排序和归并排序，并且提供一个#define让其他人在二者（标准库和你的实现）当中进行选择，或者创建另一套不同名称的函数。使用我教给你的技巧，阅读维基百科的算法页面，之后参照伪代码来实现它。 对比你的实现和标准库实现的性能。 使用这些排序函数创建DArray_sort_add，它可以向DArray添加元素，但是随后对数组排序。 编写DArray_find，使用RadixMap_find中的二分搜索算法和DArray_compare，来在有序的DArray中寻找元素。 "
            }
        );
    index.add(
            {
                id:  46 ,
                href: "\/TechDocs\/docs\/c-guide\/ex36\/",
                title: "练习36：更安全的字符串",
                description: "原文：Exercise 36: Safer Strings 译者：飞龙 我已经在练习26中，构建devpkg的时候介绍了Better String库。这个练习让你从现在开始熟悉bstring库，并且明白C风格字符串为什么十分糟糕。之后你需要修改liblcthw的代码来使用bstring。 为什么C风格字符串十分糟糕 link当人们谈论C的问题时，“字符串”的概念永远是首要缺陷之一。你已经用过它们，并且我也谈论过它们的种种缺陷，但是对为什么C字符串拥有缺陷，以及为什么一直是这样没有明确的解释。我会试着现在做出解释，部分原因是C风格字符串经过数十年的使用，有足够的证据表明它们是个非常糟糕的东西。 对于给定的任何C风格字符串，都不可能验证它是否有效。 以'\\0'结尾的C字符串是有效的。 任何处理无效C字符串的循环都是无限的（或者造成缓冲区溢出）。 C字符串没有确定的长度，所以检查它们的唯一方法就是遍历它来观察循环是否正确终止。 所以，不通过有限的循环就不可能验证C字符串。 这个逻辑非常简单。你不能编写一个循环来验证C字符串是否有效，因为无效的字符串导致循环永远不会停止。就是这样，唯一的解决方案就是包含大小。一旦你知道了大小，你可以避免无限循环问题。如果你观察练习27中我向你展示的两个函数： 译者注：检验C风格字符串是否有效等价于“停机问题”，这是一个非常著名的不可解问题。 void copy(char to[], char from[]) { int i = 0; // while loop will not end if from isn't '\\0' terminated while((to[i] = from[i]) != '\\0') { ++i; } } int safercopy(int from_len, char *from, int to_len, char *to) { int i = 0; int max = from_len \u003e to_len - 1 ? to_len - 1 : from_len; // to_len must have at least 1 byte if(from_len \u003c 0 || to_len \u003c= 0) return -1; for(i = 0; i \u003c max; i++) { to[i] = from[i]; } to[to_len - 1] = '\\0'; return i; } 想象你想要向copy函数添加检查来确保from字符串有效。你该怎么做呢？你编写了一个循环来检查字符串是否已'\\0'结尾。哦，等一下，如果字符串不以'\\0'结尾，那它怎么让循环停下？不可能停下，所以无解。",
                content: " 原文：Exercise 36: Safer Strings\n译者：飞龙\n我已经在练习26中，构建devpkg的时候介绍了Better String库。这个练习让你从现在开始熟悉bstring库，并且明白C风格字符串为什么十分糟糕。之后你需要修改liblcthw的代码来使用bstring。\n为什么C风格字符串十分糟糕 link当人们谈论C的问题时，“字符串”的概念永远是首要缺陷之一。你已经用过它们，并且我也谈论过它们的种种缺陷，但是对为什么C字符串拥有缺陷，以及为什么一直是这样没有明确的解释。我会试着现在做出解释，部分原因是C风格字符串经过数十年的使用，有足够的证据表明它们是个非常糟糕的东西。\n对于给定的任何C风格字符串，都不可能验证它是否有效。\n以'\\0'结尾的C字符串是有效的。 任何处理无效C字符串的循环都是无限的（或者造成缓冲区溢出）。 C字符串没有确定的长度，所以检查它们的唯一方法就是遍历它来观察循环是否正确终止。 所以，不通过有限的循环就不可能验证C字符串。 这个逻辑非常简单。你不能编写一个循环来验证C字符串是否有效，因为无效的字符串导致循环永远不会停止。就是这样，唯一的解决方案就是包含大小。一旦你知道了大小，你可以避免无限循环问题。如果你观察练习27中我向你展示的两个函数：\n译者注：检验C风格字符串是否有效等价于“停机问题”，这是一个非常著名的不可解问题。\nvoid copy(char to[], char from[]) { int i = 0; // while loop will not end if from isn't '\\0' terminated while((to[i] = from[i]) != '\\0') { ++i; } } int safercopy(int from_len, char *from, int to_len, char *to) { int i = 0; int max = from_len \u003e to_len - 1 ? to_len - 1 : from_len; // to_len must have at least 1 byte if(from_len \u003c 0 || to_len \u003c= 0) return -1; for(i = 0; i \u003c max; i++) { to[i] = from[i]; } to[to_len - 1] = '\\0'; return i; } 想象你想要向copy函数添加检查来确保from字符串有效。你该怎么做呢？你编写了一个循环来检查字符串是否已'\\0'结尾。哦，等一下，如果字符串不以'\\0'结尾，那它怎么让循环停下？不可能停下，所以无解。\n无论你怎么做，你都不能在不知道字符串长度的情况下检查C字符串的有效性，这里safercopy包含了程度。这个函数没有相同的问题，因为他的循环一定会中止，即使你传入了错误的大小，大小也是有限的。\n译者注：但是问题来了，对于一个C字符串，你怎么获取其大小？你需要在这个函数之前调用strlen，又是一个无限循环问题。\n于是，bstring库所做的事情就是创建一个结构体，它总是包含字符串长度。由于这个长度对于bstring来说总是可访问的，它上面的所有操作都会更安全。循环是有限的，内容也是有效的，并且这个主要的缺陷也不存在了。BString库也带有大量所需的字串操作，比如分割、格式化、搜索，并且大多数都会正确并安全地执行。\nbstring中也可能有缺陷，但是经过这么长时间，可能性已经很低了。glibc中也有缺陷，所以你让程序员怎么做才好呢？\n使用 bstrlib link有很多改进后的字符串库，但是我最喜欢bstrlib，因为它只有一个程序集，并且具有大多数所需的字符串功能。你已经在使用它了，所以这个练习中你需要从Better String获取两个文件，bstrlib.c和bstrlib.h。\n下面是我在liblcthw项目目录里所做的事情：\n$ mkdir bstrlib $ cd bstrlib/ $ unzip ~/Downloads/bstrlib-05122010.zip Archive: /Users/zedshaw/Downloads/bstrlib-05122010.zip ... $ ls bsafe.c bstraux.c bstrlib.h bstrwrap.h license.txt test.cpp bsafe.h bstraux.h bstrlib.txt cpptest.cpp porting.txt testaux.c bstest.c bstrlib.c bstrwrap.cpp gpl.txt security.txt $ mv bstrlib.h bstrlib.c ../src/lcthw/ $ cd ../ $ rm -rf bstrlib $ vim src/lcthw/bstrlib.c $ make clean all ... $ 在第14行你可以看到，我编辑了bstrlib.c文件，来将它移动到新的位置，并且修复OSX上的bug。下面是差异：\n25c25 \u003c #include \"bstrlib.h\" --- \u003e #include 2759c2759 \u003c #ifdef __GNUC__ --- \u003e #if defined(__GNUC__) \u0026\u0026 !defined(__APPLE__) 我把包含修改为，然后修复2759行ifdef的问题。\n学习使用该库 link这个练习很短，只是让你准备好剩余的练习，它们会用到这个库。接下来两个联系中，我会使用bstrlib.c来创建Hashmap`数据结构。\n你现在应该阅读头文件和实现，之后编写tests/bstr_tests.c来测试下列函数，来熟悉这个库：\nbfromcstr\n从C风格字符串中创建一个bstring。\nblk2bstr\n与上面相同，但是可以提供缓冲区长度。\nbstrcpy\n复制bstring。\nbassign\n将一个bstring赋值为另一个。\nbassigncstr\n将bsting的内容设置为C字符串的内容。\nbassignblk\n将bsting的内容设置为C字符串的内容，但是可以提供长度。\nbdestroy\n销毁bstring。\nbconcat\n在一个bstring末尾连接另一个。\nbstricmp\n比较两个bstring，返回值与strcmp相同。\nbiseq\n检查两个bstring是否相等。\nbinstr\n判断一个bstring是否被包含于另一个。\nbfindreplace\n在一个bstring中寻找另一个，并且将其替换为别的。\nbsplit\n将bstring分割为bstrList。\nbformat\n执行字符串格式化，十分便利。\nblength\n获取bstring的长度。\nbdata\n获取bstring的数据。\nbchar\n获得bstring中的字符。\n你的测试应该覆盖到所有这些操作，以及你从头文件中发现的更多有趣的东西。在valgrind下运行测试，确保内存使用正确。\n"
            }
        );
    index.add(
            {
                id:  47 ,
                href: "\/TechDocs\/docs\/c-guide\/ex37\/",
                title: "练习37：哈希表",
                description: "原文：Exercise 37: Hashmaps 译者：飞龙 哈希表（HashMap、HashTable以及Dictionary）广泛用于许多动态编程语言来储存键值对的数据。哈希表通过在键上执行“哈希”运算产生整数，之后使用它来寻找相应的桶来获取或储存值。它是非常快速的使用数据结构，因为它适用于任何数据并且易于实现。 下面是哈希表（也叫作字典）的一个使用示例： fruit_weights = {'Apples': 10, 'Oranges': 100, 'Grapes': 1.0} for key, value in fruit_weights.items(): print key, \"=\", value 几乎所有现代语言都具备这种特性，所以许多人写完代码都不知道它实际上如何工作。通过在C中创建Hashmap数据结构，我会向你展示它的工作原理。我会从头文件开始，来谈论整个数据结构。 #ifndef _lcthw_Hashmap_h #define _lcthw_Hashmap_h #include #include #define DEFAULT_NUMBER_OF_BUCKETS 100 typedef int (*Hashmap_compare)(void *a, void *b); typedef uint32_t (*Hashmap_hash)(void *key); typedef struct Hashmap { DArray *buckets; Hashmap_compare compare; Hashmap_hash hash; } Hashmap; typedef struct HashmapNode { void *key; void *data; uint32_t hash; } HashmapNode; typedef int (*Hashmap_traverse_cb)(HashmapNode *node); Hashmap *Hashmap_create(Hashmap_compare compare, Hashmap_hash); void Hashmap_destroy(Hashmap *map); int Hashmap_set(Hashmap *map, void *key, void *data); void *Hashmap_get(Hashmap *map, void *key); int Hashmap_traverse(Hashmap *map, Hashmap_traverse_cb traverse_cb); void *Hashmap_delete(Hashmap *map, void *key); #endif 这个结构就是Hashmap，含有许多HashmapNode节点。观察Hashmap你会看到它类似这样：",
                content: " 原文：Exercise 37: Hashmaps\n译者：飞龙\n哈希表（HashMap、HashTable以及Dictionary）广泛用于许多动态编程语言来储存键值对的数据。哈希表通过在键上执行“哈希”运算产生整数，之后使用它来寻找相应的桶来获取或储存值。它是非常快速的使用数据结构，因为它适用于任何数据并且易于实现。\n下面是哈希表（也叫作字典）的一个使用示例：\nfruit_weights = {'Apples': 10, 'Oranges': 100, 'Grapes': 1.0} for key, value in fruit_weights.items(): print key, \"=\", value 几乎所有现代语言都具备这种特性，所以许多人写完代码都不知道它实际上如何工作。通过在C中创建Hashmap数据结构，我会向你展示它的工作原理。我会从头文件开始，来谈论整个数据结构。\n#ifndef _lcthw_Hashmap_h #define _lcthw_Hashmap_h #include #include #define DEFAULT_NUMBER_OF_BUCKETS 100 typedef int (*Hashmap_compare)(void *a, void *b); typedef uint32_t (*Hashmap_hash)(void *key); typedef struct Hashmap { DArray *buckets; Hashmap_compare compare; Hashmap_hash hash; } Hashmap; typedef struct HashmapNode { void *key; void *data; uint32_t hash; } HashmapNode; typedef int (*Hashmap_traverse_cb)(HashmapNode *node); Hashmap *Hashmap_create(Hashmap_compare compare, Hashmap_hash); void Hashmap_destroy(Hashmap *map); int Hashmap_set(Hashmap *map, void *key, void *data); void *Hashmap_get(Hashmap *map, void *key); int Hashmap_traverse(Hashmap *map, Hashmap_traverse_cb traverse_cb); void *Hashmap_delete(Hashmap *map, void *key); #endif 这个结构就是Hashmap，含有许多HashmapNode节点。观察Hashmap你会看到它类似这样：\nDArray *buckets\n一个动态数组，设置为100个桶的固定大小。每个桶会含有一个DArray，来实际存档HashmapNode对。\nHashmap_compare compare\n这是一个比较函数，被Hashmap用于实际用过键寻找元素。它应该和其它的比较函数类似，并且默认设置为bstrcmp来比较字符串。\nHashmap_hash\n这是哈希函数，它用于接收键，处理它的内容，之后产生一个uint32_t索引数值。之后你会看到默认的实现。\n这些告诉了你数据如何存储，但是用作buckets的DArray还没有创建。要记住它具有二层结构；\n第一层有100个桶，数据基于它们的哈希值储存在桶中。 每个桶都是一个DArray，其中含有HashmapNode，添加时只是简单地附加到末尾。 HashMapNode由下面三个元素组成：\nvoid *key\n键值对的键。\nvoid *value\n键值对的值。\nuint32_t hash\n计算出的哈希值，它用于使查找该节点更加迅速，只要判断键是否相等。\n有文件的剩余部分没有新的东西，所以我现在可以向你展示hashmap.c的实现了：\n#undef NDEBUG #include #include #include #include static int default_compare(void *a, void *b) { return bstrcmp((bstring)a, (bstring)b); } /** * Simple Bob Jenkins's hash algorithm taken from the * wikipedia description. */ static uint32_t default_hash(void *a) { size_t len = blength((bstring)a); char *key = bdata((bstring)a); uint32_t hash = 0; uint32_t i = 0; for(hash = i = 0; i \u003c len; ++i) { hash += key[i]; hash += (hash \u003c\u003c 10); hash ^= (hash \u003e\u003e 6); } hash += (hash \u003c\u003c 3); hash ^= (hash \u003e\u003e 11); hash += (hash \u003c\u003c 15); return hash; } Hashmap *Hashmap_create(Hashmap_compare compare, Hashmap_hash hash) { Hashmap *map = calloc(1, sizeof(Hashmap)); check_mem(map); map-\u003ecompare = compare == NULL ? default_compare : compare; map-\u003ehash = hash == NULL ? default_hash : hash; map-\u003ebuckets = DArray_create(sizeof(DArray *), DEFAULT_NUMBER_OF_BUCKETS); map-\u003ebuckets-\u003eend = map-\u003ebuckets-\u003emax; // fake out expanding it check_mem(map-\u003ebuckets); return map; error: if(map) { Hashmap_destroy(map); } return NULL; } void Hashmap_destroy(Hashmap *map) { int i = 0; int j = 0; if(map) { if(map-\u003ebuckets) { for(i = 0; i \u003c DArray_count(map-\u003ebuckets); i++) { DArray *bucket = DArray_get(map-\u003ebuckets, i); if(bucket) { for(j = 0; j \u003c DArray_count(bucket); j++) { free(DArray_get(bucket, j)); } DArray_destroy(bucket); } } DArray_destroy(map-\u003ebuckets); } free(map); } } static inline HashmapNode *Hashmap_node_create(int hash, void *key, void *data) { HashmapNode *node = calloc(1, sizeof(HashmapNode)); check_mem(node); node-\u003ekey = key; node-\u003edata = data; node-\u003ehash = hash; return node; error: return NULL; } static inline DArray *Hashmap_find_bucket(Hashmap *map, void *key, int create, uint32_t *hash_out) { uint32_t hash = map-\u003ehash(key); int bucket_n = hash % DEFAULT_NUMBER_OF_BUCKETS; check(bucket_n \u003e= 0, \"Invalid bucket found: %d\", bucket_n); *hash_out = hash; // store it for the return so the caller can use it DArray *bucket = DArray_get(map-\u003ebuckets, bucket_n); if(!bucket \u0026\u0026 create) { // new bucket, set it up bucket = DArray_create(sizeof(void *), DEFAULT_NUMBER_OF_BUCKETS); check_mem(bucket); DArray_set(map-\u003ebuckets, bucket_n, bucket); } return bucket; error: return NULL; } int Hashmap_set(Hashmap *map, void *key, void *data) { uint32_t hash = 0; DArray *bucket = Hashmap_find_bucket(map, key, 1, \u0026hash); check(bucket, \"Error can't create bucket.\"); HashmapNode *node = Hashmap_node_create(hash, key, data); check_mem(node); DArray_push(bucket, node); return 0; error: return -1; } static inline int Hashmap_get_node(Hashmap *map, uint32_t hash, DArray *bucket, void *key) { int i = 0; for(i = 0; i \u003c DArray_end(bucket); i++) { debug(\"TRY: %d\", i); HashmapNode *node = DArray_get(bucket, i); if(node-\u003ehash == hash \u0026\u0026 map-\u003ecompare(node-\u003ekey, key) == 0) { return i; } } return -1; } void *Hashmap_get(Hashmap *map, void *key) { uint32_t hash = 0; DArray *bucket = Hashmap_find_bucket(map, key, 0, \u0026hash); if(!bucket) return NULL; int i = Hashmap_get_node(map, hash, bucket, key); if(i == -1) return NULL; HashmapNode *node = DArray_get(bucket, i); check(node != NULL, \"Failed to get node from bucket when it should exist.\"); return node-\u003edata; error: // fallthrough return NULL; } int Hashmap_traverse(Hashmap *map, Hashmap_traverse_cb traverse_cb) { int i = 0; int j = 0; int rc = 0; for(i = 0; i \u003c DArray_count(map-\u003ebuckets); i++) { DArray *bucket = DArray_get(map-\u003ebuckets, i); if(bucket) { for(j = 0; j \u003c DArray_count(bucket); j++) { HashmapNode *node = DArray_get(bucket, j); rc = traverse_cb(node); if(rc != 0) return rc; } } } return 0; } void *Hashmap_delete(Hashmap *map, void *key) { uint32_t hash = 0; DArray *bucket = Hashmap_find_bucket(map, key, 0, \u0026hash); if(!bucket) return NULL; int i = Hashmap_get_node(map, hash, bucket, key); if(i == -1) return NULL; HashmapNode *node = DArray_get(bucket, i); void *data = node-\u003edata; free(node); HashmapNode *ending = DArray_pop(bucket); if(ending != node) { // alright looks like it's not the last one, swap it DArray_set(bucket, i, ending); } return data; } 这个实现中并没有什么复杂的东西，但是default_hash和Hashmap_find_bucket需要一些解释。当你使用Hashmap_create时，你可以传入任何定制的比较和哈希函数。但是如果你没有则会使用default_compare和default_hash函数。\n需要观察的第一件事，是default_hash的行为。这是一个简单的哈希函数，叫做“Jenkins hash”，以Bob Jenkins的名字命名。我从维基百科上获得了这个算法。它仅仅遍历键（bstring）的每个字节来计算哈希，以便得出uint32_t的结果。它使用一些加法和异或运算来实现。\n哈希函数有很多中，它们具有不同的特性，然而一旦你选择了一种，就需要一种方法来使用它找到正确的桶。Hashmap_find_bucket像这样实现它：\n首先调用 map-\u003ehash(key)来获得键的哈希值。 之后使用hash % DEFAULT_NUMBER_OF_BUCKETS，这样无论哈希值有多大，都能找到匹配的桶。 找到桶之后，它是个DArray，可能还没有创建，这取决与create变量的内容。 一旦找到了正确的DArray桶，就会将它返回，并且hash_out变量用于向调用者提供所找到的哈希值。 其它函数都使用Hashmap_find_bucket来完成工作：\n设置键值对涉及到找到正确的桶，之后创建HashmapNode，将它添加到桶中。 获取键值涉及到找到正确的桶，之后找到匹配hash和key的HashmapNode。 删除元素也需要找到正确的桶，找到所需的节点，之后通过与末尾的节点交换位置来删除。 你需要学习的唯一一个其他函数是Hashmap_travers，它仅仅遍历每个桶，对于任何含有值的桶，在每个值上调用traverse_cb。这就是扫描整个Hashmap的办法。\n单元测试 link最后你需要编写单元测试，对于所有这些操作：\n#include \"minunit.h\" #include #include #include Hashmap *map = NULL; static int traverse_called = 0; struct tagbstring test1 = bsStatic(\"test data 1\"); struct tagbstring test2 = bsStatic(\"test data 2\"); struct tagbstring test3 = bsStatic(\"xest data 3\"); struct tagbstring expect1 = bsStatic(\"THE VALUE 1\"); struct tagbstring expect2 = bsStatic(\"THE VALUE 2\"); struct tagbstring expect3 = bsStatic(\"THE VALUE 3\"); static int traverse_good_cb(HashmapNode *node) { debug(\"KEY: %s\", bdata((bstring)node-\u003ekey)); traverse_called++; return 0; } static int traverse_fail_cb(HashmapNode *node) { debug(\"KEY: %s\", bdata((bstring)node-\u003ekey)); traverse_called++; if(traverse_called == 2) { return 1; } else { return 0; } } char *test_create() { map = Hashmap_create(NULL, NULL); mu_assert(map != NULL, \"Failed to create map.\"); return NULL; } char *test_destroy() { Hashmap_destroy(map); return NULL; } char *test_get_set() { int rc = Hashmap_set(map, \u0026test1, \u0026expect1); mu_assert(rc == 0, \"Failed to set \u0026test1\"); bstring result = Hashmap_get(map, \u0026test1); mu_assert(result == \u0026expect1, \"Wrong value for test1.\"); rc = Hashmap_set(map, \u0026test2, \u0026expect2); mu_assert(rc == 0, \"Failed to set test2\"); result = Hashmap_get(map, \u0026test2); mu_assert(result == \u0026expect2, \"Wrong value for test2.\"); rc = Hashmap_set(map, \u0026test3, \u0026expect3); mu_assert(rc == 0, \"Failed to set test3\"); result = Hashmap_get(map, \u0026test3); mu_assert(result == \u0026expect3, \"Wrong value for test3.\"); return NULL; } char *test_traverse() { int rc = Hashmap_traverse(map, traverse_good_cb); mu_assert(rc == 0, \"Failed to traverse.\"); mu_assert(traverse_called == 3, \"Wrong count traverse.\"); traverse_called = 0; rc = Hashmap_traverse(map, traverse_fail_cb); mu_assert(rc == 1, \"Failed to traverse.\"); mu_assert(traverse_called == 2, \"Wrong count traverse for fail.\"); return NULL; } char *test_delete() { bstring deleted = (bstring)Hashmap_delete(map, \u0026test1); mu_assert(deleted != NULL, \"Got NULL on delete.\"); mu_assert(deleted == \u0026expect1, \"Should get test1\"); bstring result = Hashmap_get(map, \u0026test1); mu_assert(result == NULL, \"Should delete.\"); deleted = (bstring)Hashmap_delete(map, \u0026test2); mu_assert(deleted != NULL, \"Got NULL on delete.\"); mu_assert(deleted == \u0026expect2, \"Should get test2\"); result = Hashmap_get(map, \u0026test2); mu_assert(result == NULL, \"Should delete.\"); deleted = (bstring)Hashmap_delete(map, \u0026test3); mu_assert(deleted != NULL, \"Got NULL on delete.\"); mu_assert(deleted == \u0026expect3, \"Should get test3\"); result = Hashmap_get(map, \u0026test3); mu_assert(result == NULL, \"Should delete.\"); return NULL; } char *all_tests() { mu_suite_start(); mu_run_test(test_create); mu_run_test(test_get_set); mu_run_test(test_traverse); mu_run_test(test_delete); mu_run_test(test_destroy); return NULL; } RUN_TESTS(all_tests); 需要学习的唯一一件事情就是我在单元测试的顶端使用了bstring的特性来创建静态字符串用于测试。我使用tagbstring和bsStatic在7~13行创建他们。\n如何改进 link这是一个非常简单的Hashmap实现，就像书中的大多数其他数据结构那样。我的目标不是让你以非常快的速度来掌握数据结构。通常这些讨论起来非常复杂，并且会让你偏离真正的基础和实用的数据结构。我的目标是提供一个易于理解的起始点，然后再改进或理解它们如何实现。\n对于这和练习，下面是你能够用于改进这个实现的方法：\n你可以对每个桶进行排序，使它们有序。这会增加你的插入时间，但是减少寻找时间，因为你可以使用二分搜索来寻找每个节点。到现在为止它遍历桶中的所有节点来寻找元素。 你可以动态设定桶的数量，或者让调用者指定每个Hashmap中的该值。 你可以使用更好的default_hash函数，有许多这样的函数。 这个实现以及几乎所有实现都有将一些特定的键存到一个桶中的风险。这会使你的程序运行速度变慢，因为它使Hashmap的处理过程变成了处理单个的DArray。如果你对桶中的数组排序会有帮助，但是你可以仅仅使用更好的哈希函数来避免，并且对于真正的偏执狂，你可以添加一个随机的盐，让键不可预测。 你可以删掉不歪有任何节点的桶来节约空间，或者将空的桶当如缓存中，便于节约创建和销毁它们的开销。 现在为止它可以添加已存在的元素，编写一个替代的实现，使它只能够添加不存在的元素。 像往常一样，你需要浏览每个函数，并且使之健壮。Hashmap也可以使用一些调试设置，来执行不变量检查。\n附加题 link 研究你最喜欢的编程语言的Hashmap实现，了解它们具有什么特性。 找到Hashmap的主要缺点，以及如何避免它们。例如，它们不做特定的修改就不能保存顺序，并且当你基于键的一部分来查找元素时，它们就不能生效。 编写单元测试来展示将键都填充到Hashmap的一个桶中所带来的缺陷，之后测试这样如何影响性能。一个实现它的好方法，就是把桶的数量减少到一个愚蠢的数值，比如1。 "
            }
        );
    index.add(
            {
                id:  48 ,
                href: "\/TechDocs\/docs\/c-guide\/ex38\/",
                title: "练习38：哈希算法",
                description: "原文：Exercise 38: Hashmap Algorithms 译者：飞龙 你需要在这个练习中实现下面这三个哈希函数： FNV-1a 以创造者Glenn Fowler、Phong Vo 和 Landon Curt Noll的名字命名。这个算法产生合理的数值并且相当快。 Adler-32 以Mark Adler命名。一个比较糟糕的算法，但是由来已久并且适于学习。 DJB Hash 由Dan J. Bernstein (DJB)发明的哈希算法，但是难以找到这个算法的讨论。它非常快，但是结果不是很好。 你应该看到我使用了Jenkins hash作为Hashmap数据结构的默认哈希函数，所以这个练习的重点会放在这三个新的函数上。它们的代码通常来说不多，并且没有任何优化。像往常一样我会放慢速度来让你理解。 头文件非常简单，所以我以它开始： #ifndef hashmap_algos_h #define hashmap_algos_h #include uint32_t Hashmap_fnv1a_hash(void *data); uint32_t Hashmap_adler32_hash(void *data); uint32_t Hashmap_djb_hash(void *data); #endif 我只是声明了三个函数，我会在hashmap_algos.c文件中实现它们： #include #include // settings taken from // http://www.isthe.com/chongo/tech/comp/fnv/index.html#FNV-param const uint32_t FNV_PRIME = 16777619; const uint32_t FNV_OFFSET_BASIS = 2166136261; uint32_t Hashmap_fnv1a_hash(void *data) { bstring s = (bstring)data; uint32_t hash = FNV_OFFSET_BASIS; int i = 0; for(i = 0; i \u003c blength(s); i++) { hash ^= bchare(s, i, 0); hash *= FNV_PRIME; } return hash; } const int MOD_ADLER = 65521; uint32_t Hashmap_adler32_hash(void *data) { bstring s = (bstring)data; uint32_t a = 1, b = 0; int i = 0; for (i = 0; i \u003c blength(s); i++) { a = (a + bchare(s, i, 0)) % MOD_ADLER; b = (b + a) % MOD_ADLER; } return (b \u003c\u003c 16) | a; } uint32_t Hashmap_djb_hash(void *data) { bstring s = (bstring)data; uint32_t hash = 5381; int i = 0; for(i = 0; i \u003c blength(s); i++) { hash = ((hash \u003c\u003c 5) + hash) + bchare(s, i, 0); /* hash * 33 + c */ } return hash; } 这个文件中有三个哈希函数。你应该注意到我默认使用bstring作为键，并且使用了bchare函数从字符串获取字符，然而如果字符超出了字符串的长度会返回0。",
                content: " 原文：Exercise 38: Hashmap Algorithms\n译者：飞龙\n你需要在这个练习中实现下面这三个哈希函数：\nFNV-1a\n以创造者Glenn Fowler、Phong Vo 和 Landon Curt Noll的名字命名。这个算法产生合理的数值并且相当快。\nAdler-32\n以Mark Adler命名。一个比较糟糕的算法，但是由来已久并且适于学习。\nDJB Hash\n由Dan J. Bernstein (DJB)发明的哈希算法，但是难以找到这个算法的讨论。它非常快，但是结果不是很好。\n你应该看到我使用了Jenkins hash作为Hashmap数据结构的默认哈希函数，所以这个练习的重点会放在这三个新的函数上。它们的代码通常来说不多，并且没有任何优化。像往常一样我会放慢速度来让你理解。\n头文件非常简单，所以我以它开始：\n#ifndef hashmap_algos_h #define hashmap_algos_h #include uint32_t Hashmap_fnv1a_hash(void *data); uint32_t Hashmap_adler32_hash(void *data); uint32_t Hashmap_djb_hash(void *data); #endif 我只是声明了三个函数，我会在hashmap_algos.c文件中实现它们：\n#include #include // settings taken from // http://www.isthe.com/chongo/tech/comp/fnv/index.html#FNV-param const uint32_t FNV_PRIME = 16777619; const uint32_t FNV_OFFSET_BASIS = 2166136261; uint32_t Hashmap_fnv1a_hash(void *data) { bstring s = (bstring)data; uint32_t hash = FNV_OFFSET_BASIS; int i = 0; for(i = 0; i \u003c blength(s); i++) { hash ^= bchare(s, i, 0); hash *= FNV_PRIME; } return hash; } const int MOD_ADLER = 65521; uint32_t Hashmap_adler32_hash(void *data) { bstring s = (bstring)data; uint32_t a = 1, b = 0; int i = 0; for (i = 0; i \u003c blength(s); i++) { a = (a + bchare(s, i, 0)) % MOD_ADLER; b = (b + a) % MOD_ADLER; } return (b \u003c\u003c 16) | a; } uint32_t Hashmap_djb_hash(void *data) { bstring s = (bstring)data; uint32_t hash = 5381; int i = 0; for(i = 0; i \u003c blength(s); i++) { hash = ((hash \u003c\u003c 5) + hash) + bchare(s, i, 0); /* hash * 33 + c */ } return hash; } 这个文件中有三个哈希函数。你应该注意到我默认使用bstring作为键，并且使用了bchare函数从字符串获取字符，然而如果字符超出了字符串的长度会返回0。\n这些算法中每个都可以在网上搜索到，所以你需要搜索它们并阅读相关内容。同时我主要使用维基百科上的结果，之后参照了其它来源。\n接着我为每个算法编写了单元测试，同时也测试了它们在多个桶中的分布情况。\n#include #include #include #include #include \"minunit.h\" struct tagbstring test1 = bsStatic(\"test data 1\"); struct tagbstring test2 = bsStatic(\"test data 2\"); struct tagbstring test3 = bsStatic(\"xest data 3\"); char *test_fnv1a() { uint32_t hash = Hashmap_fnv1a_hash(\u0026test1); mu_assert(hash != 0, \"Bad hash.\"); hash = Hashmap_fnv1a_hash(\u0026test2); mu_assert(hash != 0, \"Bad hash.\"); hash = Hashmap_fnv1a_hash(\u0026test3); mu_assert(hash != 0, \"Bad hash.\"); return NULL; } char *test_adler32() { uint32_t hash = Hashmap_adler32_hash(\u0026test1); mu_assert(hash != 0, \"Bad hash.\"); hash = Hashmap_adler32_hash(\u0026test2); mu_assert(hash != 0, \"Bad hash.\"); hash = Hashmap_adler32_hash(\u0026test3); mu_assert(hash != 0, \"Bad hash.\"); return NULL; } char *test_djb() { uint32_t hash = Hashmap_djb_hash(\u0026test1); mu_assert(hash != 0, \"Bad hash.\"); hash = Hashmap_djb_hash(\u0026test2); mu_assert(hash != 0, \"Bad hash.\"); hash = Hashmap_djb_hash(\u0026test3); mu_assert(hash != 0, \"Bad hash.\"); return NULL; } #define BUCKETS 100 #define BUFFER_LEN 20 #define NUM_KEYS BUCKETS * 1000 enum { ALGO_FNV1A, ALGO_ADLER32, ALGO_DJB}; int gen_keys(DArray *keys, int num_keys) { int i = 0; FILE *urand = fopen(\"/dev/urandom\", \"r\"); check(urand != NULL, \"Failed to open /dev/urandom\"); struct bStream *stream = bsopen((bNread)fread, urand); check(stream != NULL, \"Failed to open /dev/urandom\"); bstring key = bfromcstr(\"\"); int rc = 0; // FNV1a histogram for(i = 0; i \u003c num_keys; i++) { rc = bsread(key, stream, BUFFER_LEN); check(rc \u003e= 0, \"Failed to read from /dev/urandom.\"); DArray_push(keys, bstrcpy(key)); } bsclose(stream); fclose(urand); return 0; error: return -1; } void destroy_keys(DArray *keys) { int i = 0; for(i = 0; i \u003c NUM_KEYS; i++) { bdestroy(DArray_get(keys, i)); } DArray_destroy(keys); } void fill_distribution(int *stats, DArray *keys, Hashmap_hash hash_func) { int i = 0; uint32_t hash = 0; for(i = 0; i \u003c DArray_count(keys); i++) { hash = hash_func(DArray_get(keys, i)); stats[hash % BUCKETS] += 1; } } char *test_distribution() { int i = 0; int stats[3][BUCKETS] = {{0}}; DArray *keys = DArray_create(0, NUM_KEYS); mu_assert(gen_keys(keys, NUM_KEYS) == 0, \"Failed to generate random keys.\"); fill_distribution(stats[ALGO_FNV1A], keys, Hashmap_fnv1a_hash); fill_distribution(stats[ALGO_ADLER32], keys, Hashmap_adler32_hash); fill_distribution(stats[ALGO_DJB], keys, Hashmap_djb_hash); fprintf(stderr, \"FNV\\tA32\\tDJB\\n\"); for(i = 0; i \u003c BUCKETS; i++) { fprintf(stderr, \"%d\\t%d\\t%d\\n\", stats[ALGO_FNV1A][i], stats[ALGO_ADLER32][i], stats[ALGO_DJB][i]); } destroy_keys(keys); return NULL; } char *all_tests() { mu_suite_start(); mu_run_test(test_fnv1a); mu_run_test(test_adler32); mu_run_test(test_djb); mu_run_test(test_distribution); return NULL; } RUN_TESTS(all_tests); 我在代码中将BUCKETS的值设置得非常高，因为我的电脑足够快。如果你将它和NUM_KEYS调低，就会比较慢了。这个测试运行之后，对于每个哈希函数，通过使用R语言做统计分析，可以观察键的分布情况。\n我实现它的方式是使用gen_keys函数生成键的大型列表。这些键从/dev/urandom设备中获得，它们是一些随机的字节。之后我使用了这些键来调用fill_distribution，填充了stats 数组，这些键计算哈希值后会被放入理论上的一些桶中。所有这类函数会遍历所有键，计算哈希，之后执行类似Hashmap所做的事情来寻找正确的桶。\n最后我只是简单打印出一个三列的表格，包含每个桶的最终数量，展示了每个桶中随机储存了多少个键。之后可以观察这些数值，来判断这些哈希函数是否合理对键进行分配。\n你会看到什么 link教授R是这本书范围之外的内容，但是如果你想试试它，可以访问r-project.org。\n下面是一个简略的shell会话，向你展示了我如何运行1tests/hashmap_algos_test来获取test_distribution产生的表（这里没有展示），之后使用R来观察统计结果：\n$ tests/hashmap_algos_tests $ vim hash.txt $ R \u003e hash \u003c- read.table(\"hash.txt\", header=T) \u003e summary(hash) FNV A32 DJB Min. : 945 Min. : 908.0 Min. : 927 1st Qu.: 980 1st Qu.: 980.8 1st Qu.: 979 Median : 998 Median :1000.0 Median : 998 Mean :1000 Mean :1000.0 Mean :1000 3rd Qu.:1016 3rd Qu.:1019.2 3rd Qu.:1021 Max. :1072 Max. :1075.0 Max. :1082 首先我只是运行测试，它会在屏幕上打印表格。之后我将它复制粘贴到下来并使用vim hash.txt来储存数据。如果你观察数据，它会带有显示这三个算法的FNV A32 DJB表头。\n接着，我运行R来使用read.table命令加载数据集。它是个非常智能的函数，适用于这种tab分隔的数据，我只要告诉它header=T，它就知道数据集中带有表头。\n最后，我家在了数据并且可以使用summary来打印出它每行的统计结果。这里你可以看到每个函数处理随机数据实际上都没有问题。我会解释每个行的意义：\nMin.\n它是列出数据的最小值。FNV似乎在这方面是最优的，因为它有最大的结果，也就是说它的下界最严格。\n1st Qu.\n数据的第一个四分位点。\nMedian\n如果你对它们排序，这个数值就是最重点的那个数。中位数比起均值来讲更有用一些。\nMean\n均值对大多数人意味着“平均”，它是数据的总数比数量。如果你观察它们，所有均值都是1000，这非常棒。如果你将它去中位数对比，你会发现，这三个中位数都很接近均值。这就意味着这些数据都没有“偏向”一端，所以均值是可信的。\n3rd Qu.\n数据后四分之一的起始点，代表了尾部的数值。\nMax.\n这是数据中的最大值，代表了它们的上界。\n观察这些数据，你会发现这些哈希算法似乎都适用于随机的键，并且均值与我设置的NUM_KEYS匹配。我所要找的就是如果我为每个桶中生成了1000个键，那么平均每个桶中就应该有100个键。如果哈希函数工作不正常，你会发现统计结果中均值不是1000，并且第一个和第三个四分位点非常高。一个好的哈希算法应该使平均值为1000，并且具有严格的范围。\n同时，你应该明白即使在这个单元测试的不同运行之间，你的数据的大多数应该和我不同。\n如何使它崩溃 link这个练习的最后，我打算向你介绍使它崩溃的方法。我需要让你变写你能编写的最烂的哈希函数，并且我会使用数据来证明它确实很烂。你可以使用R来进行统计，就像我上面一样，但也可能你知道其他可以使用的工具来进行相同的统计操作。\n这里的目标是让一个哈希函数，它表面看起来是正常的，但实际运行就得到一个糟糕的均值，并且分布广泛。这意味着你不能只让你返回1，而是需要返回一些看似正常的数值，但是分布广泛并且都填充到相同的桶中。\n如果你对这四个函数之一做了一些小修改来完成任务，我会给你额外的分数。\n这个练习的目的是，想像一下一些“友好”的程序员见到你并且打算改进你的哈希函数，但是实际上只是留了个把你的Hashmap搞砸的后门。\n附加题 link 将hashmap.c中的default_hash换成hashmap_algos.c中的算法之一，并且再次通过所有测试。 向hashmap_algos_tests.c添加default_hash，并将它与其它三个哈希函数比较。 寻找一些更多的哈希函数并添加进来，你永远都不可能找到太多的哈希函数！ "
            }
        );
    index.add(
            {
                id:  49 ,
                href: "\/TechDocs\/docs\/c-guide\/ex39\/",
                title: "练习39：字符串算法",
                description: "原文：Exercise 39: String Algorithms 译者：飞龙 这个练习中，我会向你展示可能是最快的字符串搜索算法之一，并且将它与bstrlib.c中现有的binstr比较。binstr的文档说它仅仅使用了“暴力搜索”的字符串算法来寻找第一个实例。我所实现的函数使用Boyer-Moore-Horspool（BMH）算法，如果你分析理论时间的话，一般认为它会更快。你也会看到，如果我的实现没有任何缺陷，BMH的实际时间会比binstr简单的暴力搜索更糟。 这个练习的要点并不是真正解释算法本身，因为你可以直接去Boyer-Moore-Horspool 的维基百科页面去阅读它。这个算法的要点就是它会计算出“跳跃字符列表”作为第一步操作，之后它使用这个列表来快速扫描整个字符串。它应当比暴力搜索更快，所以让我们在文件里写出代码来看看吧。 首先，创建头文件： #ifndef string_algos_h #define string_algos_h #include #include typedef struct StringScanner { bstring in; const unsigned char *haystack; ssize_t hlen; const unsigned char *needle; ssize_t nlen; size_t skip_chars[UCHAR_MAX + 1]; } StringScanner; int String_find(bstring in, bstring what); StringScanner *StringScanner_create(bstring in); int StringScanner_scan(StringScanner *scan, bstring tofind); void StringScanner_destroy(StringScanner *scan); #endif 为了观察“跳跃字符列表”的效果，我打算创建这个算法的两种版本： String_find 只是在一个字符串中，寻找另一个字符串的首个实例，以一个动作执行整个算法。 StringScanner_scan 使用StringScanner状态结构，将跳跃列表的构建和实际的查找操作分开。这让我能看到什么影响了性能。这个模型有另一个优点，就是我可以在一个字符串中逐步搜索，并且快速地找到所有实例。 一旦你完成了头文件，下面就是实现了： #include #include static inline void String_setup_skip_chars( size_t *skip_chars, const unsigned char *needle, ssize_t nlen) { size_t i = 0; size_t last = nlen - 1; for(i = 0; i \u003c UCHAR_MAX + 1; i++) { skip_chars[i] = nlen; } for (i = 0; i \u003c last; i++) { skip_chars[needle[i]] = last - i; } } static inline const unsigned char *String_base_search( const unsigned char *haystack, ssize_t hlen, const unsigned char *needle, ssize_t nlen, size_t *skip_chars) { size_t i = 0; size_t last = nlen - 1; assert(haystack !",
                content: " 原文：Exercise 39: String Algorithms\n译者：飞龙\n这个练习中，我会向你展示可能是最快的字符串搜索算法之一，并且将它与bstrlib.c中现有的binstr比较。binstr的文档说它仅仅使用了“暴力搜索”的字符串算法来寻找第一个实例。我所实现的函数使用Boyer-Moore-Horspool（BMH）算法，如果你分析理论时间的话，一般认为它会更快。你也会看到，如果我的实现没有任何缺陷，BMH的实际时间会比binstr简单的暴力搜索更糟。\n这个练习的要点并不是真正解释算法本身，因为你可以直接去Boyer-Moore-Horspool 的维基百科页面去阅读它。这个算法的要点就是它会计算出“跳跃字符列表”作为第一步操作，之后它使用这个列表来快速扫描整个字符串。它应当比暴力搜索更快，所以让我们在文件里写出代码来看看吧。\n首先，创建头文件：\n#ifndef string_algos_h #define string_algos_h #include #include typedef struct StringScanner { bstring in; const unsigned char *haystack; ssize_t hlen; const unsigned char *needle; ssize_t nlen; size_t skip_chars[UCHAR_MAX + 1]; } StringScanner; int String_find(bstring in, bstring what); StringScanner *StringScanner_create(bstring in); int StringScanner_scan(StringScanner *scan, bstring tofind); void StringScanner_destroy(StringScanner *scan); #endif 为了观察“跳跃字符列表”的效果，我打算创建这个算法的两种版本：\nString_find\n只是在一个字符串中，寻找另一个字符串的首个实例，以一个动作执行整个算法。\nStringScanner_scan\n使用StringScanner状态结构，将跳跃列表的构建和实际的查找操作分开。这让我能看到什么影响了性能。这个模型有另一个优点，就是我可以在一个字符串中逐步搜索，并且快速地找到所有实例。\n一旦你完成了头文件，下面就是实现了：\n#include #include static inline void String_setup_skip_chars( size_t *skip_chars, const unsigned char *needle, ssize_t nlen) { size_t i = 0; size_t last = nlen - 1; for(i = 0; i \u003c UCHAR_MAX + 1; i++) { skip_chars[i] = nlen; } for (i = 0; i \u003c last; i++) { skip_chars[needle[i]] = last - i; } } static inline const unsigned char *String_base_search( const unsigned char *haystack, ssize_t hlen, const unsigned char *needle, ssize_t nlen, size_t *skip_chars) { size_t i = 0; size_t last = nlen - 1; assert(haystack != NULL \u0026\u0026 \"Given bad haystack to search.\"); assert(needle != NULL \u0026\u0026 \"Given bad needle to search for.\"); check(nlen \u003e 0, \"nlen can't be \u003c= 0\"); check(hlen \u003e 0, \"hlen can't be \u003c= 0\"); while (hlen \u003e= nlen) { for (i = last; haystack[i] == needle[i]; i--) { if (i == 0) { return haystack; } } hlen -= skip_chars[haystack[last]]; haystack += skip_chars[haystack[last]]; } error: // fallthrough return NULL; } int String_find(bstring in, bstring what) { const unsigned char *found = NULL; const unsigned char *haystack = (const unsigned char *)bdata(in); ssize_t hlen = blength(in); const unsigned char *needle = (const unsigned char *)bdata(what); ssize_t nlen = blength(what); size_t skip_chars[UCHAR_MAX + 1] = {0}; String_setup_skip_chars(skip_chars, needle, nlen); found = String_base_search(haystack, hlen, needle, nlen, skip_chars); return found != NULL ? found - haystack : -1; } StringScanner *StringScanner_create(bstring in) { StringScanner *scan = calloc(1, sizeof(StringScanner)); check_mem(scan); scan-\u003ein = in; scan-\u003ehaystack = (const unsigned char *)bdata(in); scan-\u003ehlen = blength(in); assert(scan != NULL \u0026\u0026 \"fuck\"); return scan; error: free(scan); return NULL; } static inline void StringScanner_set_needle(StringScanner *scan, bstring tofind) { scan-\u003eneedle = (const unsigned char *)bdata(tofind); scan-\u003enlen = blength(tofind); String_setup_skip_chars(scan-\u003eskip_chars, scan-\u003eneedle, scan-\u003enlen); } static inline void StringScanner_reset(StringScanner *scan) { scan-\u003ehaystack = (const unsigned char *)bdata(scan-\u003ein); scan-\u003ehlen = blength(scan-\u003ein); } int StringScanner_scan(StringScanner *scan, bstring tofind) { const unsigned char *found = NULL; ssize_t found_at = 0; if(scan-\u003ehlen \u003c= 0) { StringScanner_reset(scan); return -1; } if((const unsigned char *)bdata(tofind) != scan-\u003eneedle) { StringScanner_set_needle(scan, tofind); } found = String_base_search( scan-\u003ehaystack, scan-\u003ehlen, scan-\u003eneedle, scan-\u003enlen, scan-\u003eskip_chars); if(found) { found_at = found - (const unsigned char *)bdata(scan-\u003ein); scan-\u003ehaystack = found + scan-\u003enlen; scan-\u003ehlen -= found_at - scan-\u003enlen; } else { // done, reset the setup StringScanner_reset(scan); found_at = -1; } return found_at; } void StringScanner_destroy(StringScanner *scan) { if(scan) { free(scan); } } 整个算法都在两个static inline的函数中，叫做String_setup_skip_chars 和 String_base_search。它们在别的函数中使用，用于实现我想要的的搜索形式。研究这两个函数，并且与维基百科的描述对比，你就可以知道它的工作原理。\n之后String_find使用这两个函数来寻找并返回所发现的位置。它非常简单并且我使用它来查看“跳跃字符列表”的构建如何影响到真实性能。要注意，你或许可以使它更快，但是我要教给你在你实现算法之后如何验证理论速度。\nStringScanner_scan函数随后按照“创建、扫描、销毁”的常用模式，并且用于在一个字符串中逐步搜索另一个字符串。当我向你展示单元测试的时候，你会看到它如何使用。\n最后，我编写了单元测试来确保算法有效，之后在它的注释部分，我为三个搜索函数运行了简单的性能测试：\n#include \"minunit.h\" #include #include #include struct tagbstring IN_STR = bsStatic(\"I have ALPHA beta ALPHA and oranges ALPHA\"); struct tagbstring ALPHA = bsStatic(\"ALPHA\"); const int TEST_TIME = 1; char *test_find_and_scan() { StringScanner *scan = StringScanner_create(\u0026IN_STR); mu_assert(scan != NULL, \"Failed to make the scanner.\"); int find_i = String_find(\u0026IN_STR, \u0026ALPHA); mu_assert(find_i \u003e 0, \"Failed to find 'ALPHA' in test string.\"); int scan_i = StringScanner_scan(scan, \u0026ALPHA); mu_assert(scan_i \u003e 0, \"Failed to find 'ALPHA' with scan.\"); mu_assert(scan_i == find_i, \"find and scan don't match\"); scan_i = StringScanner_scan(scan, \u0026ALPHA); mu_assert(scan_i \u003e find_i, \"should find another ALPHA after the first\"); scan_i = StringScanner_scan(scan, \u0026ALPHA); mu_assert(scan_i \u003e find_i, \"should find another ALPHA after the first\"); mu_assert(StringScanner_scan(scan, \u0026ALPHA) == -1, \"shouldn't find it\"); StringScanner_destroy(scan); return NULL; } char *test_binstr_performance() { int i = 0; int found_at = 0; unsigned long find_count = 0; time_t elapsed = 0; time_t start = time(NULL); do { for(i = 0; i \u003c 1000; i++) { found_at = binstr(\u0026IN_STR, 0, \u0026ALPHA); mu_assert(found_at != BSTR_ERR, \"Failed to find!\"); find_count++; } elapsed = time(NULL) - start; } while(elapsed \u003c= TEST_TIME); debug(\"BINSTR COUNT: %lu, END TIME: %d, OPS: %f\", find_count, (int)elapsed, (double)find_count / elapsed); return NULL; } char *test_find_performance() { int i = 0; int found_at = 0; unsigned long find_count = 0; time_t elapsed = 0; time_t start = time(NULL); do { for(i = 0; i \u003c 1000; i++) { found_at = String_find(\u0026IN_STR, \u0026ALPHA); find_count++; } elapsed = time(NULL) - start; } while(elapsed \u003c= TEST_TIME); debug(\"FIND COUNT: %lu, END TIME: %d, OPS: %f\", find_count, (int)elapsed, (double)find_count / elapsed); return NULL; } char *test_scan_performance() { int i = 0; int found_at = 0; unsigned long find_count = 0; time_t elapsed = 0; StringScanner *scan = StringScanner_create(\u0026IN_STR); time_t start = time(NULL); do { for(i = 0; i \u003c 1000; i++) { found_at = 0; do { found_at = StringScanner_scan(scan, \u0026ALPHA); find_count++; } while(found_at != -1); } elapsed = time(NULL) - start; } while(elapsed \u003c= TEST_TIME); debug(\"SCAN COUNT: %lu, END TIME: %d, OPS: %f\", find_count, (int)elapsed, (double)find_count / elapsed); StringScanner_destroy(scan); return NULL; } char *all_tests() { mu_suite_start(); mu_run_test(test_find_and_scan); // this is an idiom for commenting out sections of code #if 0 mu_run_test(test_scan_performance); mu_run_test(test_find_performance); mu_run_test(test_binstr_performance); #endif return NULL; } RUN_TESTS(all_tests); 我把它们写在#if 0中间，它是使用C预处理器来注释一段代码的方法。像这样输入，并且把它和#endif移除，你就可以运行性能测试。当你继续这本书时，需要简单地把它们再次注释，以防它们浪费你的开发时间。\n这个单元测试没有什么神奇之处，它只是在尊换种调用每个不同的函数，循环需要持续足够长的时间来得到一个几秒的样本。第一个测试（test_find_and_scan）只是确保我所编写的代码正常工作，因为测试无效的代码没有意义。之后，下面的三个函数使用三个函数中的每一个来执行大量的搜索。\n需要注意的一个技巧是，我在start中存储了起始时间，之后一直循环到至少过了TEST_TIME秒。这确保了我能或得到足够好的样本用于比较三者。我之后会使用不同的TEST_TIME设置来运行测试，并且分析结果。\n你会看到什么 link当我在我的笔记本上运行测试时，我得到的数据是这样的：\n$ ./tests/string_algos_tests DEBUG tests/string_algos_tests.c:124: ----- RUNNING: ./tests/string_algos_tests ---- RUNNING: ./tests/string_algos_tests DEBUG tests/string_algos_tests.c:116: ----- test_find_and_scan DEBUG tests/string_algos_tests.c:117: ----- test_scan_performance DEBUG tests/string_algos_tests.c:105: SCAN COUNT: 110272000, END TIME: 2, OPS: 55136000.000000 DEBUG tests/string_algos_tests.c:118: ----- test_find_performance DEBUG tests/string_algos_tests.c:76: FIND COUNT: 12710000, END TIME: 2, OPS: 6355000.000000 DEBUG tests/string_algos_tests.c:119: ----- test_binstr_performance DEBUG tests/string_algos_tests.c:54: BINSTR COUNT: 72736000, END TIME: 2, OPS: 36368000.000000 ALL TESTS PASSED Tests run: 4 $ 我看到了它，觉得每轮运行应该超过两秒。并且，我打算多次运行它，并且像之前一样使用R来验证。下面是我获得的10个样例，每个基本上是10秒：\nscan find binstr 71195200 6353700 37110200 75098000 6358400 37420800 74910000 6351300 37263600 74859600 6586100 37133200 73345600 6365200 37549700 74754400 6358000 37162400 75343600 6630400 37075000 73804800 6439900 36858700 74995200 6384300 36811700 74781200 6449500 37383000 我在shell的一点点帮助下获取数据，之后编辑输出：\n$ for i in 1 2 3 4 5 6 7 8 9 10; do echo \"RUN --- $i\" \u003e\u003e times.log; ./tests/string_algos_tests 2\u003e\u00261 | grep COUNT \u003e\u003e times.log ; done $ less times.log $ vim times.log 现在你可以看到scan系统要优于另外两个，但是我会在R中打开它并且验证结果：\n\u003e times \u003c- read.table(\"times.log\", header=T) \u003e summary(times) scan find binstr Min. :71195200 Min. :6351300 Min. :36811700 1st Qu.:74042200 1st Qu.:6358100 1st Qu.:37083800 Median :74820400 Median :6374750 Median :37147800 Mean :74308760 Mean :6427680 Mean :37176830 3rd Qu.:74973900 3rd Qu.:6447100 3rd Qu.:37353150 Max. :75343600 Max. :6630400 Max. :37549700 \u003e 为了理解我为什么要生成这份概要统计，我必须对你解释一些统计学概念。我在这些数字中寻找的东西能够简单地告诉我，“这三个函数（scan、find、binstr）实际上不同吗？”我知道每次我运行测试函数的时候，我都会得到有些不同的数值，并且那些数值始终处理一个固定的范围。你可以看到两个四分位数反映了这一点。\n我首先会去看均值，并且我会观察每个样例的均值是否不同于其它的。我可以清楚地看到scan优于binstr，同时后者优于find。然而问题来了，如果我只使用均值，就可以出现每个样例的范围会重叠的可能性。\n如果均值不同，但是两个四分位点重叠会怎么用？这种情况下我只能说有这种可能性，并且如果我再次运行测试，均值就可能不同了。很可能出现的范围上的重叠是，我的两个样例（以及两个函数）并非实际上不同。任何我看到的差异都是随机产生的结果。\n统计学拥有大量工具来解决这一问题，但是在我们的例子中我可以仅仅观察两个四分位值，以及所有样例的均值。如果均值不同，并且四分位值不可能重叠，就可以说它们完全不同。\n在我的三个样例中，我可以说scan、find和binstr都是不同的，范围上没有重叠，并且（最重要的是）我可以相信数据。\n分析结果 link从结果中可以看出String_find比其它两个更慢。实际上，我认为慢的原因是我实现的方式有些问题。然而当我将它与StringScanner_scan比较时，我发现正是构造跳跃列表的那一部分最消耗时间。并且它的功能比scan要少，因为它仅仅找到了第一个位置，而scan找到了全部。\n我也可以发现scan以很大优势优于binstr。同时我可以说scan的功能比其他两个要多，速度也更快。\n下面是这个分析的一些注解：\n我可能将实现或测试弄乱了。现在我打算研究所有实现BMH的可能方式来改进它。我也会确保我所做的事情正确。 如果你修改了测试运行的时间，你会得到不同的结果。这就是我没有考虑的”热身“环节。 test_scan_performance单元测试和其它两个并不相同，但是它比其它测试做得更多（并且也是按照时间和操作数量计算的），所以他可能是合理的。 我只通过在一个字符串内搜索另一个来执行测试。我应该使所查找的字符串随机化，来移除它们的位置和长度，作为干扰因素。 binstr的实现可能比“暴力搜索”要好。（所以应该自己编写暴力搜索作为对照。） 我可能以不幸的顺序来执行这些函数，并且随机化首先运行的测试可能会得到更好的结果。 可以从中学到的是，你需要确保知己的性能，即使你“正确”实现了一个算法。在这里BMH算法应该优于binstr算法，但是一个简单的测试证明了它是错误。如果我没有这些测试，我可能就使用了一个劣等的算法实现而不自知。参照这些度量，我可以开始调优我的实现，或者只是抛弃它并寻找新的算法。\n附加题 link 看看你能不能使Scan_find更快。为什么我的实现这么慢？ 尝试一些不同的搜索时长，看看你是否能得到不同的数值。当你改变scan的测试时间时，时间的长度会有什么影响？对于这些结果你能得出什么结论？ 修改单元测试，使它最开始执行每个函数一小段时间，来消除任何“热身”缓解。这样会修改所运行时长的依赖性吗？每秒可能出现多少次操作？ 使单元测试中的所查找字符串随机化，之后测量你的得到的性能。一种实现它的方式就是使用bstrlib.h中的bsplit函数在空格处分割IN_STR。之后使用你得到的strList结构访问它返回的每个字符串。这也教给你如何使用bstrList操作进行字符串处理。 尝试一些不同顺序的测试，看看能否得到不同的结果。 "
            }
        );
    index.add(
            {
                id:  50 ,
                href: "\/TechDocs\/docs\/c-guide\/ex40\/",
                title: "练习40：二叉搜索树",
                description: "原文：Exercise 40: Binary Search Trees\n译者：飞龙\n二叉树是最简单的树形数据结构，虽然它在许多语言中被哈希表取代，但仍旧对于一些应用很实用。二叉树的各种变体可用于一些非常实用东西，比如数据库的索引、搜索算法结构、以及图像处理。\n我把我的二叉树叫做BSTree，描述它的最佳方法就是它是另一种Hashmap形式的键值对储存容器。它们的差异在于，哈希表为键计算哈希值来寻找位置，而二叉树将键与树中的节点进行对比，之后深入树中找到储存它的最佳位置，基于它与其它节点的关系。\n在我真正解释它的工作原理之前，让我向你展示bstree.h头文件，便于你看到数据结构，之后我会用它来解释如何构建。\n#ifndef _lcthw_BSTree_h #define _lcthw_BSTree_h typedef int (*BSTree_compare)(void *a, void *b); typedef struct BSTreeNode { void *key; void *data; struct BSTreeNode *left; struct BSTreeNode *right; struct BSTreeNode *parent; } BSTreeNode; typedef struct BSTree { int count; BSTree_compare compare; BSTreeNode *root; } BSTree; typedef int (*BSTree_traverse_cb)(BSTreeNode *node); BSTree *BSTree_create(BSTree_compare compare); void BSTree_destroy(BSTree *map); int BSTree_set(BSTree *map, void *key, void *data); void *BSTree_get(BSTree *map, void *key); int BSTree_traverse(BSTree *map, BSTree_traverse_cb traverse_cb); void *BSTree_delete(BSTree *map, void *key); #endif 这遵循了我之前用过的相同模式，我创建了一个基容器叫做BSTree，它含有叫做BSTreeNode的节点，组成实际内容。厌倦了吗？是的，这种结构也没有什么高明之处。",
                content: " 原文：Exercise 40: Binary Search Trees\n译者：飞龙\n二叉树是最简单的树形数据结构，虽然它在许多语言中被哈希表取代，但仍旧对于一些应用很实用。二叉树的各种变体可用于一些非常实用东西，比如数据库的索引、搜索算法结构、以及图像处理。\n我把我的二叉树叫做BSTree，描述它的最佳方法就是它是另一种Hashmap形式的键值对储存容器。它们的差异在于，哈希表为键计算哈希值来寻找位置，而二叉树将键与树中的节点进行对比，之后深入树中找到储存它的最佳位置，基于它与其它节点的关系。\n在我真正解释它的工作原理之前，让我向你展示bstree.h头文件，便于你看到数据结构，之后我会用它来解释如何构建。\n#ifndef _lcthw_BSTree_h #define _lcthw_BSTree_h typedef int (*BSTree_compare)(void *a, void *b); typedef struct BSTreeNode { void *key; void *data; struct BSTreeNode *left; struct BSTreeNode *right; struct BSTreeNode *parent; } BSTreeNode; typedef struct BSTree { int count; BSTree_compare compare; BSTreeNode *root; } BSTree; typedef int (*BSTree_traverse_cb)(BSTreeNode *node); BSTree *BSTree_create(BSTree_compare compare); void BSTree_destroy(BSTree *map); int BSTree_set(BSTree *map, void *key, void *data); void *BSTree_get(BSTree *map, void *key); int BSTree_traverse(BSTree *map, BSTree_traverse_cb traverse_cb); void *BSTree_delete(BSTree *map, void *key); #endif 这遵循了我之前用过的相同模式，我创建了一个基容器叫做BSTree，它含有叫做BSTreeNode的节点，组成实际内容。厌倦了吗？是的，这种结构也没有什么高明之处。\n最重要的部分是，BSTreeNode如何配置，以及它如何用于进行每个操作：设置、获取和删除。我会首先讲解get，因为它是最简单的操作，并且我会在数据结构上手动操作：\n我获得你要找的键，并且用根节点开始遍历，首先我将你的键与这个节点的键进行对比。 如果你的键小于node.key，我使用left指针来详细遍历。 如果你的键大于node.key，我使用right指针来详细遍历。 重复第二步和第三部，知道我找到了匹配node.key的节点，或者我遍历到了没有左子树或右子树的节点。这种情况我会返回node.data，其它情况会返回NULL。 这就是get的全部操作，现在是set，它几乎执行相同的操作，除了你在寻找防止新节点的位置。\n如果BSTree.root为空，就算是执行完成了。它就是第一个节点。 之后我会将你的键与node.key进行比对，从根节点开始。 如果你的键小于或等于node.key，我会遍历左子树，否则是右子树。 重复第三步，直到我到达了没有左子树或右子树的节点，但是这是我需要选择的方向。 我选择了这个方向（左或者右）来放置新的节点，并且将这个新节点的父节点设为我来时的上一个节点。当我删除它时，我会使用它的父节点。 这也解释了它如何工作。如果寻找一个节点涉及到按照键的对比来遍历左子树或右子树，那么设置一个节点涉及到相同的事情，直到我找到了一个位置，可以在其左子树或右子树上放置新的节点。\n花一些时间在纸上画出一些树并且遍历一些节点来进行查找或设置，你就可以理解它如何工作。之后你要准备好来看一看实现，我在其中解释了删除操作。删除一个节点非常麻烦，因此它最适合逐行的代码分解。\n#include #include #include #include static int default_compare(void *a, void *b) { return bstrcmp((bstring)a, (bstring)b); } BSTree *BSTree_create(BSTree_compare compare) { BSTree *map = calloc(1, sizeof(BSTree)); check_mem(map); map-\u003ecompare = compare == NULL ? default_compare : compare; return map; error: if(map) { BSTree_destroy(map); } return NULL; } static int BSTree_destroy_cb(BSTreeNode *node) { free(node); return 0; } void BSTree_destroy(BSTree *map) { if(map) { BSTree_traverse(map, BSTree_destroy_cb); free(map); } } static inline BSTreeNode *BSTreeNode_create(BSTreeNode *parent, void *key, void *data) { BSTreeNode *node = calloc(1, sizeof(BSTreeNode)); check_mem(node); node-\u003ekey = key; node-\u003edata = data; node-\u003eparent = parent; return node; error: return NULL; } static inline void BSTree_setnode(BSTree *map, BSTreeNode *node, void *key, void *data) { int cmp = map-\u003ecompare(node-\u003ekey, key); if(cmp \u003c= 0) { if(node-\u003eleft) { BSTree_setnode(map, node-\u003eleft, key, data); } else { node-\u003eleft = BSTreeNode_create(node, key, data); } } else { if(node-\u003eright) { BSTree_setnode(map, node-\u003eright, key, data); } else { node-\u003eright = BSTreeNode_create(node, key, data); } } } int BSTree_set(BSTree *map, void *key, void *data) { if(map-\u003eroot == NULL) { // first so just make it and get out map-\u003eroot = BSTreeNode_create(NULL, key, data); check_mem(map-\u003eroot); } else { BSTree_setnode(map, map-\u003eroot, key, data); } return 0; error: return -1; } static inline BSTreeNode *BSTree_getnode(BSTree *map, BSTreeNode *node, void *key) { int cmp = map-\u003ecompare(node-\u003ekey, key); if(cmp == 0) { return node; } else if(cmp \u003c 0) { if(node-\u003eleft) { return BSTree_getnode(map, node-\u003eleft, key); } else { return NULL; } } else { if(node-\u003eright) { return BSTree_getnode(map, node-\u003eright, key); } else { return NULL; } } } void *BSTree_get(BSTree *map, void *key) { if(map-\u003eroot == NULL) { return NULL; } else { BSTreeNode *node = BSTree_getnode(map, map-\u003eroot, key); return node == NULL ? NULL : node-\u003edata; } } static inline int BSTree_traverse_nodes(BSTreeNode *node, BSTree_traverse_cb traverse_cb) { int rc = 0; if(node-\u003eleft) { rc = BSTree_traverse_nodes(node-\u003eleft, traverse_cb); if(rc != 0) return rc; } if(node-\u003eright) { rc = BSTree_traverse_nodes(node-\u003eright, traverse_cb); if(rc != 0) return rc; } return traverse_cb(node); } int BSTree_traverse(BSTree *map, BSTree_traverse_cb traverse_cb) { if(map-\u003eroot) { return BSTree_traverse_nodes(map-\u003eroot, traverse_cb); } return 0; } static inline BSTreeNode *BSTree_find_min(BSTreeNode *node) { while(node-\u003eleft) { node = node-\u003eleft; } return node; } static inline void BSTree_replace_node_in_parent(BSTree *map, BSTreeNode *node, BSTreeNode *new_value) { if(node-\u003eparent) { if(node == node-\u003eparent-\u003eleft) { node-\u003eparent-\u003eleft = new_value; } else { node-\u003eparent-\u003eright = new_value; } } else { // this is the root so gotta change it map-\u003eroot = new_value; } if(new_value) { new_value-\u003eparent = node-\u003eparent; } } static inline void BSTree_swap(BSTreeNode *a, BSTreeNode *b) { void *temp = NULL; temp = b-\u003ekey; b-\u003ekey = a-\u003ekey; a-\u003ekey = temp; temp = b-\u003edata; b-\u003edata = a-\u003edata; a-\u003edata = temp; } static inline BSTreeNode *BSTree_node_delete(BSTree *map, BSTreeNode *node, void *key) { int cmp = map-\u003ecompare(node-\u003ekey, key); if(cmp \u003c 0) { if(node-\u003eleft) { return BSTree_node_delete(map, node-\u003eleft, key); } else { // not found return NULL; } } else if(cmp \u003e 0) { if(node-\u003eright) { return BSTree_node_delete(map, node-\u003eright, key); } else { // not found return NULL; } } else { if(node-\u003eleft \u0026\u0026 node-\u003eright) { // swap this node for the smallest node that is bigger than us BSTreeNode *successor = BSTree_find_min(node-\u003eright); BSTree_swap(successor, node); // this leaves the old successor with possibly a right child // so replace it with that right child BSTree_replace_node_in_parent(map, successor, successor-\u003eright); // finally it's swapped, so return successor instead of node return successor; } else if(node-\u003eleft) { BSTree_replace_node_in_parent(map, node, node-\u003eleft); } else if(node-\u003eright) { BSTree_replace_node_in_parent(map, node, node-\u003eright); } else { BSTree_replace_node_in_parent(map, node, NULL); } return node; } } void *BSTree_delete(BSTree *map, void *key) { void *data = NULL; if(map-\u003eroot) { BSTreeNode *node = BSTree_node_delete(map, map-\u003eroot, key); if(node) { data = node-\u003edata; free(node); } } return data; } 在讲解BSTree_delete如何工作之前，我打算解释一下我用于执行递归函数的模式。你会发现许多树形数据结构都易于使用递归来编写，而写成单个函数的形式相当困难。一部分原因在于你需要为第一次操作建立一些初始的数据，之后在数据结构中递归，这难以写成一个函数。\n解决办法就是使用两个函数。一个函数“建立”数据结构和首次递归的条件使第二层函数能够执行真正的逻辑。首先看一看BSTree_get来理解我所说的。\n我设置了初始条件来处理递归，如果map-\u003eNULL是NULL，那么就返回NULL并且不需要递归。 之后我执行了真正的递归调用，它就是BSTree_getnode。我设置了根节点的初始条件、key和map。 之后在BSTree_getnode中，我执行了真正的递归逻辑，我将是用map-\u003ecompare(node-\u003ekey, key)来进行键的比对，并且根据结果遍历左子树或右子树，或者相等。 由于这个函数时“自相似”的，并且不用处理任何初始条件（因为BSTree_get处理了），我就可以使它非常简单。当它完成时会返回给调用者，最后把结构返回给BSTree_get。 最后，在结果不为NULL的情况下，BSTree_get处理获得的node.data元素。 这种构造递归算法的方法，与我构造递归数据结构的方法一致。我创建了一个起始的“基函数”，它处理初始条件和一些边界情况，之后它调用了一个简洁的递归函数来执行任务。与之相比，我在BStree中创建了“基结构”，它持有递归的BSTreeNode结构，每个节点都引用树中的其它节点。使用这种模式让我更容易处理递归并保持简洁。\n接下来，浏览BSTree_set 和 BSTree_setnode，来观察相同的模式。我使用BSTree_set来确保初始条件和便捷情况。常见的边界情况就是树中没有根节点，于是我需要创建一个函数来初始化它们。\n这个模式适用于几乎任何递归的算法。我按照这种模式来编写它们：\n理解初始变量，它们如何改变，以及递归每一步的终止条件。 编写调用自身的递归函数，带有参数作为终止条件和初始变量。 编程一个启动函数来设置算法的初始条件，并且处理边界情况，之后调用递归函数。 最后，启动函数返回最后的结果，并且如果递归函数不能处理最终的边界情况可能还要做调整。 这引导了我完成BSTree_delete和BSTree_node_delete。首先你可以看一下BSTree_delete和它的启动函数，它获取结果节点的数据，并且释放找到的节点。在BSTree_node_delete中事情就变得复杂了，因为要在树中任意位置删除一个节点，我需要将子节点翻转上来。我会逐行拆分这个函数：\nbstree.c:190\n我执行比较函数来找出应该选择的方向。\nbstree.c:192-198\n这是“小于”的分支，我应该移到左子树。这里左子树并不存在并且返回了NULL来表示“未找到”。这处理了一些不在BSTree中元素的删除操作。\nbstree.c:199-205\n和上面相同，但是是对于树的右侧分支。这就像其它函数一样只是在树中向下遍历，并且在不存在时返回NULL。\nbstree.c:206\n这里是发现目标节点的地方，因为键是相等的（compare返回了0）。\nbstree.c:207\n这个节点同时具有left和right分支，所以它深深嵌入在树中。\nbstree.c:209\n要移除这个节点，我首先要找到大于这个节点的最小节点，这里我在右子树上调用了BSTree_find_min。\nbstree.c:210\n一旦我获得了这个几点，我将它的key和data与当前节点互换。这样就高效地将当前节点移动到树的最底端，并且不同通过它的指针来调整节点。\nbstree.c:214\n现在successor是一个无效的分支，储存了当前节点的值。然而它可能还带有右子树，也就是说我必须做一个旋转使它的右节点上来代替它。\nbstree.c:217\n到此为止，successor已经从树中移出了，它的值被当前节点的值代替，它的任何子树都合并进了它的父节点。我可以像node一样返回它。\nbstree.c:218\n这个分支中，我了解到这个节点没有右子树只有左子树，所以我可以简单地用左节点来替代它。\nbstree.c:219\n我再次使用BSTree_replace_node_in_parent来执行替换，把左节点旋转上去。\nbstree.c:220\n这是只有右子树而没有左子树的情况，所以需要将右节点旋转上去。\nbstree.c:221\n再次使用相同的函数，这次是针对右节点。\nbstree.c:222\n最后，对于我发现的节点只剩下一种情况，就是它没有任何子树（没有做子树也没有右子树）。这种情况，我只需要使用相同函数以NULL来执行替换。\nbstree.c:210\n在此之后，我已经将当前节点从书中移除，并且以某个合适的子节点的元素来替换。我只需要把它返回给调用者，使它能够被释放或管理。\n这个操作非常复杂，实话说，在一些树形数据结构中，我并不需要执行删除，而是把它当做软件中的常亮数据。如果我需要做繁杂的插入和删除工作，我会使用Hashmap。\n最后，你可以查看它的单元测试以及测试方法：\n#include \"minunit.h\" #include #include #include #include #include BSTree *map = NULL; static int traverse_called = 0; struct tagbstring test1 = bsStatic(\"test data 1\"); struct tagbstring test2 = bsStatic(\"test data 2\"); struct tagbstring test3 = bsStatic(\"xest data 3\"); struct tagbstring expect1 = bsStatic(\"THE VALUE 1\"); struct tagbstring expect2 = bsStatic(\"THE VALUE 2\"); struct tagbstring expect3 = bsStatic(\"THE VALUE 3\"); static int traverse_good_cb(BSTreeNode *node) { debug(\"KEY: %s\", bdata((bstring)node-\u003ekey)); traverse_called++; return 0; } static int traverse_fail_cb(BSTreeNode *node) { debug(\"KEY: %s\", bdata((bstring)node-\u003ekey)); traverse_called++; if(traverse_called == 2) { return 1; } else { return 0; } } char *test_create() { map = BSTree_create(NULL); mu_assert(map != NULL, \"Failed to create map.\"); return NULL; } char *test_destroy() { BSTree_destroy(map); return NULL; } char *test_get_set() { int rc = BSTree_set(map, \u0026test1, \u0026expect1); mu_assert(rc == 0, \"Failed to set \u0026test1\"); bstring result = BSTree_get(map, \u0026test1); mu_assert(result == \u0026expect1, \"Wrong value for test1.\"); rc = BSTree_set(map, \u0026test2, \u0026expect2); mu_assert(rc == 0, \"Failed to set test2\"); result = BSTree_get(map, \u0026test2); mu_assert(result == \u0026expect2, \"Wrong value for test2.\"); rc = BSTree_set(map, \u0026test3, \u0026expect3); mu_assert(rc == 0, \"Failed to set test3\"); result = BSTree_get(map, \u0026test3); mu_assert(result == \u0026expect3, \"Wrong value for test3.\"); return NULL; } char *test_traverse() { int rc = BSTree_traverse(map, traverse_good_cb); mu_assert(rc == 0, \"Failed to traverse.\"); mu_assert(traverse_called == 3, \"Wrong count traverse.\"); traverse_called = 0; rc = BSTree_traverse(map, traverse_fail_cb); mu_assert(rc == 1, \"Failed to traverse.\"); mu_assert(traverse_called == 2, \"Wrong count traverse for fail.\"); return NULL; } char *test_delete() { bstring deleted = (bstring)BSTree_delete(map, \u0026test1); mu_assert(deleted != NULL, \"Got NULL on delete.\"); mu_assert(deleted == \u0026expect1, \"Should get test1\"); bstring result = BSTree_get(map, \u0026test1); mu_assert(result == NULL, \"Should delete.\"); deleted = (bstring)BSTree_delete(map, \u0026test1); mu_assert(deleted == NULL, \"Should get NULL on delete\"); deleted = (bstring)BSTree_delete(map, \u0026test2); mu_assert(deleted != NULL, \"Got NULL on delete.\"); mu_assert(deleted == \u0026expect2, \"Should get test2\"); result = BSTree_get(map, \u0026test2); mu_assert(result == NULL, \"Should delete.\"); deleted = (bstring)BSTree_delete(map, \u0026test3); mu_assert(deleted != NULL, \"Got NULL on delete.\"); mu_assert(deleted == \u0026expect3, \"Should get test3\"); result = BSTree_get(map, \u0026test3); mu_assert(result == NULL, \"Should delete.\"); // test deleting non-existent stuff deleted = (bstring)BSTree_delete(map, \u0026test3); mu_assert(deleted == NULL, \"Should get NULL\"); return NULL; } char *test_fuzzing() { BSTree *store = BSTree_create(NULL); int i = 0; int j = 0; bstring numbers[100] = {NULL}; bstring data[100] = {NULL}; srand((unsigned int)time(NULL)); for(i = 0; i \u003c 100; i++) { int num = rand(); numbers[i] = bformat(\"%d\", num); data[i] = bformat(\"data %d\", num); BSTree_set(store, numbers[i], data[i]); } for(i = 0; i \u003c 100; i++) { bstring value = BSTree_delete(store, numbers[i]); mu_assert(value == data[i], \"Failed to delete the right number.\"); mu_assert(BSTree_delete(store, numbers[i]) == NULL, \"Should get nothing.\"); for(j = i+1; j \u003c 99 - i; j++) { bstring value = BSTree_get(store, numbers[j]); mu_assert(value == data[j], \"Failed to get the right number.\"); } bdestroy(value); bdestroy(numbers[i]); } BSTree_destroy(store); return NULL; } char *all_tests() { mu_suite_start(); mu_run_test(test_create); mu_run_test(test_get_set); mu_run_test(test_traverse); mu_run_test(test_delete); mu_run_test(test_destroy); mu_run_test(test_fuzzing); return NULL; } RUN_TESTS(all_tests); 我要重点讲解test_fuzzing函数，它是针对复杂数据结构的一种有趣的测试技巧。创建一些键来覆盖BSTree_node_delete的所有分支相当困难，而且有可能我会错过一些边界情况。更好的方法就是创建一个“模糊测试”的函数来执行所有操作，并尽可能以一种可怕且随机的方式执行它们。这里我插入了一系列随机字符串的键，之后我删除了它们并试着在删除之后获取它们的值。\n这种测试可以避免只测试到你知道能正常工作的部分，这意味着你不会遗漏不知道的事情。通过想你的数据结构插入一些随机的垃圾数据，你可以碰到意料之外的事情，并检测出任何bug。\n如何改进 link不要完成下列任何习题，因为在下个练习中我会使用这里的单元测试，来教你使用一些性能调优的技巧。在你完成练习41之后，你需要返回来完成这些习题。\n像之前一样，你应该执行所有防御性编程检查，并且为不应发生的情况添加assert。例如，你不应该在递归函数中获取到NULL，为此添加断言。 遍历函数按照左子树、右子树和当前节点的顺组进行遍历。你可以创建相反顺序的遍历函数。 每个节点上都会执行完整的字符串比较，但是我可以使用Hashmap的哈希函数来提升速度。我可以计算键的哈希值，在BSTreeNode中储存它。之后在每个创建的函数中，我可以实现计算出键的哈希值，然后在递归中向下传递。我可以使用哈希来很快地比较每个节点，就像Hashmap那样。 附加题 link同样，现在先不要完成它们，直到完成练习41，那时你就可以使用Valgrind的性能调优技巧来完成它们了。\n有一种不使用递归的替代的方法，也可以操作这个数据结构。维基百科上介绍了不使用递归来完成相同事情的替代方法。这样做会更好还是更糟？ 查询你能找到的所有不同的树的相关资料。比如AVL树、红黑树、以及一些非树形结构例如跳转表。 "
            }
        );
    index.add(
            {
                id:  51 ,
                href: "\/TechDocs\/docs\/c-guide\/ex41\/",
                title: "练习41：将 Cachegrind 和 Callgrind 用于性能调优",
                description: "原文：Exercise 41: Using Cachegrind And Callgrind For Performance Tuning\n译者：飞龙\n这个练习中，我打算上一节速成课，内容是使用Valgrind的两个工具callgrind和cachegrind。这两个工具会分析你程序的执行，并且告诉你哪一部分运行缓慢。这些结果非常精确，因为Valgrind的工作方式有助于你解决一些问题，比如执行过多的代码行，热点，内容访问问题，甚至是CPU的缓存未命中。\n为了做这个练习，我打算使用bstree_tests单元测试，你之前用于寻找能提升算法的地方。你需要确保你这些程序的版本没有任何valgrind错误，并且和我的代码非常相似，因为我会使用我的代码的转储来谈论cachegrind和callgrind如何工作。\n运行 Callgrind link为了运行Callgrind，你需要向valgrind传入--tool=callgrind选项，之后它会产生callgrind.out.PID文件（其中PID为所运行程序的进程PID）。一旦你这样运行了，你就可以使用一个叫做callgrind_annotate的工具分析callgrind.out文件，它会告诉你哪个函数运行中使用了最多的指令。下面是个例子，我在bstree_tests上运行了callgrind，之后得到了这个信息：\n$ valgrind --dsymutil=yes --tool=callgrind tests/bstree_tests ... $ callgrind_annotate callgrind.out.1232 -------------------------------------------------------------------------------- Profile data file 'callgrind.out.1232' (creator: callgrind-3.7.0.SVN) -------------------------------------------------------------------------------- I1 cache: D1 cache: LL cache: Timerange: Basic block 0 - 1098689 Trigger: Program termination Profiled target: tests/bstree_tests (PID 1232, part 1) Events recorded: Ir Events shown: Ir Event sort order: Ir Thresholds: 99 Include dirs: User annotated: Auto-annotation: off -------------------------------------------------------------------------------- Ir -------------------------------------------------------------------------------- 4,605,808 PROGRAM TOTALS -------------------------------------------------------------------------------- Ir file:function -------------------------------------------------------------------------------- 670,486 src/lcthw/bstrlib.",
                content: " 原文：Exercise 41: Using Cachegrind And Callgrind For Performance Tuning\n译者：飞龙\n这个练习中，我打算上一节速成课，内容是使用Valgrind的两个工具callgrind和cachegrind。这两个工具会分析你程序的执行，并且告诉你哪一部分运行缓慢。这些结果非常精确，因为Valgrind的工作方式有助于你解决一些问题，比如执行过多的代码行，热点，内容访问问题，甚至是CPU的缓存未命中。\n为了做这个练习，我打算使用bstree_tests单元测试，你之前用于寻找能提升算法的地方。你需要确保你这些程序的版本没有任何valgrind错误，并且和我的代码非常相似，因为我会使用我的代码的转储来谈论cachegrind和callgrind如何工作。\n运行 Callgrind link为了运行Callgrind，你需要向valgrind传入--tool=callgrind选项，之后它会产生callgrind.out.PID文件（其中PID为所运行程序的进程PID）。一旦你这样运行了，你就可以使用一个叫做callgrind_annotate的工具分析callgrind.out文件，它会告诉你哪个函数运行中使用了最多的指令。下面是个例子，我在bstree_tests上运行了callgrind，之后得到了这个信息：\n$ valgrind --dsymutil=yes --tool=callgrind tests/bstree_tests ... $ callgrind_annotate callgrind.out.1232 -------------------------------------------------------------------------------- Profile data file 'callgrind.out.1232' (creator: callgrind-3.7.0.SVN) -------------------------------------------------------------------------------- I1 cache: D1 cache: LL cache: Timerange: Basic block 0 - 1098689 Trigger: Program termination Profiled target: tests/bstree_tests (PID 1232, part 1) Events recorded: Ir Events shown: Ir Event sort order: Ir Thresholds: 99 Include dirs: User annotated: Auto-annotation: off -------------------------------------------------------------------------------- Ir -------------------------------------------------------------------------------- 4,605,808 PROGRAM TOTALS -------------------------------------------------------------------------------- Ir file:function -------------------------------------------------------------------------------- 670,486 src/lcthw/bstrlib.c:bstrcmp [tests/bstree_tests] 194,377 src/lcthw/bstree.c:BSTree_get [tests/bstree_tests] 65,580 src/lcthw/bstree.c:default_compare [tests/bstree_tests] 16,338 src/lcthw/bstree.c:BSTree_delete [tests/bstree_tests] 13,000 src/lcthw/bstrlib.c:bformat [tests/bstree_tests] 11,000 src/lcthw/bstrlib.c:bfromcstralloc [tests/bstree_tests] 7,774 src/lcthw/bstree.c:BSTree_set [tests/bstree_tests] 5,800 src/lcthw/bstrlib.c:bdestroy [tests/bstree_tests] 2,323 src/lcthw/bstree.c:BSTreeNode_create [tests/bstree_tests] 1,183 /private/tmp/pkg-build/coregrind//vg_preloaded.c:vg_cleanup_env [/usr/local/lib/valgrind/vgpreload_core-amd64-darwin.so] $ 我已经移除了单元测试和valgrind输出，因为它们对这个练习没有用。你应该看到了callgrind_anotate输出，它向你展示了每个函数所运行的指令数量（valgrind中叫做Ir），由高到低排序。你通常可以忽略头文件的数据，直接跳到函数列表。\n注\n如果你获取到一堆“???:Image”的行，并且它们不是你程序中的东西，那么你读到的是OS的垃圾。只需要在末尾添加| grep -v \"???\"来过滤掉它们。\n我现在可以对这个输出做个简短的分解，来找出下一步观察什么：\n每一行都列出了Ir序号和执行它们的file:function 。Ir是指令数量，并且如果它越少就越快。这里有些复杂，但是首先要着眼于Ir。 解决这个程序的方式是观察最上面的函数，之后看看你首先可以改进哪一个。这里，我可以改进bstrcmp或者BStree_get。可能以BStree_get开始更容易些。 这些函数的一部分由单元测试调用，所以我可以忽略它们。类似bformat，bfromcstralloc和 bdestroy就是这样的函数。 我也可以找到我可以简单地避免调用的函数。例如，或许我可以假设BSTree仅仅处理bstring键，之后我可以不使用回调系统，并且完全移除default_compare。 到目前为止，我只知道我打算改进BSTree_get，并且不是因为BSTree_get执行慢。这是分析的第二阶段。\nCallgrind 注解源文件 link下一步我使用callgrind_annotate输出bstree.c文件，并且使用所带有的Ir对每一行做注解。你可以通过运行下面的命令来得到注解后的源文件：\n$ callgrind_annotate callgrind.out.1232 src/lcthw/bstree.c ... 你的输出会是这个源文件的一个较大的转储，但是我会将它们剪切成包含BSTree_get和BSTree_getnode的部分：\n-------------------------------------------------------------------------------- -- User-annotated source: src/lcthw/bstree.c -------------------------------------------------------------------------------- Ir 2,453 static inline BSTreeNode *BSTree_getnode(BSTree *map, BSTreeNode *node, void *key) . { 61,853 int cmp = map-\u003ecompare(node-\u003ekey, key); 663,908 =\u003e src/lcthw/bstree.c:default_compare (14850x) . 14,850 if(cmp == 0) { . return node; 24,794 } else if(cmp \u003c 0) { 30,623 if(node-\u003eleft) { . return BSTree_getnode(map, node-\u003eleft, key); . } else { . return NULL; . } . } else { 13,146 if(node-\u003eright) { . return BSTree_getnode(map, node-\u003eright, key); . } else { . return NULL; . } . } . } . . void *BSTree_get(BSTree *map, void *key) 4,912 { 24,557 if(map-\u003eroot == NULL) { 14,736 return NULL; . } else { . BSTreeNode *node = BSTree_getnode(map, map-\u003eroot, key); 2,453 return node == NULL ? NULL : node-\u003edata; . } . } 每一行都显示它的Ir（指令）数量，或者一个点（.）来表示它并不重要。我所要找的就是一些热点，或者带有巨大数值的Ir的行，它能够被优化掉。这里，第十行的输出表明，BSTree_getnode开销非常大的原因是它调用了default_comapre，它又调用了bstrcmp。我已经知道了bstrcmp是性能最差的函数，所以如果我想要改进BSTree_getnode的速度，我应该首先解决掉它。\n之后我以相同方式查看bstrcmp：\n98,370 int bstrcmp (const_bstring b0, const_bstring b1) { . int i, v, n; . 196,740 if (b0 == NULL || b1 == NULL || b0-\u003edata == NULL || b1-\u003edata == NULL || 32,790 b0-\u003eslen \u003c 0 || b1-\u003eslen \u003c 0) return SHRT_MIN; 65,580 n = b0-\u003eslen; if (n \u003e b1-\u003eslen) n = b1-\u003eslen; 89,449 if (b0-\u003eslen == b1-\u003eslen \u0026\u0026 (b0-\u003edata == b1-\u003edata || b0-\u003eslen == 0)) . return BSTR_OK; . 23,915 for (i = 0; i \u003c n; i ++) { 163,642 v = ((char) b0-\u003edata[i]) - ((char) b1-\u003edata[i]); . if (v != 0) return v; . if (b0-\u003edata[i] == (unsigned char) '\\0') return BSTR_OK; . } . . if (b0-\u003eslen \u003e n) return 1; . if (b1-\u003eslen \u003e n) return -1; . return BSTR_OK; . } 输出中让我预料之外的事情就是bstrcmp最糟糕的一行并不是我想象中的字符比较。对于内存访问，顶部的防御性if语句将所有可能的无效变量都检查了一遍。与第十七行比较字符的语句相比，这个if语句进行了多于两倍的内存访问。如果我要优化bstcmp，我会完全把它去掉，或者在其它一些地方来执行它。\n另一种选择是将这个检查改为assert，它只在开发时的运行中存在，之后在发布时把它去掉。我没有足够的证明来表明这行代码不适于这个数据结构，所以我可以证明移除它是可行的。\n然而，我并不想弱化这个函数的防御性，来得到一些性能。在真实的性能优化环境，我会简单地把它放到列表中，之后挖掘程序中能得到的其它收益。\n调优之道 link 我们应该忽略微小的效率，对于97%的情况：过早优化是万恶之源。\n– 高德纳\n在我看来，这个引述似乎忽略了一个关于性能调优的重点。在高德纳的话中，当你做性能调优时，如果你过早去做它，可能会导致各种问题。根据他的话，优化应该执行于“稍晚的某个时间”，或者这只是我的猜测。谁知道呢。\n我打算澄清这个引述并不是完全错误，而是忽略了某些东西，并且我打算给出我的引述。你可以引用我的这段话：\n使用证据来寻找最大的优化并花费最少的精力。\n– 泽德 A. 肖\n你什么时候优化并不重要，但是你需要弄清楚你的优化是否真正能改进软件，以及需要投入多少精力来实现它。通过证据你就可以找到代码中的位置，用一点点精力就能取得最大的提升。通常这些地方都是一些愚蠢的决定，就像bstrcmp试图检查任何东西不为NULL一样。\n在某个特定时间点上，代码中需要调优的地方只剩下极其微小的优化，比如重新组织if语句，或者类似达夫设备这样的特殊循环。这时候，你应该停止优化，因为这是一个好机会，你可以通过重新设计软件并且避免这些事情来获得更多收益。\n这是一些只想做优化的程序员没有看到的事情。许多时候，把一件事情做快的最好方法就是寻找避免它们的办法。在上面的分析中，我不打算优化bstrcmp，我会寻找一个不使用它的方法。也许我可以使用一种哈希算法来执行可排序的哈希计算而不是始终使用bstrcmp。也许我可以通过首先尝试第一个字符，如果它们不匹配就没必要调用bstrcmp。\n如果在此之后你根本不能重新设计，那么就开始寻找微小的优化，但是要始终确保它们能够提升速度。要记住目标是使用最少的精力尽可能得到最大的效果。\n使用 KCachegrind link这个练习最后一部分就是向你介绍一个叫做KCachegrind的神奇的GUI工具，用于分析callgrind 和 cachegrind的输出。我使用Linux或BSD电脑上工作时几乎都会使用它，并且我实际上为了使用KCachegrind而切换到Linux来编写代码。\n教会你如何使用是这个练习之外的内容，你需要在这个练习之后自己学习如何用它。输出几乎是相同的，除了KCachegrind可以让你做这些：\n图形化地浏览源码和执行次数，并使用各种排序来搜索可优化的东西。 分析不同的图表，来可视化地观察什么占据了大多数时间，以及它调用了什么。 查看真实的汇编机器码输出，使你能够看到实际的指令，给你更多的线索。 可视化地显示源码中的循环和分支的跳跃方式，便于你更容易地找到优化代码的方法。 你应该在获取、安装和玩转KCachegrind上花一些时间。\n附加题 link 阅读 callgrind 手册页并且尝试一些高级选项。 阅读 cachegrind 手册页并且也尝试一些高级选项。 在所有单元测试上使用callgrind 和 cachegrind，看看你能否找到可优化的地方。你找到一些预料之外的事情了吗？如果没有，你可能观察地不够仔细。 使用 KCachegrind 并且观察它和我这里的输出有什么不同。 现在使用这些工具来完成练习40的附加题和改进部分。 "
            }
        );
    index.add(
            {
                id:  52 ,
                href: "\/TechDocs\/docs\/c-guide\/ex42\/",
                title: "练习42：栈和队列",
                description: "原文：Exercise 42: Stacks and Queues 译者：飞龙 到现在为止，你已经知道了大多数用于构建其它数据结构的数据结构。如果你拥有一些List、DArray、Hashmap 和 Tree，你就能用他们构造出大多数其它的任何结构。你碰到的其它任何结构要么可以用它们实现，要么是它们的变体。如果不是的话，它可能是外来的数据结构，你可能不需要它。 Stack和Queue是非常简单的数据结构，它们是List的变体。它们是List的弱化或者转换形式，因为你只需要在List的一端放置元素。对于Stack，你只能能够在一段压入和弹出元素。而对于Queue，你只能够在开头压入元素，并在末尾弹出（或者反过来）。 我能够只通过C预处理器和两个头文件来实现这两个数据结构。我的头文件只有21行的长度，并且实现了所有Stack和Queue的操作，不带有任何神奇的定义。 我将会向你展示单元测试，你需要实现头文件来让它们正常工作。你不能创建stack.c 或 queue.c实现文件来通过测试，只能使用stack.h 和 queue.h来使测试运行。 #include \"minunit.h\" #include #include static Stack *stack = NULL; char *tests[] = {\"test1 data\", \"test2 data\", \"test3 data\"}; #define NUM_TESTS 3 char *test_create() { stack = Stack_create(); mu_assert(stack != NULL, \"Failed to create stack.\"); return NULL; } char *test_destroy() { mu_assert(stack != NULL, \"Failed to make stack #2\"); Stack_destroy(stack); return NULL; } char *test_push_pop() { int i = 0; for(i = 0; i \u003c NUM_TESTS; i++) { Stack_push(stack, tests[i]); mu_assert(Stack_peek(stack) == tests[i], \"Wrong next value.",
                content: " 原文：Exercise 42: Stacks and Queues\n译者：飞龙\n到现在为止，你已经知道了大多数用于构建其它数据结构的数据结构。如果你拥有一些List、DArray、Hashmap 和 Tree，你就能用他们构造出大多数其它的任何结构。你碰到的其它任何结构要么可以用它们实现，要么是它们的变体。如果不是的话，它可能是外来的数据结构，你可能不需要它。\nStack和Queue是非常简单的数据结构，它们是List的变体。它们是List的弱化或者转换形式，因为你只需要在List的一端放置元素。对于Stack，你只能能够在一段压入和弹出元素。而对于Queue，你只能够在开头压入元素，并在末尾弹出（或者反过来）。\n我能够只通过C预处理器和两个头文件来实现这两个数据结构。我的头文件只有21行的长度，并且实现了所有Stack和Queue的操作，不带有任何神奇的定义。\n我将会向你展示单元测试，你需要实现头文件来让它们正常工作。你不能创建stack.c 或 queue.c实现文件来通过测试，只能使用stack.h 和 queue.h来使测试运行。\n#include \"minunit.h\" #include #include static Stack *stack = NULL; char *tests[] = {\"test1 data\", \"test2 data\", \"test3 data\"}; #define NUM_TESTS 3 char *test_create() { stack = Stack_create(); mu_assert(stack != NULL, \"Failed to create stack.\"); return NULL; } char *test_destroy() { mu_assert(stack != NULL, \"Failed to make stack #2\"); Stack_destroy(stack); return NULL; } char *test_push_pop() { int i = 0; for(i = 0; i \u003c NUM_TESTS; i++) { Stack_push(stack, tests[i]); mu_assert(Stack_peek(stack) == tests[i], \"Wrong next value.\"); } mu_assert(Stack_count(stack) == NUM_TESTS, \"Wrong count on push.\"); STACK_FOREACH(stack, cur) { debug(\"VAL: %s\", (char *)cur-\u003evalue); } for(i = NUM_TESTS - 1; i \u003e= 0; i--) { char *val = Stack_pop(stack); mu_assert(val == tests[i], \"Wrong value on pop.\"); } mu_assert(Stack_count(stack) == 0, \"Wrong count after pop.\"); return NULL; } char *all_tests() { mu_suite_start(); mu_run_test(test_create); mu_run_test(test_push_pop); mu_run_test(test_destroy); return NULL; } RUN_TESTS(all_tests); 之后是queue_tests.c，几乎以相同的方式来使用Queue：\n#include \"minunit.h\" #include #include static Queue *queue = NULL; char *tests[] = {\"test1 data\", \"test2 data\", \"test3 data\"}; #define NUM_TESTS 3 char *test_create() { queue = Queue_create(); mu_assert(queue != NULL, \"Failed to create queue.\"); return NULL; } char *test_destroy() { mu_assert(queue != NULL, \"Failed to make queue #2\"); Queue_destroy(queue); return NULL; } char *test_send_recv() { int i = 0; for(i = 0; i \u003c NUM_TESTS; i++) { Queue_send(queue, tests[i]); mu_assert(Queue_peek(queue) == tests[0], \"Wrong next value.\"); } mu_assert(Queue_count(queue) == NUM_TESTS, \"Wrong count on send.\"); QUEUE_FOREACH(queue, cur) { debug(\"VAL: %s\", (char *)cur-\u003evalue); } for(i = 0; i \u003c NUM_TESTS; i++) { char *val = Queue_recv(queue); mu_assert(val == tests[i], \"Wrong value on recv.\"); } mu_assert(Queue_count(queue) == 0, \"Wrong count after recv.\"); return NULL; } char *all_tests() { mu_suite_start(); mu_run_test(test_create); mu_run_test(test_send_recv); mu_run_test(test_destroy); return NULL; } RUN_TESTS(all_tests); 你应该在不修改测试文件的条件下，使单元测试能够运行，并且它应该能够通过valgrind而没有任何内存错误。下面是当我直接运行stack_tests时它的样子：\n$ ./tests/stack_tests DEBUG tests/stack_tests.c:60: ----- RUNNING: ./tests/stack_tests ---- RUNNING: ./tests/stack_tests DEBUG tests/stack_tests.c:53: ----- test_create DEBUG tests/stack_tests.c:54: ----- test_push_pop DEBUG tests/stack_tests.c:37: VAL: test3 data DEBUG tests/stack_tests.c:37: VAL: test2 data DEBUG tests/stack_tests.c:37: VAL: test1 data DEBUG tests/stack_tests.c:55: ----- test_destroy ALL TESTS PASSED Tests run: 3 $ queue_test的输出基本一样，所以我在这里就不展示了。\n如何改进 link你可以做到的唯一真正的改进，就是把所用的List换成DArray。Queue数据结构难以用DArray实现，因为它要同时处理两端的节点。\n完全在头文件中来实现它们的缺点，是你并不能够轻易地对它做性能调优。你需要使用这种技巧，建立一种以特定的方式使用List的“协议”。做性能调优时，如果你优化了List，这两种数据结构都会有所改进。\n附加题 link 使用DArray代替List实现Stack，并保持单元测试不变。这意味着你需要创建你自己的STACK_FOREACH。 "
            }
        );
    index.add(
            {
                id:  53 ,
                href: "\/TechDocs\/docs\/c-guide\/ex43\/",
                title: "练习43：一个简单的统计引擎",
                description: "原文：Exercise 43: A Simple Statistics Engine 译者：飞龙 这是一个简单的算法，我将其用于“联机”（不储存任何样本）收集概要统计。我在任何需要执行一些统计，比如均值、标准差和求和中使用它，但是其中我并不会储存所需的全部样本。我只需要储存计算出的结果，它们仅仅含有5个数值。 计算标准差和均值 link首先你需要一系列样本。它可以使任何事情，比如完成一个任务所需的时间，某人访问某个东西的次数，或者甚至是网站的评分。是什么并不重要，只要你能得到一些数字，并且你想要知道它们的下列概要统计值： sum 对所有数字求和。 sumsq（平方和） 对所有数字求平方和。 count(n) 求出样本数量。 min 求出样本最小值。 max 求出样本最大值。 mean 求出样本的均值。它类似于但又不是中位数，但可作为中位数的估计。 stddev 使用$sqrt(sumsq - (sum * mean) / (n - 1) )来计算标准差，其中sqrt为math.h头文件中的平方根。 我将会使用R来验证这些计算，因为我知道R能够计算正确。 \u003e s \u003c- runif(n=10, max=10) \u003e s [1] 6.1061334 9.6783204 1.2747090 8.2395131 0.3333483 6.9755066 1.0626275 [8] 7.6587523 4.9382973 9.5788115 \u003e summary(s) Min. 1st Qu. Median Mean 3rd Qu. Max. 0.3333 2.1910 6.5410 5.5850 8.0940 9.6780 \u003e sd(s) [1] 3.",
                content: " 原文：Exercise 43: A Simple Statistics Engine\n译者：飞龙\n这是一个简单的算法，我将其用于“联机”（不储存任何样本）收集概要统计。我在任何需要执行一些统计，比如均值、标准差和求和中使用它，但是其中我并不会储存所需的全部样本。我只需要储存计算出的结果，它们仅仅含有5个数值。\n计算标准差和均值 link首先你需要一系列样本。它可以使任何事情，比如完成一个任务所需的时间，某人访问某个东西的次数，或者甚至是网站的评分。是什么并不重要，只要你能得到一些数字，并且你想要知道它们的下列概要统计值：\nsum\n对所有数字求和。\nsumsq（平方和）\n对所有数字求平方和。\ncount(n)\n求出样本数量。\nmin\n求出样本最小值。\nmax\n求出样本最大值。\nmean\n求出样本的均值。它类似于但又不是中位数，但可作为中位数的估计。\nstddev\n使用$sqrt(sumsq - (sum * mean) / (n - 1) )来计算标准差，其中sqrt为math.h头文件中的平方根。\n我将会使用R来验证这些计算，因为我知道R能够计算正确。\n\u003e s \u003c- runif(n=10, max=10) \u003e s [1] 6.1061334 9.6783204 1.2747090 8.2395131 0.3333483 6.9755066 1.0626275 [8] 7.6587523 4.9382973 9.5788115 \u003e summary(s) Min. 1st Qu. Median Mean 3rd Qu. Max. 0.3333 2.1910 6.5410 5.5850 8.0940 9.6780 \u003e sd(s) [1] 3.547868 \u003e sum(s) [1] 55.84602 \u003e sum(s * s) [1] 425.1641 \u003e sum(s) * mean(s) [1] 311.8778 \u003e sum(s * s) - sum(s) * mean(s) [1] 113.2863 \u003e (sum(s * s) - sum(s) * mean(s)) / (length(s) - 1) [1] 12.58737 \u003e sqrt((sum(s * s) - sum(s) * mean(s)) / (length(s) - 1)) [1] 3.547868 \u003e 你并不需要懂得R，只需要看着我拆分代码来解释如何检查这些运算：\nlines 1-4\n我使用runit函数来获得“随机形式”的数字分布，之后将它们打印出来。我会在接下来的单元测试中用到它。\nlines 5-7\n这个就是概要，便于你看到R如何计算它们。\nlines 8-9\n这是使用sd函数计算的stddev。\nlines 10-11\n现在我开始手动进行这一计算，首先计算sum。\nlines 12-13\nstddev公式中的下一部分是sumsq，我可以通过sum(s * s)来得到，它告诉R将整个s列表乘以其自身，之后计算它们的sum。R的可以在整个数据结构上做运算，就像这样。\nlines 14-15\n观察那个公式，我之后需要sum乘上mean，所以我执行了sum(s) * mean(s)。\nlines 16-17\n我接着将sumsq参与运算，得到sum(s * s) - sum(s) * mean(s)。\nlines 18-19\n还需要除以n - 1，所以我执行了(sum(s * s) - sum(s) * mean(s)) / (length(s) - 1)。\nlines 20-21\n随后，我使用sqrt算出平方根，并得到3.547868，它符合R通过sd的运算结果。\n实现 link这就是计算stddev的方法，现在我可以编写一些简单的代码来实现这一计算。\n#ifndef lcthw_stats_h #define lctwh_stats_h typedef struct Stats { double sum; double sumsq; unsigned long n; double min; double max; } Stats; Stats *Stats_recreate(double sum, double sumsq, unsigned long n, double min, double max); Stats *Stats_create(); double Stats_mean(Stats *st); double Stats_stddev(Stats *st); void Stats_sample(Stats *st, double s); void Stats_dump(Stats *st); #endif 这里你可以看到我将所需的统计量放入一个struct，并且创建了用于处理样本和获得数值的函数。实现它只是转换数字的一个练习：\n#include #include #include #include Stats *Stats_recreate(double sum, double sumsq, unsigned long n, double min, double max) { Stats *st = malloc(sizeof(Stats)); check_mem(st); st-\u003esum = sum; st-\u003esumsq = sumsq; st-\u003en = n; st-\u003emin = min; st-\u003emax = max; return st; error: return NULL; } Stats *Stats_create() { return Stats_recreate(0.0, 0.0, 0L, 0.0, 0.0); } double Stats_mean(Stats *st) { return st-\u003esum / st-\u003en; } double Stats_stddev(Stats *st) { return sqrt( (st-\u003esumsq - ( st-\u003esum * st-\u003esum / st-\u003en)) / (st-\u003en - 1) ); } void Stats_sample(Stats *st, double s) { st-\u003esum += s; st-\u003esumsq += s * s; if(st-\u003en == 0) { st-\u003emin = s; st-\u003emax = s; } else { if(st-\u003emin \u003e s) st-\u003emin = s; if(st-\u003emax \u003c s) st-\u003emax = s; } st-\u003en += 1; } void Stats_dump(Stats *st) { fprintf(stderr, \"sum: %f, sumsq: %f, n: %ld, min: %f, max: %f, mean: %f, stddev: %f\", st-\u003esum, st-\u003esumsq, st-\u003en, st-\u003emin, st-\u003emax, Stats_mean(st), Stats_stddev(st)); } 下面是 stats.c中每个函数的作用：\nStats_recreate\n我希望从一些数据中加载这些数据，这和函数让我重新创建Stats结构体。\nStats_create\n只是以全0的值调用Stats_recreate。\nStats_mean\n使用sum和n计算均值。\nStats_stddev\n实现我之前的公式，唯一的不同就是我使用t-\u003esum / st-\u003en来计算均值，而不是调用Stats_mean。\nStats_sample\n它用于在Stats结构体中储存数值。当你向它提供数值时，它看到n是0，并且相应地设置min和max。之后的每次调用都会使sum、sumsq和n增加，并且计算出这一新的样本的min和max值。\nStats_dump\n简单的调试函数，用于转储统计量，便于你看到它们。\n我需要干的最后一件事，就是确保这些运算正确。我打算使用我的样本，以及来自于R会话中的计算结果创建单元测试，来确保我会得到正确的结果。\n#include \"minunit.h\" #include #include const int NUM_SAMPLES = 10; double samples[] = { 6.1061334, 9.6783204, 1.2747090, 8.2395131, 0.3333483, 6.9755066, 1.0626275, 7.6587523, 4.9382973, 9.5788115 }; Stats expect = { .sumsq = 425.1641, .sum = 55.84602, .min = 0.333, .max = 9.678, .n = 10, }; double expect_mean = 5.584602; double expect_stddev = 3.547868; #define EQ(X,Y,N) (round((X) * pow(10, N)) == round((Y) * pow(10, N))) char *test_operations() { int i = 0; Stats *st = Stats_create(); mu_assert(st != NULL, \"Failed to create stats.\"); for(i = 0; i \u003c NUM_SAMPLES; i++) { Stats_sample(st, samples[i]); } Stats_dump(st); mu_assert(EQ(st-\u003esumsq, expect.sumsq, 3), \"sumsq not valid\"); mu_assert(EQ(st-\u003esum, expect.sum, 3), \"sum not valid\"); mu_assert(EQ(st-\u003emin, expect.min, 3), \"min not valid\"); mu_assert(EQ(st-\u003emax, expect.max, 3), \"max not valid\"); mu_assert(EQ(st-\u003en, expect.n, 3), \"max not valid\"); mu_assert(EQ(expect_mean, Stats_mean(st), 3), \"mean not valid\"); mu_assert(EQ(expect_stddev, Stats_stddev(st), 3), \"stddev not valid\"); return NULL; } char *test_recreate() { Stats *st = Stats_recreate(expect.sum, expect.sumsq, expect.n, expect.min, expect.max); mu_assert(st-\u003esum == expect.sum, \"sum not equal\"); mu_assert(st-\u003esumsq == expect.sumsq, \"sumsq not equal\"); mu_assert(st-\u003en == expect.n, \"n not equal\"); mu_assert(st-\u003emin == expect.min, \"min not equal\"); mu_assert(st-\u003emax == expect.max, \"max not equal\"); mu_assert(EQ(expect_mean, Stats_mean(st), 3), \"mean not valid\"); mu_assert(EQ(expect_stddev, Stats_stddev(st), 3), \"stddev not valid\"); return NULL; } char *all_tests() { mu_suite_start(); mu_run_test(test_operations); mu_run_test(test_recreate); return NULL; } RUN_TESTS(all_tests); 这个单元测试中没什么新东西，除了EQ宏。我比较懒，并且不想查询比较两个double值的标准方法，所以我使用了这个宏。double的问题是等性不是完全相等，因为我使用了两个不同的系统，并带有不同的四舍五入的位数。解决方案就是判断两个数“乘以10的X次方是否相等”。\n我使用EQ来计算数字的10的幂，之后使用round函数来获得证书。这是个简单的方法来四舍五入N位小数，并以整数比较结果。我确定有数以亿计的其它方法能做相同的事情，但是现在我就用这种。\n预期结果储存在Stats struct中，之后我只是确保我得到的数值接近R给我的数值。\n如何使用 link你可以使用标准差和均值来决定一个新的样本是否是“有趣”的，或者你可以使用它们计算统计量的统计量。前者对于人们来说更容易理解，所以我用登录的例子来做个简短的解释。\n假设你在跟踪人们花费多长时间在一台服务器上，并且你打算用统计来分析它。每次有人登录进来，你都对它们在这里的时长保持跟踪，之后调用Stats_sample函数。我会寻找停留“过长”时间的人，以及“过短”的人。\n比起设定特殊的级别，我更倾向于将一个人的停留时间与mean (plus or minus) 2 * stddev这个范围进行比较。我计算出mean和2 * stddev，并且如果它们在这个范围之外，我就认为是“有趣”的。由于我使用了联机算法来维护这些统计量，所以它非常快，并且我可以使软件标记在这个范围外的用户。\n这不仅仅用于找出行为异常的用户，更有助于标记一些潜在的问题，你可以查看它们来观察发生了什么。它基于所有用户的行为来计算，这也避免了你任意挑出一个数值而并不基于实际情况的问题。\n你可以从中学到的通用规则是，mean (plus or minus) 2 * stddev是90%的值预期所属的范围预测值，任何在它之外的值都是有趣的。\n第二种利用这些统计量的方式就是继续将其用于其它的Stats计算。基本上像通常一样使用Stats_sample，但是之后在min、max、n、mean和stddev上执行Stats_sample。这会提供二级的度量，并且让你对比样本的样本。\n被搞晕了吗？我会以上面的例子基础，并且假设你拥有100台服务器，每台都运行一个应用。你已经在每个应用服务器上跟踪了用户的登录时长，但是你想要比较所有的这100和应用，并且标记它们当中任何登录时间过长的用户。最简单的方式就是每次有人登录进来时，计算新的登录统计量，之后将Stats structs的元素添加到第二个Stats中。\n你最后应该会得到一些统计量，它们可以这样命名：\n均值的均值\n这是一个Stats struct，它向你提供所有服务器的均值的mean和stddev。你可以用全局视角来观察任何在此之外的用户或服务器。\n标准差的均值\n另一个Stats struct，计算这些服务器的分布的统计量。你之后可以分析每个服务器并且观察是否它们中的任何服务器具有异常分散的分布，通过将它们的stddev和这个mean of stddevs统计量进行对比。\n你可以计算出全部统计量，但是这两个是最有用的。如果你打算监视服务器上的移除登录时间，你可以这样做：\n用户John登录并登出服务器A。获取服务器A的统计量，并更新它们。 获取mean of means统计量，计算出A的均值并且将其加入样本。我叫它m_of_m。 获取mean of stddev统计量，将A的标准差添加到样本中。我叫它 m_of_s。 如果A的mean在m_of_m.mean + 2 * m_of_m.stddev范围外，标记它可能存在问题。 如果A的stddev在m_of_s.mean + 2 * m_of_s.stddev范围外，标记它可能存在行为异常。 最后，如果John的登录时长在A的范围之外，或A的m_of_m范围之外，标记为有趣的。 通过计算“均值的均值”，或者“标准差的均值”，你可以以最小的执行和储存总量，有效地跟踪许多度量。\n附加题 link 将Stats_stddev 和 Stats_mean转换为static inline函数，放到stats.h文件中，而不是stats.c文件。 使用这份代码来编写string_algos_test.c的性能测试。使它为可选的，并且运行基准测试作为一系列样本，之后报告结果。 编写它的另一个语言的版本。确保这个版本基于我的数据正确执行。 编写一个小型程序，它能从文件读取所有数字，并执行这些统计。 使程序接收一个数据表，其中第一行是表头，剩下的行含有任意数量空格分隔的数值。你的程序应该按照表头中的名称，打印出每一列的统计值。 "
            }
        );
    index.add(
            {
                id:  54 ,
                href: "\/TechDocs\/docs\/c-guide\/ex44\/",
                title: "练习44：环形缓冲区",
                description: "原文：Exercise 44: Ring Buffer 译者：飞龙 环形缓冲区在处理异步IO时非常实用。它们可以在一端接收随机长度和区间的数据，在另一端以相同长度和区间提供密致的数据块。它们是Queue数据结构的变体，但是它针对于字节块而不是一系列指针。这个练习中我打算向你展示RingBuffer的代码，并且之后你需要对它执行完整的单元测试。 #ifndef _lcthw_RingBuffer_h #define _lcthw_RingBuffer_h #include typedef struct { char *buffer; int length; int start; int end; } RingBuffer; RingBuffer *RingBuffer_create(int length); void RingBuffer_destroy(RingBuffer *buffer); int RingBuffer_read(RingBuffer *buffer, char *target, int amount); int RingBuffer_write(RingBuffer *buffer, char *data, int length); int RingBuffer_empty(RingBuffer *buffer); int RingBuffer_full(RingBuffer *buffer); int RingBuffer_available_data(RingBuffer *buffer); int RingBuffer_available_space(RingBuffer *buffer); bstring RingBuffer_gets(RingBuffer *buffer, int amount); #define RingBuffer_available_data(B) (((B)-\u003eend + 1) % (B)-\u003elength - (B)-\u003estart - 1) #define RingBuffer_available_space(B) ((B)-\u003elength - (B)-\u003eend - 1) #define RingBuffer_full(B) (RingBuffer_available_data((B)) - (B)-\u003elength == 0) #define RingBuffer_empty(B) (RingBuffer_available_data((B)) == 0) #define RingBuffer_puts(B, D) RingBuffer_write((B), bdata((D)), blength((D))) #define RingBuffer_get_all(B) RingBuffer_gets((B), RingBuffer_available_data((B))) #define RingBuffer_starts_at(B) ((B)-\u003ebuffer + (B)-\u003estart) #define RingBuffer_ends_at(B) ((B)-\u003ebuffer + (B)-\u003eend) #define RingBuffer_commit_read(B, A) ((B)-\u003estart = ((B)-\u003estart + (A)) % (B)-\u003elength) #define RingBuffer_commit_write(B, A) ((B)-\u003eend = ((B)-\u003eend + (A)) % (B)-\u003elength) #endif 观察这个数据结构，你会看到它含有buffer、start 和 end。RingBuffer的所做的事情只是在buffer中移动start和end，所以当数据到达缓冲区末尾时还可以继续“循环”。这样就会给人一种在固定空间内无限读取的“幻觉”。接下来我创建了一些宏来基于它执行各种计算。",
                content: " 原文：Exercise 44: Ring Buffer\n译者：飞龙\n环形缓冲区在处理异步IO时非常实用。它们可以在一端接收随机长度和区间的数据，在另一端以相同长度和区间提供密致的数据块。它们是Queue数据结构的变体，但是它针对于字节块而不是一系列指针。这个练习中我打算向你展示RingBuffer的代码，并且之后你需要对它执行完整的单元测试。\n#ifndef _lcthw_RingBuffer_h #define _lcthw_RingBuffer_h #include typedef struct { char *buffer; int length; int start; int end; } RingBuffer; RingBuffer *RingBuffer_create(int length); void RingBuffer_destroy(RingBuffer *buffer); int RingBuffer_read(RingBuffer *buffer, char *target, int amount); int RingBuffer_write(RingBuffer *buffer, char *data, int length); int RingBuffer_empty(RingBuffer *buffer); int RingBuffer_full(RingBuffer *buffer); int RingBuffer_available_data(RingBuffer *buffer); int RingBuffer_available_space(RingBuffer *buffer); bstring RingBuffer_gets(RingBuffer *buffer, int amount); #define RingBuffer_available_data(B) (((B)-\u003eend + 1) % (B)-\u003elength - (B)-\u003estart - 1) #define RingBuffer_available_space(B) ((B)-\u003elength - (B)-\u003eend - 1) #define RingBuffer_full(B) (RingBuffer_available_data((B)) - (B)-\u003elength == 0) #define RingBuffer_empty(B) (RingBuffer_available_data((B)) == 0) #define RingBuffer_puts(B, D) RingBuffer_write((B), bdata((D)), blength((D))) #define RingBuffer_get_all(B) RingBuffer_gets((B), RingBuffer_available_data((B))) #define RingBuffer_starts_at(B) ((B)-\u003ebuffer + (B)-\u003estart) #define RingBuffer_ends_at(B) ((B)-\u003ebuffer + (B)-\u003eend) #define RingBuffer_commit_read(B, A) ((B)-\u003estart = ((B)-\u003estart + (A)) % (B)-\u003elength) #define RingBuffer_commit_write(B, A) ((B)-\u003eend = ((B)-\u003eend + (A)) % (B)-\u003elength) #endif 观察这个数据结构，你会看到它含有buffer、start 和 end。RingBuffer的所做的事情只是在buffer中移动start和end，所以当数据到达缓冲区末尾时还可以继续“循环”。这样就会给人一种在固定空间内无限读取的“幻觉”。接下来我创建了一些宏来基于它执行各种计算。\n下面是它的实现，它是对工作原理更好的解释：\n#undef NDEBUG #include #include #include #include #include #include RingBuffer *RingBuffer_create(int length) { RingBuffer *buffer = calloc(1, sizeof(RingBuffer)); buffer-\u003elength = length + 1; buffer-\u003estart = 0; buffer-\u003eend = 0; buffer-\u003ebuffer = calloc(buffer-\u003elength, 1); return buffer; } void RingBuffer_destroy(RingBuffer *buffer) { if(buffer) { free(buffer-\u003ebuffer); free(buffer); } } int RingBuffer_write(RingBuffer *buffer, char *data, int length) { if(RingBuffer_available_data(buffer) == 0) { buffer-\u003estart = buffer-\u003eend = 0; } check(length \u003c= RingBuffer_available_space(buffer), \"Not enough space: %d request, %d available\", RingBuffer_available_data(buffer), length); void *result = memcpy(RingBuffer_ends_at(buffer), data, length); check(result != NULL, \"Failed to write data into buffer.\"); RingBuffer_commit_write(buffer, length); return length; error: return -1; } int RingBuffer_read(RingBuffer *buffer, char *target, int amount) { check_debug(amount \u003c= RingBuffer_available_data(buffer), \"Not enough in the buffer: has %d, needs %d\", RingBuffer_available_data(buffer), amount); void *result = memcpy(target, RingBuffer_starts_at(buffer), amount); check(result != NULL, \"Failed to write buffer into data.\"); RingBuffer_commit_read(buffer, amount); if(buffer-\u003eend == buffer-\u003estart) { buffer-\u003estart = buffer-\u003eend = 0; } return amount; error: return -1; } bstring RingBuffer_gets(RingBuffer *buffer, int amount) { check(amount \u003e 0, \"Need more than 0 for gets, you gave: %d \", amount); check_debug(amount \u003c= RingBuffer_available_data(buffer), \"Not enough in the buffer.\"); bstring result = blk2bstr(RingBuffer_starts_at(buffer), amount); check(result != NULL, \"Failed to create gets result.\"); check(blength(result) == amount, \"Wrong result length.\"); RingBuffer_commit_read(buffer, amount); assert(RingBuffer_available_data(buffer) \u003e= 0 \u0026\u0026 \"Error in read commit.\"); return result; error: return NULL; } 这些就是一个基本的RingBuffer实现的全部了。你可以从中读取和写入数据，获得它的大小和容量。也有一些缓冲区使用OS中的技巧来创建虚拟的无限存储，但它们不可移植。\n由于我的RingBuffer处理读取和写入内存块，我要保证任何end == start出现的时候我都要将它们重置为0，使它们从退回缓冲区头部。在维基百科上的版本中，它并不可以写入数据块，所以只能移动end和start来转圈。为了更好地处理数据块，你需要在数据为空时移动到内部缓冲区的开头。\n单元测试 link对于你的单元测试，你需要测试尽可能多的情况。最简单的方法就是预构造不同的RingBuffer结构，之后手动检查函数和算数是否有效。例如，你可以构造end在缓冲区末尾的右边，而start在缓冲区范围内的RingBuffer，来看看它是否执行成功。\n你会看到什么 link下面是我的ringbuffer_tests运行结果：\n$ ./tests/ringbuffer_tests DEBUG tests/ringbuffer_tests.c:60: ----- RUNNING: ./tests/ringbuffer_tests ---- RUNNING: ./tests/ringbuffer_tests DEBUG tests/ringbuffer_tests.c:53: ----- test_create DEBUG tests/ringbuffer_tests.c:54: ----- test_read_write DEBUG tests/ringbuffer_tests.c:55: ----- test_destroy ALL TESTS PASSED Tests run: 3 $ 你应该测试至少三次来确保所有基本操作有效，并且看看在我完成之前你能测试到额外的多少东西。\n如何改进 link像往常一样，你应该为这个练习做防御性编程检查。我希望你这样做，是因为 liblcthw的代码基本上没有做我教给你的防御型编程检查。我将它们留给你，便于你熟悉使用这些额外的检查来改进代码。\n例如，这个环形缓冲区并没有过多检查每次访问是否实际上都在缓冲区内。\n如果你阅读环形缓冲区的维基百科页面，你会看到“优化的POSIX实现”，它使用POSIX特定的调用来创建一块无限的区域。研究并且在附加题中尝试实现它。\n附加题 link 创建RingBuffer的替代版本，使用POSIX的技巧并为其执行单元测试。 为二者添加一个性能对比测试，通过带有随机数据和随机读写操作的模糊测试来比较两个版本。确保你你对每个版本进行了相同的操作，便于你在操作之间比较二者。 使用callgrind 和 cachegrind比较二者的性能。 "
            }
        );
    index.add(
            {
                id:  55 ,
                href: "\/TechDocs\/docs\/c-guide\/ex45\/",
                title: "练习45：一个简单的TCP/IP客户端",
                description: "原文：Exercise 45: A Simple TCP/IP Client 译者：飞龙 我打算使用RingBuffer来创建一个非常简单的小型网络测试工具，叫做netclient。为此我需要向Makefile添加一些工具，来处理bin/目录下的小程序。 扩展Makefile link首先，为程序添加一些变量，就像单元测试的TESTS和TEST_SRC变量： PROGRAMS_SRC=$(wildcard bin/*.c) PROGRAMS=$(patsubst %.c,%,$(PROGRAMS_SRC)) 之后你可能想要添加PROGRAMS到所有目标中： all: $(TARGET) $(SO_TARGET) tests $(PROGRAMS) 之后在clean目标中向rm那一行添加PROGRAMS： rm -rf build $(OBJECTS) $(TESTS) $(PROGRAMS) 最后你还需要在最后添加一个目标来构建它们： $(PROGRAMS): CFLAGS += $(TARGET) 做了这些修改你就能够将.c文件扔到bin中，并且编译它们以及为其链接库文件，就像测试那样。 netclient 代码 linknetclient的代码是这样的： #undef NDEBUG #include #include #include #include #include #include #include #include #include #include #include #include struct tagbstring NL = bsStatic(\"\\n\"); struct tagbstring CRLF = bsStatic(\"\\r\\n\"); int nonblock(int fd) { int flags = fcntl(fd, F_GETFL, 0); check(flags \u003e= 0, \"Invalid flags on nonblock.",
                content: " 原文：Exercise 45: A Simple TCP/IP Client\n译者：飞龙\n我打算使用RingBuffer来创建一个非常简单的小型网络测试工具，叫做netclient。为此我需要向Makefile添加一些工具，来处理bin/目录下的小程序。\n扩展Makefile link首先，为程序添加一些变量，就像单元测试的TESTS和TEST_SRC变量：\nPROGRAMS_SRC=$(wildcard bin/*.c) PROGRAMS=$(patsubst %.c,%,$(PROGRAMS_SRC)) 之后你可能想要添加PROGRAMS到所有目标中：\nall: $(TARGET) $(SO_TARGET) tests $(PROGRAMS) 之后在clean目标中向rm那一行添加PROGRAMS：\nrm -rf build $(OBJECTS) $(TESTS) $(PROGRAMS) 最后你还需要在最后添加一个目标来构建它们：\n$(PROGRAMS): CFLAGS += $(TARGET) 做了这些修改你就能够将.c文件扔到bin中，并且编译它们以及为其链接库文件，就像测试那样。\nnetclient 代码 linknetclient的代码是这样的：\n#undef NDEBUG #include #include #include #include #include #include #include #include #include #include #include #include struct tagbstring NL = bsStatic(\"\\n\"); struct tagbstring CRLF = bsStatic(\"\\r\\n\"); int nonblock(int fd) { int flags = fcntl(fd, F_GETFL, 0); check(flags \u003e= 0, \"Invalid flags on nonblock.\"); int rc = fcntl(fd, F_SETFL, flags | O_NONBLOCK); check(rc == 0, \"Can't set nonblocking.\"); return 0; error: return -1; } int client_connect(char *host, char *port) { int rc = 0; struct addrinfo *addr = NULL; rc = getaddrinfo(host, port, NULL, \u0026addr); check(rc == 0, \"Failed to lookup %s:%s\", host, port); int sock = socket(AF_INET, SOCK_STREAM, 0); check(sock \u003e= 0, \"Cannot create a socket.\"); rc = connect(sock, addr-\u003eai_addr, addr-\u003eai_addrlen); check(rc == 0, \"Connect failed.\"); rc = nonblock(sock); check(rc == 0, \"Can't set nonblocking.\"); freeaddrinfo(addr); return sock; error: freeaddrinfo(addr); return -1; } int read_some(RingBuffer *buffer, int fd, int is_socket) { int rc = 0; if(RingBuffer_available_data(buffer) == 0) { buffer-\u003estart = buffer-\u003eend = 0; } if(is_socket) { rc = recv(fd, RingBuffer_starts_at(buffer), RingBuffer_available_space(buffer), 0); } else { rc = read(fd, RingBuffer_starts_at(buffer), RingBuffer_available_space(buffer)); } check(rc \u003e= 0, \"Failed to read from fd: %d\", fd); RingBuffer_commit_write(buffer, rc); return rc; error: return -1; } int write_some(RingBuffer *buffer, int fd, int is_socket) { int rc = 0; bstring data = RingBuffer_get_all(buffer); check(data != NULL, \"Failed to get from the buffer.\"); check(bfindreplace(data, \u0026NL, \u0026CRLF, 0) == BSTR_OK, \"Failed to replace NL.\"); if(is_socket) { rc = send(fd, bdata(data), blength(data), 0); } else { rc = write(fd, bdata(data), blength(data)); } check(rc == blength(data), \"Failed to write everything to fd: %d.\", fd); bdestroy(data); return rc; error: return -1; } int main(int argc, char *argv[]) { fd_set allreads; fd_set readmask; int socket = 0; int rc = 0; RingBuffer *in_rb = RingBuffer_create(1024 * 10); RingBuffer *sock_rb = RingBuffer_create(1024 * 10); check(argc == 3, \"USAGE: netclient host port\"); socket = client_connect(argv[1], argv[2]); check(socket \u003e= 0, \"connect to %s:%s failed.\", argv[1], argv[2]); FD_ZERO(\u0026allreads); FD_SET(socket, \u0026allreads); FD_SET(0, \u0026allreads); while(1) { readmask = allreads; rc = select(socket + 1, \u0026readmask, NULL, NULL, NULL); check(rc \u003e= 0, \"select failed.\"); if(FD_ISSET(0, \u0026readmask)) { rc = read_some(in_rb, 0, 0); check_debug(rc != -1, \"Failed to read from stdin.\"); } if(FD_ISSET(socket, \u0026readmask)) { rc = read_some(sock_rb, socket, 0); check_debug(rc != -1, \"Failed to read from socket.\"); } while(!RingBuffer_empty(sock_rb)) { rc = write_some(sock_rb, 1, 0); check_debug(rc != -1, \"Failed to write to stdout.\"); } while(!RingBuffer_empty(in_rb)) { rc = write_some(in_rb, socket, 1); check_debug(rc != -1, \"Failed to write to socket.\"); } } return 0; error: return -1; } 代码中使用了select来处理stdin（文件描述符0）和用于和服务器交互的socket中的事件。它使用了RingBuffer来储存和复制数据，并且你可以认为read_some和write_some函数都是RingBuffer中相似函数的原型。\n在这一小段代码中，可能有一些你并不知道的网络函数。当你碰到不知道的函数时，在手册页上查询它来确保你理解了它。这一小段代码可能需要让你研究用于小型服务器编程的所有C语言API。\n你会看到什么 link如果你完成了所有构建，测试的最快方式就是看看你能否从learncodethehardway.org上得到一个特殊的文件：\n$ $ ./bin/netclient learncodethehardway.org 80 GET /ex45.txt HTTP/1.1 Host: learncodethehardway.org HTTP/1.1 200 OK Date: Fri, 27 Apr 2012 00:41:25 GMT Content-Type: text/plain Content-Length: 41 Last-Modified: Fri, 27 Apr 2012 00:42:11 GMT ETag: 4f99eb63-29 Server: Mongrel2/1.7.5 Learn C The Hard Way, Exercise 45 works. ^C $ 这里我所做的事情是键入创建/ex45.txt的HTTP请求所需的语法，在Host:请求航之后，按下ENTER键来输入空行。接着我获取相应，包括响应头和内容。最后我按下CTRL-C来退出。\n如何使它崩溃 link这段代码肯定含有bug，但是当前在本书的草稿中，我会继续完成它。与此同时，尝试分析代码，并且用其它服务器来击溃它。一种叫做netcat的工具可以用于建立这种服务器。另一种方法就是使用Python或Ruby之类的语言创建一个简单的“垃圾服务器”，来产生垃圾数据，随机关闭连接，或者其它异常行为。\n如果你找到了bug，在评论中报告它们，我会修复它。\n附加题 link 像我提到的那样，这里面有一些你不知道的函数，去查询他们。实际上，即使你知道它们也要查询。 在valgrind下运行它来寻找错误。 为函数添加各种防御性编程检查，来改进它们。 使用getopt函数，运行用户提供选项来防止将\\n转换为\\r\\n。这仅仅用于需要处理行尾的协议例如HTTP。有时你可能不想执行转换，所以要给用户一个选择。 "
            }
        );
    index.add(
            {
                id:  56 ,
                href: "\/TechDocs\/docs\/c-guide\/ex46\/",
                title: "练习46：三叉搜索树",
                description: "原文：Exercise 46: Ternary Search Tree 译者：飞龙 我打算向你介绍的最后一种数据结构就是三叉搜索树（TSTree），它和BSTree很像，除了它有三个分支，low、equal和high。它的用法和BStree以及Hashmap基本相同，用于储存键值对的数据，但是它通过键中的独立字符来控制。这使得TSTree具有一些BStree和Hashmap不具备的功能。 TSTree的工作方式是，每个键都是字符串，根据字符串中字符的等性，通过构建或者遍历一棵树来进行插入。首先由根节点开始，观察每个节点的字符，如果小于、等于或大于则去往相应的方向。你可以参考这个头文件： #ifndef _lcthw_TSTree_h #define _lctwh_TSTree_h #include #include typedef struct TSTree { char splitchar; struct TSTree *low; struct TSTree *equal; struct TSTree *high; void *value; } TSTree; void *TSTree_search(TSTree *root, const char *key, size_t len); void *TSTree_search_prefix(TSTree *root, const char *key, size_t len); typedef void (*TSTree_traverse_cb)(void *value, void *data); TSTree *TSTree_insert(TSTree *node, const char *key, size_t len, void *value); void TSTree_traverse(TSTree *node, TSTree_traverse_cb cb, void *data); void TSTree_destroy(TSTree *root); #endif TSTree拥有下列成员：",
                content: " 原文：Exercise 46: Ternary Search Tree\n译者：飞龙\n我打算向你介绍的最后一种数据结构就是三叉搜索树（TSTree），它和BSTree很像，除了它有三个分支，low、equal和high。它的用法和BStree以及Hashmap基本相同，用于储存键值对的数据，但是它通过键中的独立字符来控制。这使得TSTree具有一些BStree和Hashmap不具备的功能。\nTSTree的工作方式是，每个键都是字符串，根据字符串中字符的等性，通过构建或者遍历一棵树来进行插入。首先由根节点开始，观察每个节点的字符，如果小于、等于或大于则去往相应的方向。你可以参考这个头文件：\n#ifndef _lcthw_TSTree_h #define _lctwh_TSTree_h #include #include typedef struct TSTree { char splitchar; struct TSTree *low; struct TSTree *equal; struct TSTree *high; void *value; } TSTree; void *TSTree_search(TSTree *root, const char *key, size_t len); void *TSTree_search_prefix(TSTree *root, const char *key, size_t len); typedef void (*TSTree_traverse_cb)(void *value, void *data); TSTree *TSTree_insert(TSTree *node, const char *key, size_t len, void *value); void TSTree_traverse(TSTree *node, TSTree_traverse_cb cb, void *data); void TSTree_destroy(TSTree *root); #endif TSTree拥有下列成员：\nsplitchar\n树中该节点的字符。\nlow\n小于splitchar的分支。\nequal\n等于splitchar的分支。\nhigh\n大于splitchar的分支。\nvalue\n这个节点上符合当前splitchar的值的集合。\n你可以看到这个实现中含有下列操作：\nsearch\n为特定key寻找值的典型操作。\nsearch_prefix\n寻找第一个以key为前缀的值，这是你不能轻易使用BSTree 或 Hashmap 完成的操作。\ninsert\n将key根据每个字符拆分，并把它插入到树中。\ntraverse\n遍历整颗树，使你能够收集或分析所包含的所有键和值。\n唯一缺少的操作就是TSTree_delete，这是因为它是一个开销很大的操作，比BSTree_delete大得多。当我使用TSTree结构时，我将它们视为常量数据，我打算遍历许多次，但是永远不会移除任何东西。它们对于这样的操作会很快，但是不适于需要快速插入或删除的情况。为此我会使用Hashmap因为它优于BSTree和TSTree。\nTSTree的实现非常简单，但是第一次可能难以理解。我会在你读完之后拆分它。\n#include #include #include #include #include static inline TSTree *TSTree_insert_base(TSTree *root, TSTree *node, const char *key, size_t len, void *value) { if(node == NULL) { node = (TSTree *) calloc(1, sizeof(TSTree)); if(root == NULL) { root = node; } node-\u003esplitchar = *key; } if(*key \u003c node-\u003esplitchar) { node-\u003elow = TSTree_insert_base(root, node-\u003elow, key, len, value); } else if(*key == node-\u003esplitchar) { if(len \u003e 1) { node-\u003eequal = TSTree_insert_base(root, node-\u003eequal, key+1, len - 1, value); } else { assert(node-\u003evalue == NULL \u0026\u0026 \"Duplicate insert into tst.\"); node-\u003evalue = value; } } else { node-\u003ehigh = TSTree_insert_base(root, node-\u003ehigh, key, len, value); } return node; } TSTree *TSTree_insert(TSTree *node, const char *key, size_t len, void *value) { return TSTree_insert_base(node, node, key, len, value); } void *TSTree_search(TSTree *root, const char *key, size_t len) { TSTree *node = root; size_t i = 0; while(i \u003c len \u0026\u0026 node) { if(key[i] \u003c node-\u003esplitchar) { node = node-\u003elow; } else if(key[i] == node-\u003esplitchar) { i++; if(i \u003c len) node = node-\u003eequal; } else { node = node-\u003ehigh; } } if(node) { return node-\u003evalue; } else { return NULL; } } void *TSTree_search_prefix(TSTree *root, const char *key, size_t len) { if(len == 0) return NULL; TSTree *node = root; TSTree *last = NULL; size_t i = 0; while(i \u003c len \u0026\u0026 node) { if(key[i] \u003c node-\u003esplitchar) { node = node-\u003elow; } else if(key[i] == node-\u003esplitchar) { i++; if(i \u003c len) { if(node-\u003evalue) last = node; node = node-\u003eequal; } } else { node = node-\u003ehigh; } } node = node ? node : last; // traverse until we find the first value in the equal chain // this is then the first node with this prefix while(node \u0026\u0026 !node-\u003evalue) { node = node-\u003eequal; } return node ? node-\u003evalue : NULL; } void TSTree_traverse(TSTree *node, TSTree_traverse_cb cb, void *data) { if(!node) return; if(node-\u003elow) TSTree_traverse(node-\u003elow, cb, data); if(node-\u003eequal) { TSTree_traverse(node-\u003eequal, cb, data); } if(node-\u003ehigh) TSTree_traverse(node-\u003ehigh, cb, data); if(node-\u003evalue) cb(node-\u003evalue, data); } void TSTree_destroy(TSTree *node) { if(node == NULL) return; if(node-\u003elow) TSTree_destroy(node-\u003elow); if(node-\u003eequal) { TSTree_destroy(node-\u003eequal); } if(node-\u003ehigh) TSTree_destroy(node-\u003ehigh); free(node); } 对于TSTree_insert，我使用了相同模式的递归结构，其中我创建了一个小型函数，它调用真正的递归函数。我对此并不做任何检查，但是你应该为之添加通常的防御性编程策略。要记住的一件事，就是它使用了一些不同的设计，这里并没有单独的TSTree_create函数，如果你将node传入为NULL，它会新建一个，然后返回最终的值。\n这意味着我需要为你分解TSTree_insert_base，使你理解插入操作。\ntstree.c:10-18\n像我提到的那样，如果函数接收到NULL，我需要创建节点，并且将*key（当前字符）赋值给它。这用于当我插入键时来构建树。\ntstree.c:20-21\n当*key小于splitchar时，选择low分支。\ntstree.c:22\n如果splitchar相等，我就要进一步确定等性。这会在我刚刚创建这个节点时发生，所以这里我会构建这棵树。\ntstree.c:23-24\n仍然有字符串需要处理，所以向下递归equal分支，并且移动到下一个*key字符。\ntstree.c:26-27\n这是最后一个字符的情况，所以我将值设置好。我编写了一个assert来避免重复。\ntstree.c:29-30\n最后的情况是*key大于splitchar，所以我需要向下递归high分支。\n这个数据结构的key实际上带有一些特性，我只会在splitchar相等时递增所要分析的字符。其它两种情况我只会继续遍历整个树，直到碰到了相等的字符，我才会递归处理下一个字符。这一操作使它对于找不到键的情况是非常快的。我可以传入一个不存在的键，简单地遍历一些high和low节点，直到我碰到了末尾并且知道这个键不存在。我并不需要处理键的每个字符，或者树的每个节点。\n一旦你理解了这些，之后来分析TSTree_search如何工作：\ntstree.c:46\n我并不需要递归处理整棵树，只需要使用while循环和当前的node节点。\ntstree.c:47-48\n如果当前字符小于节点中的splitchar，则选择low分支。\ntstree.c:49-51\n如果相等，自增i并且选择equal分支，只要不是最后一个字符。这就是if(i \u003c len)所做的，使我不会越过最后的value。\ntstree.c:52-53\n否则我会选择high分支，由于当前字符更大。\ntstree.c:57-61\n循环结束后如果node不为空，那么返回它的value，否则返回NULL。\n这并不难以理解，并且你可以看到TSTree_search_prefix函数用了几乎相同的算法。唯一的不同就是我并不试着寻找精确的匹配，而是可找到的最长前缀。我在相等时跟踪last节点来实现它，并且在搜索循环结束之后，遍历这个节点直到发现value。\n观察TSTree_search_prefix，你就会开始明白TSTree相对BSTree 和 Hashmap在查找操作上的另一个优点。给定一个长度为X的键，你可以在X步内找到任何键，但是也可以在X步加上额外的N步内找到第一个前缀，取决于匹配的键有多长。如果树中最长的键是十个字符，那么你就可以在10步之内找到任意的前缀。更重要的是，你可以通过对键的每个字符只比较一次来实现。\n相比之下，使用BSTree执行相同操作，你需要在BSTree的每一个可能匹配的节点中检查两个字符串是否有共同的前缀。这对于寻找键，或者检查键是否存在（TSTree_search）是相同的。你需要将每个字符与BSTree中的大多数字符对比，来确认是否匹配。\nHashamp对于寻找前缀更加糟糕，因为你不能够仅仅计算前缀的哈希值。你基本上不能高效在Hashmap中实现它，除非数据类似URL可以被解析。即使这样你还是需要遍历Hashmap的所有节点。\n译者注：二叉树和三叉树在搜索时都是走其中的一支，但由于二叉树中每个节点储存字符串，而三叉树储存的是字符。所以三叉树的整个搜索过程相当于一次字符串比较，而二叉树的每个节点都需要一次字符串比较。三叉树堆叠储存字符串使搜索起来更方便。\n至于哈希表，由于字符串整体和前缀计算出来的哈希值差别很大，所以按前缀搜索时，哈希的优势完全失效，所以只能改为暴力搜索，效果比二叉树还要差。\n最后的两个函数应该易于分析，因为它们是典型的遍历和销毁操作，你已经在其它数据结构中看到过了。\n最后，我编写了简单的单元测试，来确保我所做的全部东西正确。\n#include \"minunit.h\" #include #include #include #include TSTree *node = NULL; char *valueA = \"VALUEA\"; char *valueB = \"VALUEB\"; char *value2 = \"VALUE2\"; char *value4 = \"VALUE4\"; char *reverse = \"VALUER\"; int traverse_count = 0; struct tagbstring test1 = bsStatic(\"TEST\"); struct tagbstring test2 = bsStatic(\"TEST2\"); struct tagbstring test3 = bsStatic(\"TSET\"); struct tagbstring test4 = bsStatic(\"T\"); char *test_insert() { node = TSTree_insert(node, bdata(\u0026test1), blength(\u0026test1), valueA); mu_assert(node != NULL, \"Failed to insert into tst.\"); node = TSTree_insert(node, bdata(\u0026test2), blength(\u0026test2), value2); mu_assert(node != NULL, \"Failed to insert into tst with second name.\"); node = TSTree_insert(node, bdata(\u0026test3), blength(\u0026test3), reverse); mu_assert(node != NULL, \"Failed to insert into tst with reverse name.\"); node = TSTree_insert(node, bdata(\u0026test4), blength(\u0026test4), value4); mu_assert(node != NULL, \"Failed to insert into tst with second name.\"); return NULL; } char *test_search_exact() { // tst returns the last one inserted void *res = TSTree_search(node, bdata(\u0026test1), blength(\u0026test1)); mu_assert(res == valueA, \"Got the wrong value back, should get A not B.\"); // tst does not find if not exact res = TSTree_search(node, \"TESTNO\", strlen(\"TESTNO\")); mu_assert(res == NULL, \"Should not find anything.\"); return NULL; } char *test_search_prefix() { void *res = TSTree_search_prefix(node, bdata(\u0026test1), blength(\u0026test1)); debug(\"result: %p, expected: %p\", res, valueA); mu_assert(res == valueA, \"Got wrong valueA by prefix.\"); res = TSTree_search_prefix(node, bdata(\u0026test1), 1); debug(\"result: %p, expected: %p\", res, valueA); mu_assert(res == value4, \"Got wrong value4 for prefix of 1.\"); res = TSTree_search_prefix(node, \"TE\", strlen(\"TE\")); mu_assert(res != NULL, \"Should find for short prefix.\"); res = TSTree_search_prefix(node, \"TE--\", strlen(\"TE--\")); mu_assert(res != NULL, \"Should find for partial prefix.\"); return NULL; } void TSTree_traverse_test_cb(void *value, void *data) { assert(value != NULL \u0026\u0026 \"Should not get NULL value.\"); assert(data == valueA \u0026\u0026 \"Expecting valueA as the data.\"); traverse_count++; } char *test_traverse() { traverse_count = 0; TSTree_traverse(node, TSTree_traverse_test_cb, valueA); debug(\"traverse count is: %d\", traverse_count); mu_assert(traverse_count == 4, \"Didn't find 4 keys.\"); return NULL; } char *test_destroy() { TSTree_destroy(node); return NULL; } char * all_tests() { mu_suite_start(); mu_run_test(test_insert); mu_run_test(test_search_exact); mu_run_test(test_search_prefix); mu_run_test(test_traverse); mu_run_test(test_destroy); return NULL; } RUN_TESTS(all_tests); 优点和缺点 linkTSTree可以用于实现一些其它实用的事情：\n除了寻找前缀，你可以反转插入的所有键，之后通过后缀来寻找。我使用它来寻找主机名称，因为我想要找到*.learncodethehardway.com，所以如果我反向来寻找，会更快匹配到它们。 你可以执行“模糊”搜索，其中你可以收集所有与键的大多数字符相似的节点，或者使用其它算法用于搜索近似的匹配。 你可以寻找所有中间带有特定部分的键。 我已经谈论了TSTree能做的一些事情，但是它们并不总是最好的数据结构。TSTree的缺点在于：\n像我提到过的那样，删除操作非常麻烦。它们适用于需要快速检索并且从不移除的操作。如果你需要删除，可以简单地将value置空，之后当树过大时周期性重构它。 与BSTree和Hashmap相比，它在相同的键上使用了大量的空间。它对于键中的每个字符都使用了完整的节点。它对于短的键效果更好，但如果你在TSTree中放入一大堆东西，它会变得很大。 它们也不适合处理非常长的键，然而“长”是主观的词，所以应当像通常一样先进行测试。如果你尝试储存一万个字符的键，那么应当使用Hashmap。 如何改进 link像通常一样，浏览代码，使用防御性的先决条件、断言，并且检查每个函数来改进。下面是一些其他的改进方案，但是你并不需要全部实现它们：\n你可以使用DArray来允许重复的value值。 因为我提到删除非常困难，但是你可以通过将值设为NULL来模拟，使值能够高效被删除。 目前还不能获取到所有匹配指定前缀的值，我会让你在附加题中实现它。 有一些其他得更复杂的算法会比它要好。查询前缀数组、前缀树和基数树的资料。 附加题 link 实现TSTree_collect返回DArray包含所有匹配指定前缀的键。 实现TSTree_search_suffix和TSTree_insert_suffix，实现后缀搜索和插入。 使用valgrind来查看与BSTree 和 Hashmap相比，这个结构使用了多少内存来储存数据。 "
            }
        );
    index.add(
            {
                id:  57 ,
                href: "\/TechDocs\/docs\/c-guide\/ex47\/",
                title: "练习47：一个快速的URL路由",
                description: "原文：Exercise 47: A Fast URL Router 译者：飞龙 我现在打算向你展示使用TSTree来创建服务器中的快速URL路由。它适用于应用中的简单的URL匹配，而不是在许多Web应用框架中的更复杂（一些情况下也不必要）的路由发现功能。 我打算编程一个小型命令行工具和路由交互，他叫做urlor，读取简单的路由文件，之后提示用户输入要检索的URL。 #include #include TSTree *add_route_data(TSTree *routes, bstring line) { struct bstrList *data = bsplit(line, ' '); check(data-\u003eqty == 2, \"Line '%s' does not have 2 columns\", bdata(line)); routes = TSTree_insert(routes, bdata(data-\u003eentry[0]), blength(data-\u003eentry[0]), bstrcpy(data-\u003eentry[1])); bstrListDestroy(data); return routes; error: return NULL; } TSTree *load_routes(const char *file) { TSTree *routes = NULL; bstring line = NULL; FILE *routes_map = NULL; routes_map = fopen(file, \"r\"); check(routes_map !",
                content: " 原文：Exercise 47: A Fast URL Router\n译者：飞龙\n我现在打算向你展示使用TSTree来创建服务器中的快速URL路由。它适用于应用中的简单的URL匹配，而不是在许多Web应用框架中的更复杂（一些情况下也不必要）的路由发现功能。\n我打算编程一个小型命令行工具和路由交互，他叫做urlor，读取简单的路由文件，之后提示用户输入要检索的URL。\n#include #include TSTree *add_route_data(TSTree *routes, bstring line) { struct bstrList *data = bsplit(line, ' '); check(data-\u003eqty == 2, \"Line '%s' does not have 2 columns\", bdata(line)); routes = TSTree_insert(routes, bdata(data-\u003eentry[0]), blength(data-\u003eentry[0]), bstrcpy(data-\u003eentry[1])); bstrListDestroy(data); return routes; error: return NULL; } TSTree *load_routes(const char *file) { TSTree *routes = NULL; bstring line = NULL; FILE *routes_map = NULL; routes_map = fopen(file, \"r\"); check(routes_map != NULL, \"Failed to open routes: %s\", file); while((line = bgets((bNgetc)fgetc, routes_map, '\\n')) != NULL) { check(btrimws(line) == BSTR_OK, \"Failed to trim line.\"); routes = add_route_data(routes, line); check(routes != NULL, \"Failed to add route.\"); bdestroy(line); } fclose(routes_map); return routes; error: if(routes_map) fclose(routes_map); if(line) bdestroy(line); return NULL; } bstring match_url(TSTree *routes, bstring url) { bstring route = TSTree_search(routes, bdata(url), blength(url)); if(route == NULL) { printf(\"No exact match found, trying prefix.\\n\"); route = TSTree_search_prefix(routes, bdata(url), blength(url)); } return route; } bstring read_line(const char *prompt) { printf(\"%s\", prompt); bstring result = bgets((bNgetc)fgetc, stdin, '\\n'); check_debug(result != NULL, \"stdin closed.\"); check(btrimws(result) == BSTR_OK, \"Failed to trim.\"); return result; error: return NULL; } void bdestroy_cb(void *value, void *ignored) { (void)ignored; bdestroy((bstring)value); } void destroy_routes(TSTree *routes) { TSTree_traverse(routes, bdestroy_cb, NULL); TSTree_destroy(routes); } int main(int argc, char *argv[]) { bstring url = NULL; bstring route = NULL; check(argc == 2, \"USAGE: urlor \"); TSTree *routes = load_routes(argv[1]); check(routes != NULL, \"Your route file has an error.\"); while(1) { url = read_line(\"URL\u003e \"); check_debug(url != NULL, \"goodbye.\"); route = match_url(routes, url); if(route) { printf(\"MATCH: %s == %s\\n\", bdata(url), bdata(route)); } else { printf(\"FAIL: %s\\n\", bdata(url)); } bdestroy(url); } destroy_routes(routes); return 0; error: destroy_routes(routes); return 1; } 之后我创建了一个简单的文件，含有一些用于交互的伪造的路由：\n/ MainApp /hello Hello /hello/ Hello /signup Signup /logout Logout /album/ Album 你会看到什么 link一旦你使urlor工作，并且创建了路由文件，你可以尝试这样：\n$ ./bin/urlor urls.txt URL\u003e / MATCH: / == MainApp URL\u003e /hello MATCH: /hello == Hello URL\u003e /hello/zed No exact match found, trying prefix. MATCH: /hello/zed == Hello URL\u003e /album No exact match found, trying prefix. MATCH: /album == Album URL\u003e /album/12345 No exact match found, trying prefix. MATCH: /album/12345 == Album URL\u003e asdfasfdasfd No exact match found, trying prefix. FAIL: asdfasfdasfd URL\u003e /asdfasdfasf No exact match found, trying prefix. MATCH: /asdfasdfasf == MainApp URL\u003e $ 你可以看到路由系统首先尝试精确匹配，之后如果找不到的话则会尝试前缀匹配。这主要是尝试这二者的不同。根据你的URL的语义，你可能想要之中精确匹配，始终前缀匹配，或者执行二者并选出“最好”的那个。\n如何改进 linkURL非常古怪。因为人们想让它们神奇地处理它们的web应用所具有的，所有疯狂的事情，即使不是很合逻辑。在这个对如何将TSTree用作路由的简单演示中，它具有一些人们不想要的缺陷。比如，它会把/al匹配到Album，它是人们通常不想要的。它们想要/album/*匹配到Album以及/al匹配到404错误。\n这并不难以实现，因为你可以修改前缀算法来以你想要的任何方式匹配。如果你修改了匹配算法，来寻找所有匹配的前缀，之后选出“最好”的那个，你就可以轻易做到它。这种情况下，/al回匹配MainApp或者Album。获得这些结果之后，就可以执行一些逻辑来决定哪个“最好”。\n另一件你能在真正的路由系统里做的事情，就是使用TSTree来寻找所有可能的匹配，但是这些匹配是需要检查的一些模式串。在许多web应用中，有一个正则表达式的列表，用于和每个请求的URL进行匹配。匹配所有这些正则表达式非常花时间，所以你可以使用TSTree来通过它们的前缀寻找所有可能的结果。于是你就可以缩小模式串的范围，更快速地做尝试。\n使用这种方式，你的URL会精确匹配，因为你实际上运行了正则表达式，它们匹配起来更快，因为你通过可能的前缀来查找它们。\n这种算法也可用于所有需要用户可视化的灵活路由机制。域名、IP地址、包注册器和目录，文件或者URL。\n附加题 link 创建一个实际的引擎，使用Handler结构储存应用，而不是仅仅储存应用的字符串。这个结构储存它所绑定的URL，名称和任何需要构建实际路由系统的东西。 将URL映射到.so文件而不是任意的名字，并且使用dlopen系统动态加载处理器，并执行它们所包含的回调。将这些回调放进你的Handler结构体中，之后你就用C编写了动态回调处理器系统的全部。 "
            }
        );
    index.add(
            {
                id:  58 ,
                href: "\/TechDocs\/docs\/c-guide\/postscript\/",
                title: "“解构 K\u0026R C” 已死",
                description: "原文：Deconstructing K\u0026RC Is Dead\n译者：飞龙\n我彻底失败了。我放弃了多年以来尝试理清C语言如何编写的想法，因为它的发明是有缺陷的。起初，我的书中有一章叫做“解构 K\u0026R C”。这一章的目的是告诉人们永远不要假设它们的代码是正确的，或者对于任何人的代码，不管它有多出名，也不能避免缺陷。这看起来似乎并不是革命性的想法，并且对我来说它只是分析代码缺陷和编写更好更可靠代码的一部分。\n多年以来，我在写这本书的这一块时收到重挫，并且收到了比任何其它事情更多的批评和侮辱。不仅如此，而且书中这部分的批评以这些话而结束，“你是对的，但是你认为他们的代码很烂这件事是错的。”我不能理解，有一群被认为很聪明的人，他们的大脑中充满理性，却坚持“我可以是错的，但是同时也可以是对的”的观点。我不得不与这些学究在C IRC channels、邮件列表、评论上斗争，这包括每一个它们提出一些怪异的、迂腐的刻薄意见的情况，需要我对我的文章进行更多的逻辑性修改来说服他们。\n有趣的一点是，在我写这部分之前，我收到了本书许多正面的评论。当时本书还在写作中，所以我觉得确实需要改进。我甚至设置了一些奖金让人们帮助改进。但可悲的是，一旦他们被自己的英雄蒙蔽，所崇拜的基调就发生了翻天覆地的变化。我变得十分令人讨厌，只不过是尝试教人们如何安全使用一个极易出错的垃圾语言，比如C语言。这是我很擅长的东西。\n这些批评者向我承认，他们不写C代码也不教授它，他们只是死记硬背标准库来“帮助”其它人，这对我来说并不重要。我以一个开放的心态试图解决问题，甚至设置奖金给那些有助于修复它的人，这也不重要。这可以使更多的人爱上C语言，并且使其它人入门编程，这更不重要。重要的是我“侮辱”了他们的英雄，这意味着我所说的话永远地完蛋了，没有人会再次相信我。\n坦率地说，这是编程文化极为的黑暗、丑陋、邪恶的一面。他们整天在说，“我与你们同在”，但是如果你不屈服于大师们海量的学识，以及乞求他们准许你质疑他们所信奉的东西，你突然就会变成敌人。程序员费尽心机地把自己放在权力的宝座上，来要求别人赞许他们高超的记忆能力，或者对一些微不足道的琐事的熟知，并且会尽全力消灭那些胆敢质疑的人。\n这非常恶心，我对此也没什么能做的。我对老程序员无能为力。但他们注定会失败。它们通过标准化记忆所积累的学识，也会在咸鱼的下一次翻身中蒸发掉。它们对考虑如何事物的运作方式，以及如何改进它们，或者将它们的手艺传授给他人毫无兴趣，除非这里面涉及到大量的阿谀奉承并让他们觉得很爽。老程序员总会完蛋的。\n他们向现在的年轻程序员施压，我对此并不能做任何事情。我不能阻止无能程序员的诽谤，他们甚至根本不像专业的C程序员那样。然而，我宁愿使本书有助于那些想要学习C语言以及如何编写可靠的软件的人，而不是和那些思维闭锁的保守派做斗争。它们贪图安逸的行为给人一种感觉，就是他们知道更多迂腐的、可怜的小话题，就比如未定义行为。\n因此，我删除了书中的K\u0026R C部分，并且找到了新的主题。我打算重写这本书，但是并不知道如何去做。我犹如在地狱中，因为我自己非常执着于我觉得很重要的一些事情，但我不知道如何推进。我现在算是明白了这是错的，因为它阻碍我将一些与C不相关的重要技巧教给许多新的程序员，包括编程规范、代码分析、缺陷和安全漏洞的检测，以及学习其它编程语言的方法。\n现在我明白了，我将为这本书制作一些课程，关于编写最安全的C代码，以及将C语言代码打破为一种学习C和编程规范的方式。我会卑微地说我的书只是一个桥梁，所有人应该去读K\u0026R C来迎合这些学究，并且在这些黄金法则的脚下顶礼膜拜。我要澄清我的C版本限制于一个固定的目的之中，因为这让我的代码更安全。我一定会提到所有迂腐的东西，比如每个书呆子式的，关于20世纪60年代的PDP-11电脑上空指针的要求。\n之后，我会告诉人们不要再去写别的C程序。这不会很明显，完全不会，但我的目标是将人们从C带到能更好地编程的其它语言中。Go、Rust或者Swift，是我能想到的能处理C语言主要任务新型语言，所以我推荐人们学习它们。我会告诉他们，他们的技能在于发现缺陷，并且对C代码的严格分析将会对所有语言都有巨大的好处，以及使其它语言更易于学习。\n但是C呢？C已经死了，它是为想要争论A.6.2章第四段的指针未定义行为的老程序员准备的。谢天谢地，我打算去学习Go（或者Rust，或者Swift，或者其它任何东西）了。",
                content: " 原文：Deconstructing K\u0026RC Is Dead\n译者：飞龙\n我彻底失败了。我放弃了多年以来尝试理清C语言如何编写的想法，因为它的发明是有缺陷的。起初，我的书中有一章叫做“解构 K\u0026R C”。这一章的目的是告诉人们永远不要假设它们的代码是正确的，或者对于任何人的代码，不管它有多出名，也不能避免缺陷。这看起来似乎并不是革命性的想法，并且对我来说它只是分析代码缺陷和编写更好更可靠代码的一部分。\n多年以来，我在写这本书的这一块时收到重挫，并且收到了比任何其它事情更多的批评和侮辱。不仅如此，而且书中这部分的批评以这些话而结束，“你是对的，但是你认为他们的代码很烂这件事是错的。”我不能理解，有一群被认为很聪明的人，他们的大脑中充满理性，却坚持“我可以是错的，但是同时也可以是对的”的观点。我不得不与这些学究在C IRC channels、邮件列表、评论上斗争，这包括每一个它们提出一些怪异的、迂腐的刻薄意见的情况，需要我对我的文章进行更多的逻辑性修改来说服他们。\n有趣的一点是，在我写这部分之前，我收到了本书许多正面的评论。当时本书还在写作中，所以我觉得确实需要改进。我甚至设置了一些奖金让人们帮助改进。但可悲的是，一旦他们被自己的英雄蒙蔽，所崇拜的基调就发生了翻天覆地的变化。我变得十分令人讨厌，只不过是尝试教人们如何安全使用一个极易出错的垃圾语言，比如C语言。这是我很擅长的东西。\n这些批评者向我承认，他们不写C代码也不教授它，他们只是死记硬背标准库来“帮助”其它人，这对我来说并不重要。我以一个开放的心态试图解决问题，甚至设置奖金给那些有助于修复它的人，这也不重要。这可以使更多的人爱上C语言，并且使其它人入门编程，这更不重要。重要的是我“侮辱”了他们的英雄，这意味着我所说的话永远地完蛋了，没有人会再次相信我。\n坦率地说，这是编程文化极为的黑暗、丑陋、邪恶的一面。他们整天在说，“我与你们同在”，但是如果你不屈服于大师们海量的学识，以及乞求他们准许你质疑他们所信奉的东西，你突然就会变成敌人。程序员费尽心机地把自己放在权力的宝座上，来要求别人赞许他们高超的记忆能力，或者对一些微不足道的琐事的熟知，并且会尽全力消灭那些胆敢质疑的人。\n这非常恶心，我对此也没什么能做的。我对老程序员无能为力。但他们注定会失败。它们通过标准化记忆所积累的学识，也会在咸鱼的下一次翻身中蒸发掉。它们对考虑如何事物的运作方式，以及如何改进它们，或者将它们的手艺传授给他人毫无兴趣，除非这里面涉及到大量的阿谀奉承并让他们觉得很爽。老程序员总会完蛋的。\n他们向现在的年轻程序员施压，我对此并不能做任何事情。我不能阻止无能程序员的诽谤，他们甚至根本不像专业的C程序员那样。然而，我宁愿使本书有助于那些想要学习C语言以及如何编写可靠的软件的人，而不是和那些思维闭锁的保守派做斗争。它们贪图安逸的行为给人一种感觉，就是他们知道更多迂腐的、可怜的小话题，就比如未定义行为。\n因此，我删除了书中的K\u0026R C部分，并且找到了新的主题。我打算重写这本书，但是并不知道如何去做。我犹如在地狱中，因为我自己非常执着于我觉得很重要的一些事情，但我不知道如何推进。我现在算是明白了这是错的，因为它阻碍我将一些与C不相关的重要技巧教给许多新的程序员，包括编程规范、代码分析、缺陷和安全漏洞的检测，以及学习其它编程语言的方法。\n现在我明白了，我将为这本书制作一些课程，关于编写最安全的C代码，以及将C语言代码打破为一种学习C和编程规范的方式。我会卑微地说我的书只是一个桥梁，所有人应该去读K\u0026R C来迎合这些学究，并且在这些黄金法则的脚下顶礼膜拜。我要澄清我的C版本限制于一个固定的目的之中，因为这让我的代码更安全。我一定会提到所有迂腐的东西，比如每个书呆子式的，关于20世纪60年代的PDP-11电脑上空指针的要求。\n之后，我会告诉人们不要再去写别的C程序。这不会很明显，完全不会，但我的目标是将人们从C带到能更好地编程的其它语言中。Go、Rust或者Swift，是我能想到的能处理C语言主要任务新型语言，所以我推荐人们学习它们。我会告诉他们，他们的技能在于发现缺陷，并且对C代码的严格分析将会对所有语言都有巨大的好处，以及使其它语言更易于学习。\n但是C呢？C已经死了，它是为想要争论A.6.2章第四段的指针未定义行为的老程序员准备的。谢天谢地，我打算去学习Go（或者Rust，或者Swift，或者其它任何东西）了。\n"
            }
        );
    index.add(
            {
                id:  59 ,
                href: "\/TechDocs\/docs\/c-guide\/donors\/",
                title: "捐赠名单",
                description: "感谢以下童鞋的捐助，你们的慷慨是我继续的动力：\ndonor value jxdwinter 6.00 贾**@悠云.com 20.00 Mr.Moon 2.00 ",
                content: "感谢以下童鞋的捐助，你们的慷慨是我继续的动力：\ndonor value jxdwinter 6.00 贾**@悠云.com 20.00 Mr.Moon 2.00 "
            }
        );
    index.add(
            {
                id:  60 ,
                href: "\/TechDocs\/docs\/hpcgame\/",
                title: "高性能计算竞赛存档",
                description: "",
                content: ""
            }
        );
    index.add(
            {
                id:  61 ,
                href: "\/TechDocs\/docs\/hpcgame\/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97%E7%AE%80%E4%BB%8B\/",
                title: "1. 高性能计算简介",
                description: "",
                content: ""
            }
        );
    index.add(
            {
                id:  62 ,
                href: "\/TechDocs\/docs\/hpcgame\/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97%E7%AE%80%E4%BB%8B\/1a\/",
                title: "A. 欢迎参赛",
                description: "欢迎参赛 link欢迎参加第零届北京大学高性能计算综合能力竞赛！\n点击题目列表上方“进入超算平台”按钮即可登入 SCOW 平台。我们为每位选手预充值了一些金额，以方便大家的使用。\n如果需要在线编写和调试程序，我们推荐使用在线 VSCode。您可以在 SCOW 平台上打开“交互式应用”，并创建一个 VSCode 应用，然后点击连接即可。请注意，默认情况下一小时后打开的实例会被自动销毁。在创建交互式应用时，保持页面的默认配置即可（分区：compute，核心数：1）。\n您也可以选择使用在线 Shell 进行程序的编写和调试，但是我们提倡：不要在登录节点上运行大型计算任务。您可以通过 SCOW 的文件管理功能进行文件的上传和下载。您放在您家目录（/data/home/您的SCOW用户名（注意：和您的用户名、用户ID并不相同））内的文件将在所有集群内的机器上可见。交互式应用的销毁并不会导致您家目录内文件的丢失，但是我们仍提倡定期将集群内保存的代码等文件下载到本地。我们不对该集群上任何数据丢失负责。\n如何使用 GPU：在分区 GPU （大写）即可使用 GPU，记得在分配任务时需要指定 --gres=gpu:1，从而分配一块 GPU。\n关于本题 link本题意图祝愿大家在本次比赛中取得良好成绩，所以获得本题的分数也十分容易。您只需下载集群中的 /data/hpcgame/bonus/bonus.dat 并提交，即可获得本题的全部分数！",
                content: "欢迎参赛 link欢迎参加第零届北京大学高性能计算综合能力竞赛！\n点击题目列表上方“进入超算平台”按钮即可登入 SCOW 平台。我们为每位选手预充值了一些金额，以方便大家的使用。\n如果需要在线编写和调试程序，我们推荐使用在线 VSCode。您可以在 SCOW 平台上打开“交互式应用”，并创建一个 VSCode 应用，然后点击连接即可。请注意，默认情况下一小时后打开的实例会被自动销毁。在创建交互式应用时，保持页面的默认配置即可（分区：compute，核心数：1）。\n您也可以选择使用在线 Shell 进行程序的编写和调试，但是我们提倡：不要在登录节点上运行大型计算任务。您可以通过 SCOW 的文件管理功能进行文件的上传和下载。您放在您家目录（/data/home/您的SCOW用户名（注意：和您的用户名、用户ID并不相同））内的文件将在所有集群内的机器上可见。交互式应用的销毁并不会导致您家目录内文件的丢失，但是我们仍提倡定期将集群内保存的代码等文件下载到本地。我们不对该集群上任何数据丢失负责。\n如何使用 GPU：在分区 GPU （大写）即可使用 GPU，记得在分配任务时需要指定 --gres=gpu:1，从而分配一块 GPU。\n关于本题 link本题意图祝愿大家在本次比赛中取得良好成绩，所以获得本题的分数也十分容易。您只需下载集群中的 /data/hpcgame/bonus/bonus.dat 并提交，即可获得本题的全部分数！\n"
            }
        );
    index.add(
            {
                id:  63 ,
                href: "\/TechDocs\/docs\/hpcgame\/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97%E7%AE%80%E4%BB%8B\/1b\/",
                title: "B. 实验室的新机器",
                description: "题面 link小北实验室最近新购置了几台服务器，供日常实验数据分析使用。为了让大家都能合理且方便地运用这些机器，你在它们上面安装了 slurm 和 SCOW，大家都使用得很开心。\n李华今年刚加入小北实验室。他的日常工作需要分析大量数据。李华撰写了一个程序，专门用于分析他的这些数据。他使用他的笔记本运行这个程序。但是，李华发现，随着研究的不断深入，他需要分析的数据也越来越复杂；终于有一天，李华的笔记本“罢工”了——它所使用的“火龙一号”处理器在持续不断的满负荷工作过程中产生了过量的热，导致自己处于被烧毁的边缘，触发了“罢工”的保护机制。\n于是，李华申请了实验室服务器账号，接下来他便可以把他的程序运行在实验室服务器上，他的笔记本也可以得到良好的休息。这将为他省下一大笔修理费用。\n但是李华发现，每次在集群上运行自己的程序都需要先输入一堆与 slurm 有关的命令，他觉得这有些繁琐，希望你能帮他编写一个脚本，运行这个脚本以后，就会自动地创建 Job 、分配资源并运行李华的程序，在程序运行完成之后还会留存该程序运行的资源消耗情况。\n你看在李华这次承诺不再需要你为他撰写一封收件人是你自己的感谢信的份上，决定帮他这个忙。\n提交要求 link请你提交一个脚本文件（允许的格式：Shell 脚本或 Python 脚本），它需要满足如下要求：\n在文件头部具有一个 Shebang，用于表明如何运行该脚本（例子：对于一个 Bash 脚本来说，通常为 #!/bin/bash） 该脚本需要完成如下工作： 在计算节点上运行李华的程序（./program），这个程序接收一个命令行参数，在调用你撰写的脚本时，也会传入这个参数，如果你编写 Shell 脚本，可以使用 $1 来访问；计算节点应位于 compute 分区，配置为一个机器、一个核心（-N1 -n1 -c1） 将程序的输出重定向到 output.dat 使用 seff 命令查看运行这个 Job 的资源使用情况，并将输出重定向到 seff.dat 注：李华不会使用 sbatch，所以你的程序是直接在登录节点上被执行的！\n提示 link 为了降低你的工作量，李华的程序会获取 Slurm Job ID 并输出至 job_id.dat 文件。 李华的程序不会输出至 stderr，只会输出至 stdout。 在 Shell 脚本中，将一个文件的内容作为命令参数的部分方式： 使用类似 command_name \"$(cat filename.dat)\" 的方式 使用类似 cat filename.dat | xargs command_name 的方式 ",
                content: "题面 link小北实验室最近新购置了几台服务器，供日常实验数据分析使用。为了让大家都能合理且方便地运用这些机器，你在它们上面安装了 slurm 和 SCOW，大家都使用得很开心。\n李华今年刚加入小北实验室。他的日常工作需要分析大量数据。李华撰写了一个程序，专门用于分析他的这些数据。他使用他的笔记本运行这个程序。但是，李华发现，随着研究的不断深入，他需要分析的数据也越来越复杂；终于有一天，李华的笔记本“罢工”了——它所使用的“火龙一号”处理器在持续不断的满负荷工作过程中产生了过量的热，导致自己处于被烧毁的边缘，触发了“罢工”的保护机制。\n于是，李华申请了实验室服务器账号，接下来他便可以把他的程序运行在实验室服务器上，他的笔记本也可以得到良好的休息。这将为他省下一大笔修理费用。\n但是李华发现，每次在集群上运行自己的程序都需要先输入一堆与 slurm 有关的命令，他觉得这有些繁琐，希望你能帮他编写一个脚本，运行这个脚本以后，就会自动地创建 Job 、分配资源并运行李华的程序，在程序运行完成之后还会留存该程序运行的资源消耗情况。\n你看在李华这次承诺不再需要你为他撰写一封收件人是你自己的感谢信的份上，决定帮他这个忙。\n提交要求 link请你提交一个脚本文件（允许的格式：Shell 脚本或 Python 脚本），它需要满足如下要求：\n在文件头部具有一个 Shebang，用于表明如何运行该脚本（例子：对于一个 Bash 脚本来说，通常为 #!/bin/bash） 该脚本需要完成如下工作： 在计算节点上运行李华的程序（./program），这个程序接收一个命令行参数，在调用你撰写的脚本时，也会传入这个参数，如果你编写 Shell 脚本，可以使用 $1 来访问；计算节点应位于 compute 分区，配置为一个机器、一个核心（-N1 -n1 -c1） 将程序的输出重定向到 output.dat 使用 seff 命令查看运行这个 Job 的资源使用情况，并将输出重定向到 seff.dat 注：李华不会使用 sbatch，所以你的程序是直接在登录节点上被执行的！\n提示 link 为了降低你的工作量，李华的程序会获取 Slurm Job ID 并输出至 job_id.dat 文件。 李华的程序不会输出至 stderr，只会输出至 stdout。 在 Shell 脚本中，将一个文件的内容作为命令参数的部分方式： 使用类似 command_name \"$(cat filename.dat)\" 的方式 使用类似 cat filename.dat | xargs command_name 的方式 "
            }
        );
    index.add(
            {
                id:  64 ,
                href: "\/TechDocs\/docs\/hpcgame\/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97%E7%AE%80%E4%BB%8B\/1c\/",
                title: "C. 小北问答超速版",
                description: "背景 link小 A 热衷于小北问答。但是小 A 觉得手工判卷太慢了。于是小 A 学会了 YAML 并试图实现自动评分。小 A 把它称作“小北问答·超速版”。他想要测试自己编写的自动评分系统正不正确，于是出了一套题，让你来帮忙试一试。\n据你所知，“超速”的含义是小 A 把这套自动评分程序运行于超算上。\n小 A 的题目 link TOP500中能效最高的超算是哪一台？（回答一个单词）\n戈登贝尔奖是并行计算领域的最高奖项，戈登贝尔奖设立在哪一年？（回答一个数字）\n一般来说，服务器使用的 CPU 相比于同代同等级的游戏 CPU，核心更 （ ）（填多 / 少），多核性能更（ ）（填强 / 弱）\n一般来说，服务器使用的 CPU 相比于同代同等级的游戏 CPU，单核最高频率更 （ ）（填高 / 低），因此起单核性能更 （ ）（填强 / 弱）\n5~7 题：对如下实现的矩阵乘法CN×N​=CN×N​+AN×N​BN×N​, 假设单位内存是1：（均填写含 N 的表达式，可以使用 +-*/ 运算符、小括号和 pow(a, b)，sqrt(n) 函数，等价形式均可）\n内存写策略是直写，全相联（块大小是1），替换策略是LRU。\nfor m in [1, N]: for n in [1,N]: for k in [1, N]: C[m,n] = C[m,n] + A[m, k] * B[k, n] 对矩阵A, B, C均进行了（ ）次读，对C进行了（ ）次写。",
                content: "背景 link小 A 热衷于小北问答。但是小 A 觉得手工判卷太慢了。于是小 A 学会了 YAML 并试图实现自动评分。小 A 把它称作“小北问答·超速版”。他想要测试自己编写的自动评分系统正不正确，于是出了一套题，让你来帮忙试一试。\n据你所知，“超速”的含义是小 A 把这套自动评分程序运行于超算上。\n小 A 的题目 link TOP500中能效最高的超算是哪一台？（回答一个单词）\n戈登贝尔奖是并行计算领域的最高奖项，戈登贝尔奖设立在哪一年？（回答一个数字）\n一般来说，服务器使用的 CPU 相比于同代同等级的游戏 CPU，核心更 （ ）（填多 / 少），多核性能更（ ）（填强 / 弱）\n一般来说，服务器使用的 CPU 相比于同代同等级的游戏 CPU，单核最高频率更 （ ）（填高 / 低），因此起单核性能更 （ ）（填强 / 弱）\n5~7 题：对如下实现的矩阵乘法CN×N​=CN×N​+AN×N​BN×N​, 假设单位内存是1：（均填写含 N 的表达式，可以使用 +-*/ 运算符、小括号和 pow(a, b)，sqrt(n) 函数，等价形式均可）\n内存写策略是直写，全相联（块大小是1），替换策略是LRU。\nfor m in [1, N]: for n in [1,N]: for k in [1, N]: C[m,n] = C[m,n] + A[m, k] * B[k, n] 对矩阵A, B, C均进行了（ ）次读，对C进行了（ ）次写。\n假设我们有一个有一级cache的处理器，cache大小为 3∗N2, 运算开始时A,B,C在内存中，结束后强制将cache写回内存（直写）。则会对内存进行（ ）次读运算，（ ）次写运算。\n第6题中，如果cache大小为2N+1, 则会对内存进行（ ）次读运算，（ ）次写运算。\nTOP500中，中国建造的超级计算机排行最高的是：（ ）\n天河二号采用（ ）、（ ）处理器，太湖之光采用（ ）处理器。 （填写选项）\nA. Xeon E5 B. Xeon Phi C. Xeon Platinum D. 申威众核\n中国人第一次获得戈登贝尔奖是（ ）年（填数字），相关论文第一作者是（ ）（填中文人名），作者现在在（ ）工作。\n提交格式 link你需要提交一个 YAML 文件，里面包含有这些题目的答案。\n例子：\nQ1: My Supercomputer Name Q2: 1700 Q3: B1: 多 B2: 强 Q4: B1: 高 B2: 强 Q5: B1: N B2: N Q6: B1: 2*N B2: N Q7: B1: (N+1)*N B2: N Q8: 我的超级计算机 Q9: B1: D B2: C B3: B Q10: B1: 1700 B2: 张三 B3: 家里蹲大学 请注意：这并不是一份正确答案。提交这份答案可能只能获得少得可怜的分数。\n注意：使用pow函数，第二个参数请传入一个浮点数（如：2.0），否则会报错！\n"
            }
        );
    index.add(
            {
                id:  65 ,
                href: "\/TechDocs\/docs\/hpcgame\/%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E7%AE%97%E7%AE%80%E4%BB%8B\/1d\/",
                title: "D. 简单题",
                description: "题面 linkHint: mmap写入空文件的处理方式：https://stackoverflow.com/questions/44553907/mmap-sigbus-error-and-initializing-the-file 不要惊慌。你没有看错，这就是一道简单题。 啊偶，虽然在某些比赛中，被标注为“简单题”的题目往往并不简单，但是在这场比赛中，我们确实试图提供一些简单题，以让大家能够更容易地获得更多分数。 你需要用 P 个核心，把 N 个 32 位有符号整数数组中所有元素 + 1，并且求原来（未加一）的数字之和(MOD 100001651)并输出。 输入 link从 input.bin 读入。这是一个二进制文件，用小端法储存储存，可以直接进行内存映射。（题目保证这些数字小于 230） 第一个参数是核心数 P ，表示当前程序运行平台的核心数。第二个参数是 N ，表示数据总数（在32位整数表示范围内）。 输出 link输出到 output.bin。也是一个二进制文件，建议直接内存映射写入。 第一个数字是求和取模的结果，后面的数字是修改后的数组。 提交 link提交一个 C++ 源程序即可。 编译命令： g++ -o solution solution.cpp -O1 -fopenmp -std=c++11 一个可能有用的数据生成器 link #!/usr/bin/php \u003c?php if ($argc != 4) { die(\"USAGE: {$argv[0]} \\n\"); } function i32_to_bytes(int $n): array { $rslt = []; for ($i = 0; $i \u003c 4; ++$i) { $rslt[] = $n \u0026 255; $n \u003e\u003e= 8; } return $rslt; } function bytes_to_string(array $n): string { $a = array_map(fn (int $num) =\u003e chr($num), $n); return join('', $a); } function i32_to_string(int $n): string { return bytes_to_string(i32_to_bytes($n)); } $f = fopen($argv[1], \"w\"); $p = (int) $argv[2]; $n = (1 \u003c\u003c ((int) trim($argv[3]))); $n += $n + rand(0, $n / 2); $part = 1; $n = floor($n / $part) * $part; echo \"p={$p}, n={$n}\" .",
                content: "题面 linkHint: mmap写入空文件的处理方式：https://stackoverflow.com/questions/44553907/mmap-sigbus-error-and-initializing-the-file\n不要惊慌。你没有看错，这就是一道简单题。\n啊偶，虽然在某些比赛中，被标注为“简单题”的题目往往并不简单，但是在这场比赛中，我们确实试图提供一些简单题，以让大家能够更容易地获得更多分数。\n你需要用 P 个核心，把 N 个 32 位有符号整数数组中所有元素 + 1，并且求原来（未加一）的数字之和(MOD 100001651)并输出。\n输入 link从 input.bin 读入。这是一个二进制文件，用小端法储存储存，可以直接进行内存映射。（题目保证这些数字小于 230）\n第一个参数是核心数 P ，表示当前程序运行平台的核心数。第二个参数是 N ，表示数据总数（在32位整数表示范围内）。\n输出 link输出到 output.bin。也是一个二进制文件，建议直接内存映射写入。\n第一个数字是求和取模的结果，后面的数字是修改后的数组。\n提交 link提交一个 C++ 源程序即可。\n编译命令：\ng++ -o solution solution.cpp -O1 -fopenmp -std=c++11 一个可能有用的数据生成器 link #!/usr/bin/php \u003c?php if ($argc != 4) { die(\"USAGE: {$argv[0]} \\n\"); } function i32_to_bytes(int $n): array { $rslt = []; for ($i = 0; $i \u003c 4; ++$i) { $rslt[] = $n \u0026 255; $n \u003e\u003e= 8; } return $rslt; } function bytes_to_string(array $n): string { $a = array_map(fn (int $num) =\u003e chr($num), $n); return join('', $a); } function i32_to_string(int $n): string { return bytes_to_string(i32_to_bytes($n)); } $f = fopen($argv[1], \"w\"); $p = (int) $argv[2]; $n = (1 \u003c\u003c ((int) trim($argv[3]))); $n += $n + rand(0, $n / 2); $part = 1; $n = floor($n / $part) * $part; echo \"p={$p}, n={$n}\" . PHP_EOL; fwrite($f, i32_to_string($p)); fwrite($f, i32_to_string($n)); for ($i = 0; $i \u003c ($n / $part); ++$i) { $m = i32_to_string(rand(0, 1 \u003c\u003c 30)); fwrite($f, $m); } fclose($f); 附件 link输入样例\n下载input1.bin\n"
            }
        );
    index.add(
            {
                id:  66 ,
                href: "\/TechDocs\/docs\/hpcgame\/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%A4%A7%E8%A7%84%E6%A8%A1\/",
                title: "2. 并行与大规模",
                description: "",
                content: ""
            }
        );
    index.add(
            {
                id:  67 ,
                href: "\/TechDocs\/docs\/hpcgame\/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%A4%A7%E8%A7%84%E6%A8%A1\/2a\/",
                title: "A. 求积分！",
                description: "题目 link小明对高等数学感到头疼。今天，他的作业里有一道计算积分的题目。他不知道自己的答案正不正确。他希望你能写一个程序，计算得越准确越好。由于他对于精度的要求非常高，又不希望等待程序运行花费太多时间，所以他将会把程序运行于超算上。你需要使得你编写的程序支持多线程处理从而提升处理速度。 小明遇到的题目转化为离散形式是这样的： 给定函数$f(x)$, 正整数 $N$, 计算 $I_N(f)$, 其中 $$ \\int_0^1 f(x)\\approx I_N(f)=\\frac{1}{N}\\sum_{i=1}^Nf(\\frac{x^i}{N})， x_i=i-\\frac{1}{2} $$ 小明听说有个叫 OpenMP 的东西，能方便地帮助你编写并行的应用程序。你决定试一试。 输入格式 link文件引用 rhs.h，该头文件定义了： void rhs(double \u0026x, double \u0026value); 即为提供的 f(x)。其中，x 将作为变量 x，函数将把 f(x) 函数值放入 value。 程序需要接收一个命令行参数，即为 N。 输出格式 link向文件 output.dat 中输出一个浮点数，通常可选择保留 12 位有效数字。与标准解答误差在 N⋅10−15 以内即算作正确。 样例数据 linkrhs.cpp #include #include \"rhs.h\" void rhs(double \u0026x, double \u0026value) { value = x; } rhs.h #ifndef _rhs_h_ #define _rhs_h_ void rhs(double \u0026, double \u0026); #endif 样例输入：1",
                content: "题目 link小明对高等数学感到头疼。今天，他的作业里有一道计算积分的题目。他不知道自己的答案正不正确。他希望你能写一个程序，计算得越准确越好。由于他对于精度的要求非常高，又不希望等待程序运行花费太多时间，所以他将会把程序运行于超算上。你需要使得你编写的程序支持多线程处理从而提升处理速度。\n小明遇到的题目转化为离散形式是这样的：\n给定函数$f(x)$, 正整数 $N$, 计算 $I_N(f)$, 其中\n$$ \\int_0^1 f(x)\\approx I_N(f)=\\frac{1}{N}\\sum_{i=1}^Nf(\\frac{x^i}{N})， x_i=i-\\frac{1}{2} $$\n小明听说有个叫 OpenMP 的东西，能方便地帮助你编写并行的应用程序。你决定试一试。\n输入格式 link文件引用 rhs.h，该头文件定义了：\nvoid rhs(double \u0026x, double \u0026value); 即为提供的 f(x)。其中，x 将作为变量 x，函数将把 f(x) 函数值放入 value。\n程序需要接收一个命令行参数，即为 N。\n输出格式 link向文件 output.dat 中输出一个浮点数，通常可选择保留 12 位有效数字。与标准解答误差在 N⋅10−15 以内即算作正确。\n样例数据 linkrhs.cpp\n#include #include \"rhs.h\" void rhs(double \u0026x, double \u0026value) { value = x; } rhs.h\n#ifndef _rhs_h_ #define _rhs_h_ void rhs(double \u0026, double \u0026); #endif 样例输入：1\n样例输出（output.dat）：0.500000000000000 （注：只需满足精度要求，对保留的小数位数不作硬性规定）\n请注意：在文件的结尾请添加一个空行（\\n）。有选手反馈不添加空行会导致 Wrong Answer。\n提交格式 link请提交一个 C++ 源码文件，我们将把它与 rhs.h 和 rhs.cpp 一同编译，编译参数为：（假设用户程序为 omp_cinte.cpp）\ng++ -O3 -Wall -std=c++17 omp_cinte.cpp rhs.cpp -fopenmp -lm -o omp_cinte 测试点说明 link本题一共设置 4 个测试点：\n编号 分值 时限 核心 1 10 16s 8 2 10 24s 8 3 20 36s 4 4 20 40s 8 同时，你需要确保你的程序足够并行，也即是说：你需要充分利用所给核心，否则可能出现 Not So Parallel 的结果，那样只能获得该测试点一半的分数。\n提示 link在https://www.bilibili.com/video/BV18M41187ZU可以看到高性能计算入门讲座（四）:openMP简介\n"
            }
        );
    index.add(
            {
                id:  68 ,
                href: "\/TechDocs\/docs\/hpcgame\/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%A4%A7%E8%A7%84%E6%A8%A1\/2b\/",
                title: "B. 乘一乘！",
                description: "题目 link小明对线性代数也感到头疼。今天，他的作业里有一道计算矩阵乘法的题目。他不知道自己的答案正不正确。他希望你能写一个程序，计算得越准确越好。由于他对于精度的要求非常高，又不希望等待程序运行花费太多时间，所以他将会把程序运行于超算上。你需要使得你编写的程序支持多线程处理从而提升处理速度。\n小明遇到的题目是这样的：\n给定矩阵 A,B, 满足 A 列数与 B 行数相等, 计算 AB.\n小明再次向你介绍有个叫 OpenMP 的东西，能方便地帮助你编写并行的应用程序。你向他表明你在帮助他完成数学分析作业的时候，已经熟练运用了 OpenMP，并希望他下次能问你一些物理问题。\n输入格式 link文件引用 rhs.h，该头文件定义了：\nvoid matA(unsigned int \u0026i, unsigned int \u0026j, double \u0026value); void matB(unsigned int \u0026i, unsigned int \u0026j, double \u0026value); 设矩阵 A 为 ${a_{ij}​}$ ，矩阵 B 为 ${b_{ij}​}$，那么调用这两个函数将分别给出矩阵 A 和 B 第 i 行第 j 列的元素的值。函数将把值放入 value。\n程序需要接收三个命令行参数，即为 N1, N2, N3，表示矩阵 A 是 N1*N2 维的，矩阵 B 是 N2*N3 维的。\n输出格式 link向文件 output.dat 中输出结果矩阵，每行一个浮点数，按如下方式排布：（以 3x3 矩阵为例）",
                content: "题目 link小明对线性代数也感到头疼。今天，他的作业里有一道计算矩阵乘法的题目。他不知道自己的答案正不正确。他希望你能写一个程序，计算得越准确越好。由于他对于精度的要求非常高，又不希望等待程序运行花费太多时间，所以他将会把程序运行于超算上。你需要使得你编写的程序支持多线程处理从而提升处理速度。\n小明遇到的题目是这样的：\n给定矩阵 A,B, 满足 A 列数与 B 行数相等, 计算 AB.\n小明再次向你介绍有个叫 OpenMP 的东西，能方便地帮助你编写并行的应用程序。你向他表明你在帮助他完成数学分析作业的时候，已经熟练运用了 OpenMP，并希望他下次能问你一些物理问题。\n输入格式 link文件引用 rhs.h，该头文件定义了：\nvoid matA(unsigned int \u0026i, unsigned int \u0026j, double \u0026value); void matB(unsigned int \u0026i, unsigned int \u0026j, double \u0026value); 设矩阵 A 为 ${a_{ij}​}$ ，矩阵 B 为 ${b_{ij}​}$，那么调用这两个函数将分别给出矩阵 A 和 B 第 i 行第 j 列的元素的值。函数将把值放入 value。\n程序需要接收三个命令行参数，即为 N1, N2, N3，表示矩阵 A 是 N1*N2 维的，矩阵 B 是 N2*N3 维的。\n输出格式 link向文件 output.dat 中输出结果矩阵，每行一个浮点数，按如下方式排布：（以 3x3 矩阵为例）\na00 a01 a02 a10 a11 a12 a20 a21 a22 一般保留 12 位有效数字即可（注意：已知问题：保留超过 12 位小数可能导致 Wrong Answer，我们的 N2 均足够大使得误差要求均不小于 10−12）。要求误差不超过 N2​⋅10−15。\n样例数据 linkrhs.cpp\n#include #include \"rhs.h\" void matA(unsigned int \u0026i, unsigned int \u0026j, double \u0026value) { value = std::sin(i + 2 * j); } void matB(unsigned int \u0026i, unsigned int \u0026j, double \u0026value) { value = std::cos(3 * i + j); } rhs.h\n#ifndef _rhs_h_ #define _rhs_h_ void matA(unsigned int \u0026, unsigned int \u0026, double \u0026); void matB(unsigned int \u0026, unsigned int \u0026, double \u0026); #endif 提交格式 link请提交一个 C++ 源码文件，我们将把它与 rhs.h 和 rhs.cpp 一同编译，编译参数为：（假设用户程序为 omp_cmul.cpp）\ng++ -O3 -Wall -std=c++17 omp_cmul.cpp rhs.cpp -fopenmp -lm -o omp_cmul 测试点说明 link本题一共设置 9 个测试点：\n编号 分值 时限 核心 0 10 6s 6 1 10 7s 7 2 10 11s 8 3 10 6s 8 4 10 7s 6 5 10 8s 8 6 10 6s 6 7 10 7s 8 8 10 12s 8 同时，你需要确保你的程序足够并行，也即是说：你需要充分利用所给核心，否则可能出现 Not So Parallel 的结果，那样只能获得该测试点一半的分数。\n"
            }
        );
    index.add(
            {
                id:  69 ,
                href: "\/TechDocs\/docs\/hpcgame\/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%A4%A7%E8%A7%84%E6%A8%A1\/2c\/",
                title: "C. 解方程！",
                description: "题目 link小明这回的确问了个“物理”些的问题。虽然依旧是一个数学问题。他还是希望你能编写一个程序，帮他解决这个问题。他依旧想把你的程序运行在超算上，并要求你的程序是并行的。\n给定函数 $f(x,y)$, 正整数 $N$, 在 $N×N$ 均匀网格上用五点格式求解 Poisson 方程\n$$ \\begin{cases} \u0026 -\\Delta u(x,y)=f(x,y),(x,y)\\in \\Omega = (0,1)^2 \\ \u0026 u(x,y)=0,(x,y)\\in \\partial \\Omega \\end{cases} $$\n记 $U_{i,j}$​ 为 $u(x_i,y_j​)$的近似值, 离散格式为\n$$ \\begin{aligned} \u00264U_{i,j}-U_{i-1,j}-U{i+1,j}-U_{i,j-1}-U{i,j+1}=\\frac{1}{N^2}f(x_i,y_i),x_i=\\frac{i}{N},y_i=\\frac{j}{N}\\ \u0026 U_{i,j}=0,(i=0)\\lor(i=N)\\lor(j=0)\\lor(j=N) \\end{aligned} $$\n用 Gauss-Seidel 迭代求解上述线性方程组。\n小明定义了一个量，名叫 EPS（各分量绝对值差最大值）。他希望你的程序能在 EPS 小于 10−15 后输出结果。\n你看着题目苦笑了一下。如你所料，小明总是念念不忘他的 OpenMP。\n输入格式 link文件引用 rhs.h，该头文件定义了：\nvoid rhs(double \u0026x, double \u0026y, double \u0026value); 该函数即为 f(x,y)。传入 x, y, value, 那么 f(x,y) 就会被保存到 value 内。\n程序需要接收一个命令行参数，即为 N。",
                content: "题目 link小明这回的确问了个“物理”些的问题。虽然依旧是一个数学问题。他还是希望你能编写一个程序，帮他解决这个问题。他依旧想把你的程序运行在超算上，并要求你的程序是并行的。\n给定函数 $f(x,y)$, 正整数 $N$, 在 $N×N$ 均匀网格上用五点格式求解 Poisson 方程\n$$ \\begin{cases} \u0026 -\\Delta u(x,y)=f(x,y),(x,y)\\in \\Omega = (0,1)^2 \\ \u0026 u(x,y)=0,(x,y)\\in \\partial \\Omega \\end{cases} $$\n记 $U_{i,j}$​ 为 $u(x_i,y_j​)$的近似值, 离散格式为\n$$ \\begin{aligned} \u00264U_{i,j}-U_{i-1,j}-U{i+1,j}-U_{i,j-1}-U{i,j+1}=\\frac{1}{N^2}f(x_i,y_i),x_i=\\frac{i}{N},y_i=\\frac{j}{N}\\ \u0026 U_{i,j}=0,(i=0)\\lor(i=N)\\lor(j=0)\\lor(j=N) \\end{aligned} $$\n用 Gauss-Seidel 迭代求解上述线性方程组。\n小明定义了一个量，名叫 EPS（各分量绝对值差最大值）。他希望你的程序能在 EPS 小于 10−15 后输出结果。\n你看着题目苦笑了一下。如你所料，小明总是念念不忘他的 OpenMP。\n输入格式 link文件引用 rhs.h，该头文件定义了：\nvoid rhs(double \u0026x, double \u0026y, double \u0026value); 该函数即为 f(x,y)。传入 x, y, value, 那么 f(x,y) 就会被保存到 value 内。\n程序需要接收一个命令行参数，即为 N。\n输出格式 link每行一个浮点数，依次输出 U0,0​, U0,1​, …, U0,n​, U1,0​, U1,1​, …, Un,n​。通常保留 12 位有效数字即可。当然，我们只会检查误差大小，并不严格要求保留的小数位数。\n如果误差超过 10−10，那么该测试点将获得 0 分。误差在 10−10 范围之内的，误差越小，得分越高；误差在 10−11 范围以内的，有机会获得该测试点的全部分数。\n样例 linkrhs.cpp\n#include #include \"rhs.h\" #define PI25DT 3.141592653589793238462643 #define doublePIsquare 19.73920880217871723766898 void rhs(double \u0026x, double \u0026y, double \u0026value) { value = doublePIsquare * std::sin(PI25DT * x) * std::sin(PI25DT * y); } rhs.h\n#ifndef _rhs_h_ #define _rhs_h_ void rhs(double \u0026, double \u0026, double \u0026); #endif 我们输入的 N 大约在几十的范围内。\n测试点说明 link本题一共设置 6 个测试点：\n编号 分值 时限 核心 0 10 4s 8 1 20 6s 8 2 20 6s 8 3 20 9s 8 4 20 6s 8 5 30 15s 8 同时，你需要确保你的程序足够并行，也即是说：你需要充分利用所给核心，否则可能出现 Not So Parallel 的结果，那样只能获得该测试点原本得分一半的分数。\n"
            }
        );
    index.add(
            {
                id:  70 ,
                href: "\/TechDocs\/docs\/hpcgame\/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%A4%A7%E8%A7%84%E6%A8%A1\/2d\/",
                title: "D. 道生一",
                description: "题面 link道生一，一生二，二生三，三生万物。 我们给你选择了三个“魔力数字”genA, genB, genC，请你使用这三个数生成n个“随从数字”并排序，得到data数组。经过对data数组的计算，你会得到一个归一数，把这个数输出到标准输出即可。 （本题中的所有数字都是64位无符号整数。） 输入 link从标准输入中读入四个数字，分别是genA, genB, genC,n 。 输出 link输出一个归一数到标准输出，生成方式见下文。 数据生成与测试 link #define data_t unsigned long long /*data数组的生成的示意代码如下：*/ data_t gen_next(){ gen_A ^= gen_A \u003c\u003c 31; gen_A ^= gen_A \u003e\u003e 17; gen_B ^= gen_B \u003c\u003c 13; gen_B ^= gen_B \u003e\u003e 5; gen_C ++; gen_A ^=gen_B; gen_B ^= gen_C; return gen_A; } void data_init(){ scanf(\"%llu%llu%llu%llu\", \u0026gen_A, \u0026gen_B, \u0026gen_C, \u0026n); a = (data_t *) malloc(sizeof(data_t) * n); for (data_t i = 0 ; i \u003c n; i ++) { a[i] = gen_next(); } } /*归一数的计算方式如下：*/ data_t get_res(data_t *a,data_t n){ for (data_t i = 0,tmp; i \u003c n; i ++) for (data_t j = 0; j \u003c n - 1 - i; j ++) { if (a[j] \u003e a[j + 1]) { tmp = a[j]; a[j] = a[j+1]; a[j+1] = tmp; } } data_t res = 0; for (data_t i = 0; i \u003c n; i ++) { res ^= i * a[i]; } return res; } #undef data_t 其中i * a[i]的溢出处理方式是低64位截断。",
                content: "题面 link道生一，一生二，二生三，三生万物。\n我们给你选择了三个“魔力数字”genA, genB, genC，请你使用这三个数生成n个“随从数字”并排序，得到data数组。经过对data数组的计算，你会得到一个归一数，把这个数输出到标准输出即可。 （本题中的所有数字都是64位无符号整数。）\n输入 link从标准输入中读入四个数字，分别是genA, genB, genC,n 。\n输出 link输出一个归一数到标准输出，生成方式见下文。\n数据生成与测试 link #define data_t unsigned long long /*data数组的生成的示意代码如下：*/ data_t gen_next(){ gen_A ^= gen_A \u003c\u003c 31; gen_A ^= gen_A \u003e\u003e 17; gen_B ^= gen_B \u003c\u003c 13; gen_B ^= gen_B \u003e\u003e 5; gen_C ++; gen_A ^=gen_B; gen_B ^= gen_C; return gen_A; } void data_init(){ scanf(\"%llu%llu%llu%llu\", \u0026gen_A, \u0026gen_B, \u0026gen_C, \u0026n); a = (data_t *) malloc(sizeof(data_t) * n); for (data_t i = 0 ; i \u003c n; i ++) { a[i] = gen_next(); } } /*归一数的计算方式如下：*/ data_t get_res(data_t *a,data_t n){ for (data_t i = 0,tmp; i \u003c n; i ++) for (data_t j = 0; j \u003c n - 1 - i; j ++) { if (a[j] \u003e a[j + 1]) { tmp = a[j]; a[j] = a[j+1]; a[j+1] = tmp; } } data_t res = 0; for (data_t i = 0; i \u003c n; i ++) { res ^= i * a[i]; } return res; } #undef data_t 其中i * a[i]的溢出处理方式是低64位截断。\n评测说明 link评测提供8个CPU核心，32G内存。\n本题共两个测试点，分别为 80 分和 120 分，都会根据您程序运行的时间给出最终得分。程序运行越快，得分越高。其中第一个数据点用时 9.8s 以内开始得分，0.45s 满分；第二个数据点 53.0s 以内开始得分，3.0s 满分。这个标准是依照题给例程和组委会已知的最优优化给出的。\n提示与说明 link 除了打表和攻击比赛平台等不正当的方式，你可以使用任何优化方式 。不仅仅是排序部分，数据生成和最后生成res过程或许都能优化，正确性角度只要得到的归一数正确即可。\n本题的提交方式是，将二进制文件解答文件（统一命名为 answer，请编译到 linux-x86_64 （有时也称 amd64））和代码、编译脚本一起打包为压缩包提交（请注意：answer应放置在压缩包根目录，而非任何子目录下；否则评测时无法识别），平台直接调用二进制文件进行评测。对于所有获奖选手，我们会逐一对代码进行审核、编译。如不一致且不能说明原因，将按照违规取消本题成绩，并对其他题目严格审查。\n本题还是有梯度的，可以拿挺多部分分，have fun!\n如果你的评测结果是 Internal Error，并且报错 exit status 126，请你检查你是否将 answer 程序放置在了解答压缩包的根目录（注意：不应该在某个子文件夹内）！\n参考资料 Diverting LSD sort – Axelle\n"
            }
        );
    index.add(
            {
                id:  71 ,
                href: "\/TechDocs\/docs\/hpcgame\/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%A4%A7%E8%A7%84%E6%A8%A1\/2e\/",
                title: "E. 卷？寄！",
                description: "背景 link二维卷积是卷积神经网络的基础操作，可以提取数据特征，在图像识别领域应用广泛。卷积的复杂度导致训练困难，也是图像识别领域的重要瓶颈之一。\n对卷积感兴趣的同学，可以去翻一翻 Ian Goodfellow 等人写的Deep Learning的第9章。我们只引用书中的一张图介绍卷积的计算。\n对于矩阵Input，我们使用一个比它规模小的多的Kernel进行运算。本题我们方法大概是这样：\n设Input是A∗B矩阵，Kernel是C∗D矩阵，对于每个位置(i, j)，如果可以取一个和Kernel大小一样的不越界矩阵(本题不考虑padding)，我们就把这个矩阵中与Kernel中对应元素乘起来并求和，结果放在Output(i,j)​中。\n$$ \\begin{bmatrix} I_{(i,j)} \u0026 I_{(i,j)} \u0026 \\cdots \u0026 I_{(i,j+D)} \\ I_{(i+1,j)} \u0026 I_{(i+1,j+2)} \u0026 \\cdots \u0026 I_{(i+1,j+D)} \\ \\cdots \u0026 \\cdots \u0026 \\cdots \u0026 \\cdots \\ I_{(i+C,j)} \u0026 I_{(i+C,j+2)} \u0026 \\cdots \u0026 I_{(i+C,j+D)} \\ \\end{bmatrix} $$\n计算完所有可算的i, j，我们就得到了卷积的输出。\n$$ Output_{(i,j)}=\\sum_{p=0}^{C-1} \\sum_{q=0}^{D-1} Input_{(i+p,j+q)} * Kernel_{(p,q)} $$\n下图引自Ian Goodfellow 等人著作Deep Learning`，很形象地表现了这一过程。因为元素运算是可向量化的，我们试图在CPU上使用SIMD（单指令多数据）的方法，优化二维卷积运算。\n要怎么做才好呢 link要不，问问chatGPT？\n他说的确实对，向量化的思路没错，但是我们不打算给你太多的核心，所以你得让每一条指令都能操作多个数据。\n硬件条件 link评测平台的CPU是Intel® Xeon® Platinum 8358，关闭超线程。\n每次评测分配1CPU核心，4G内存。\nCPU相关参数如下：\n32K数据L1缓存，1.25MB L2缓存。",
                content: "背景 link二维卷积是卷积神经网络的基础操作，可以提取数据特征，在图像识别领域应用广泛。卷积的复杂度导致训练困难，也是图像识别领域的重要瓶颈之一。\n对卷积感兴趣的同学，可以去翻一翻 Ian Goodfellow 等人写的Deep Learning的第9章。我们只引用书中的一张图介绍卷积的计算。\n对于矩阵Input，我们使用一个比它规模小的多的Kernel进行运算。本题我们方法大概是这样：\n设Input是A∗B矩阵，Kernel是C∗D矩阵，对于每个位置(i, j)，如果可以取一个和Kernel大小一样的不越界矩阵(本题不考虑padding)，我们就把这个矩阵中与Kernel中对应元素乘起来并求和，结果放在Output(i,j)​中。\n$$ \\begin{bmatrix} I_{(i,j)} \u0026 I_{(i,j)} \u0026 \\cdots \u0026 I_{(i,j+D)} \\ I_{(i+1,j)} \u0026 I_{(i+1,j+2)} \u0026 \\cdots \u0026 I_{(i+1,j+D)} \\ \\cdots \u0026 \\cdots \u0026 \\cdots \u0026 \\cdots \\ I_{(i+C,j)} \u0026 I_{(i+C,j+2)} \u0026 \\cdots \u0026 I_{(i+C,j+D)} \\ \\end{bmatrix} $$\n计算完所有可算的i, j，我们就得到了卷积的输出。\n$$ Output_{(i,j)}=\\sum_{p=0}^{C-1} \\sum_{q=0}^{D-1} Input_{(i+p,j+q)} * Kernel_{(p,q)} $$\n下图引自Ian Goodfellow 等人著作Deep Learning`，很形象地表现了这一过程。因为元素运算是可向量化的，我们试图在CPU上使用SIMD（单指令多数据）的方法，优化二维卷积运算。\n要怎么做才好呢 link要不，问问chatGPT？\n他说的确实对，向量化的思路没错，但是我们不打算给你太多的核心，所以你得让每一条指令都能操作多个数据。\n硬件条件 link评测平台的CPU是Intel® Xeon® Platinum 8358，关闭超线程。\n每次评测分配1CPU核心，4G内存。\nCPU相关参数如下：\n32K数据L1缓存，1.25MB L2缓存。\n指令集扩展：Intel® SSE4.2, Intel® AVX, Intel® AVX2, Intel® AVX-512\n评分标准 link出题人很讲武德，你只要跑得比chatGPT指导他写的Python程序快就行了。不过，出题人使用了Intel编译的加速优化后的Python和numpy，所以你大概要写C++才能拿到看起来比较多的分数。\n对于性能评测，每个测试点15分，max(0,min((T(出题人程序)/T(你的程序)−0.8)/2∗15,15))就是你的得分。\n提交说明 link我们下发的包是一个cmake工程的骨架。改里面的answer.cpp就行。\n编译方式：运行compile.sh。\n提交方式：直接提交answer.cpp。如果您需要使用其他语言，请与我们联系hpcgame@pku.edu.cn。\n输入与输出说明 link本题所有数字均为单精度浮点数，允许的浮点误差是1∗10−5\n输入文件： link从input.txt读入Input，第一个数字是行数N，第二个数字是列数M。后面是N行数据，每一行M个数字。\n从weight.txt读入Kernel，第一个数字是C，第二个数字是D。后面是C行数据，每一行D个数字。\n输出文件： link把你得到的Output输出到output.txt，第一个数字是行数P，第二个数字是列数Q，后面有P行，每行Q个数字。\n一些提示 link 输入的卷积核边长是16的倍数，因为AVX512每次可以操作16个float 没有padding！16∗16的矩阵和2∗2的Kernel输出会是15∗15的 建议多注意数据对齐的问题，64 bytes对齐可能会是比较好的选择，可以参考Intel的这篇文章。评测使用C++ 17标准，其中aligned_alloc挺适合完成这个工作的。 请关注缓存命中的问题，比较影响性能。 零基础友好部分 link 附件有ETH的介绍SIMD的slides，里面例子很多，强烈推荐。 xsimd这个C++wraper挺好用的，所以我们帮你预装好了。 Intel的手册是重要资料，在这里。 知乎上有个中文教程，我们觉得还不错。 测试数据规模 link 数据点 Input Kernel 分值（给分方式） 0 512x1024 64x64 15（性能评测） 1 512x1024 32x32 15（性能评测） 2 512x1024 16x16 15（性能评测） 3 2048x2048 64x64 15（性能评测） 4 2048x2048 32x32 15（性能评测） 5 2048x2048 16x16 15（性能评测） 6 1024x2048 64x64 15（性能评测） 7 1024x2048 32x32 15（性能评测） 8 1024x2048 16x16 15（性能评测） 9 1024x1024 64x64 15（性能评测） 10 1024x1024 32x32 15（性能评测） 11 1024x1024 16x16 15（性能评测） 12 4096x4096 16x16 10（不超时即可） 13 4096x4096 32x32 10（不超时即可） 附件 link初始工作区\n下载convolution_handout.tar.gz\nZTH SIMD教程\n下载zth_simd.pdf\n输入输出样例\n下载sample_data.zip\n"
            }
        );
    index.add(
            {
                id:  72 ,
                href: "\/TechDocs\/docs\/hpcgame\/%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%A4%A7%E8%A7%84%E6%A8%A1\/2f\/",
                title: "F. MPI算个PI",
                description: "MPI 算个 PI link前情提要 link本题是简单题，不想读背景的大佬请直接跳到题目要求。 背景 link几乎从人类数学诞生以来，一代代数学家就在试图提高圆周率π的数值精度。从五千年前的1位精度提升到当下世界纪录的100万亿位，π的计算方法从粗略估计、测量估算，再到公式逼近、机器演算，我们可以从中看到人类科技的发展史。 \u003c?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?\u003e \u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e Record pi approximations Produced by GNUPLOT 4.6 patchlevel 0 1 100 104 106 108 1010 1012 1014 2000 BCE 250 BCE 480 1400 1450 1500 1550 1600 1650 1700 1750 1800 1850 1900 1950 2000 Number of decimal digits Year Record approximations of pi gnuplot_plot_1 当下，π的计算还是衡量高性能计算集群性能和算法优越性的重要量度，问题的维度从单纯的计算，拓展到了储存、通信、内存瓶颈等方方面面，各路超算纷纷借此机会大秀肌肉。 但是在这一系列浩浩汤汤的计算过程中，有一小群人，在个人电脑刚刚普及的年代，却凭借着合作的力量，通过众包计算的方法，也达到了可喜的成就。其中一个项目是，通过分布式的方法，计算出了π中特殊位置数字的PiHex。在个人算力不足的年代，这可谓是工程学奇迹。 现在我们假设你有一些算力不是很强的机器，来模拟这个场景。 题目要求 link你有5个物理节点，每个的节点2个核心。你需要写一个MPI程序，计算π的近似值，精确到1∗10−14（15位有效数字）。 因为MPI开销比较大，本题时间限制为30秒，不考察效率。（其实就是想让大家试一试MPI) 请注意，我们的平台关闭了超线程，但是直接由MPI生成的线程数可能会是打开超线程后的。",
                content: "MPI 算个 PI link前情提要 link本题是简单题，不想读背景的大佬请直接跳到题目要求。\n背景 link几乎从人类数学诞生以来，一代代数学家就在试图提高圆周率π的数值精度。从五千年前的1位精度提升到当下世界纪录的100万亿位，π的计算方法从粗略估计、测量估算，再到公式逼近、机器演算，我们可以从中看到人类科技的发展史。\n\u003c?xml version=\"1.0\" encoding=\"utf-8\" standalone=\"no\"?\u003e \u003c!DOCTYPE svg PUBLIC \"-//W3C//DTD SVG 1.1//EN\" \"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\"\u003e Record pi approximations Produced by GNUPLOT 4.6 patchlevel 0 1 100 104 106 108 1010 1012 1014 2000 BCE 250 BCE 480 1400 1450 1500 1550 1600 1650 1700 1750 1800 1850 1900 1950 2000 Number of decimal digits Year Record approximations of pi gnuplot_plot_1 当下，π的计算还是衡量高性能计算集群性能和算法优越性的重要量度，问题的维度从单纯的计算，拓展到了储存、通信、内存瓶颈等方方面面，各路超算纷纷借此机会大秀肌肉。\n但是在这一系列浩浩汤汤的计算过程中，有一小群人，在个人电脑刚刚普及的年代，却凭借着合作的力量，通过众包计算的方法，也达到了可喜的成就。其中一个项目是，通过分布式的方法，计算出了π中特殊位置数字的PiHex。在个人算力不足的年代，这可谓是工程学奇迹。\n现在我们假设你有一些算力不是很强的机器，来模拟这个场景。\n题目要求 link你有5个物理节点，每个的节点2个核心。你需要写一个MPI程序，计算π的近似值，精确到1∗10−14（15位有效数字）。\n因为MPI开销比较大，本题时间限制为30秒，不考察效率。（其实就是想让大家试一试MPI)\n请注意，我们的平台关闭了超线程，但是直接由MPI生成的线程数可能会是打开超线程后的。\n输入输出 link输入：无\n输出：一个双精度浮点数，保留15位有效数字。输出到output.txt即可。如果只有13位有效数字，则得一半分。\n编译命令 link（运行mpi.tar中的compile.sh即可）\nmodule load mpi/2021.8.0 mpicc cpi.c -lm -o cpi 运行命令 link（运行mpi.tar中的run.sh即可）\nsalloc -p compute -N5 --ntasks-per-node=2 -c 1 -q normal module load mpi/2021.8.0 srun -c 1 hostname -s | sort -n \u003e slurm.hosts mpirun -np 10 -machinefile slurm.hosts ./cpi 评分细节 link请不要使用直接打表的方法，否则本题零分。我们会进行人工核验。毕竟这样一个程序并不难写，何乐而不为呢。\n参考计算方法 link（也可以用其他方法，下面这个方法精度不算很高）\n（引自北京大学，杨超，并行与分布式计算基础)\n参考资料 linkMPI讲座：https://www.bilibili.com/video/BV13v4y1v7y7\n附件 link初始工作区\n下载mpi.tar\n"
            }
        );
    index.add(
            {
                id:  73 ,
                href: "\/TechDocs\/docs\/hpcgame\/gpu%E4%B8%8A%E7%9A%84%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97\/",
                title: "3. GPU上的并行计算",
                description: "",
                content: ""
            }
        );
    index.add(
            {
                id:  74 ,
                href: "\/TechDocs\/docs\/hpcgame\/gpu%E4%B8%8A%E7%9A%84%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97\/3a\/",
                title: "A. 从头开始造AI",
                description: "Section 1 Can you train a simple neural network using Pytorch? linkIn this section, you need to complete the code of Pytorch.ipynb. You can see more tutorials and details in the file. We will check the completion and correctness of your code in this section.\nSection 2 Can you differentiate a weed from a crop seedling? linkWith the network training experience, we can solve a lot of interesting problems and let’s try one of them in this section.",
                content: "Section 1 Can you train a simple neural network using Pytorch? linkIn this section, you need to complete the code of Pytorch.ipynb. You can see more tutorials and details in the file. We will check the completion and correctness of your code in this section.\nSection 2 Can you differentiate a weed from a crop seedling? linkWith the network training experience, we can solve a lot of interesting problems and let’s try one of them in this section.\nThe ability to do so effectively can mean better crop yields and better stewardship of the environment.\nThe Aarhus University Signal Processing group, in collaboration with University of Southern Denmark, has recently released a dataset containing images of approximately 960 unique plants belonging to 12 species at several growth stages.\nFig1: Some examples of seedlings.\nWe’re hosting this dataset as a problem in order to give it wider exposure, to give the community an opportunity to experiment with different image recognition techniques, as well to provide a place to cross-pollenate ideas.\nDataset Description linkYou are provided with a training set and a test set of images of plant seedlings at various stages of grown. Each image has a filename that is its unique id. The dataset comprises 12 plant species. The goal of the competition is to create a classifier capable of determining a plant’s species from a photo. The list of species is as follows:\nBlack-grass Charlock Cleavers Common Chickweed Common wheat Fat Hen Loose Silky-bent Maize Scentless Mayweed Shepherds Purse Small-flowered Cranesbill Sugar beet You need to organize the dataset in a proper way for your network training. In your network training, you need to use some training data to train your model and use some validation data to evaluate the performance of your model and choose the best checkpoint with the best classification accuracy. For more information of the dataset, you can load the images and check it by yourself.\nNetwork Training linkYou need to write your own code and finish the network training. You can use your previous knowledge or what you learned from the first section to improve the performance of your model. And some potential tricks include:\nbetter model architecture data augmentation batch norm dropout different activation functions The final grade will be determined by the test results on an unseen test dataset. However, rest assured that the test results are consistent with the same distribution as our dataset and will be roughly similar to the performance of our validation dataset. We will also eventually check and deduct points if the code implementation is more problematic, e.g., if the checkpoint obtained is not possible to obtain from the implemented code\nYou need to submit your prediction result in the same format as the example submission file, sample_submission.csv. We will give your model’s accuracy and a corresponding score for this problem.\nUseful materials link pytorch tutorial pytorch cheat sheet (see in attachments) Acknowledgments linkWe extend our appreciation to the Aarhus University Department of Engineering Signal Processing Group for hosting the original data and we also refer to some tutorials from Stanford University.\nCitation linkA Public Image Database for Benchmark of Plant Seedling Classification Algorithms\nKaggle Competition\ncs231n course, Stanford University\n========== 编者注 ==========\n任务说明 linkSection1 给与大家充分的学习和热身，在简单数据集合上实现ai训练，并给与了充分的代码和指导。Section2 旨在考验利用Section1的训练经验自己实现整个ai训练的任务，所以需要大家自己组织已给数据集，将其划分为自己认为合适的集合和格式，自己设计模型书写代码完成训练。\n如何提交 link提交一个压缩包，其中包括两个文件和一个文件夹。\n文件： link result：第一部分的训练结果，通过save_result(model, loader_test)生成 submission.csv：识别/data/shared/plant-seedling/中文件的结果，保存为csv格式，格式可参考sample_submission.csv，其中第一行将被忽略。 文件夹 link code：包括你的ipynb文件，Section2代码和一切有必要的说明文件 测试方法 linkresult ：按正确率给分，代码如下 link if accuracy \u003e= 0.9: score = 80 elif acc \u003e= 0.7: score = math.ceil(80 * (acc - 0.7) / 0.2) else: score = 0 submission.csv link数据共240行，第一行将被省略\ncorrect_num = check_correct() score = min(100, ceil(100.0/240*(correct_num * 1.1))) 附件 link初始工作区\n下载aiIntro.zip\n"
            }
        );
    index.add(
            {
                id:  75 ,
                href: "\/TechDocs\/docs\/hpcgame\/gpu%E4%B8%8A%E7%9A%84%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97\/3b\/",
                title: "B. 神奇的焦散",
                description: "任务背景 link焦散是光线经过透明物体后在某些位置汇聚形成的图案，因为其空间频率远高于单纯漫反射下的明暗，在渲染时需要较大的计算量。考虑一个简单的场景，一束方形截面的平行单色光经过若干方向玻璃板照在方形屏幕上。在这个场景中，只需要采样平行光最终到达屏幕的位置，即可得到焦散图案。 物理模型 link这里我们假设玻璃板会让经过的光线发生不均匀的相位落后，从而向不同方向折射，为了简化计算，忽略玻璃板的厚度。相位落后由多个定义在半径为r的圆形区域内的，最大值为d的旋转对称模板函数相加。 模板函数具有如下形式 $$ f(t=\\frac{\\sqrt{x^2 + y ^2}}{r})=d * exp(-\\frac{4t^2}{1-t^2}) $$ 样例程序中包含计算模板函数梯度的部分，可以根据自己的需要修改。 输入与输出 link题目数据量较大，因此将使用读写二进制文件的输入输出方式。处理输入输出的代码已经包含在样例程序中，可以根据自己的需要修改。 任务目标 link你需要适当修改提供的在cpu上进行计算的样例程序，使其运行在gpu上。如果你直接提交样例程序虽然能够获得正确的结果但会运行相当长的时间。样例程序中会包含一个没用的kernel，用于证明这个程序确实在gpu上运行了。 务必确保全程使用单精度浮点计算，允许的误差仅考虑到GPU与CPU浮点运算差异，单双精度浮点差别远大于此。 有用的信息 linkr在0.05到0.10的范围内随机分布 模板函数中心位置在方形区域内随机分布 可以使用int atomicAdd(int* address, int val);进行计数。 编译命令nvcc -O3 运行在单核，八分之一个A100上 共两个测试点： 测试点 ID 玻璃板数量 每个玻璃板上的模板函数数量 采样数量 输出像素 分值 0 2 256 4096*4096 256*256 10 1 32 256 16384*16384 1024*1024 190 附件中提供一份输入文件，可以用于本地调试。 评分标准 link如果能在目标时间内得到正确的焦散图案可以得到基本分。 运行时间越短得到的附加分越高。 样例程序 link #include #include #include #include struct lens_t { float x, y, r, d; }; struct pane_t { int panecount; float* panepos; int* lensindex; lens_t* lensdata; }; struct result_t { int raydensity; int sensordensity; int* sensordata; }; __global__ void ker_test(float* x, int n) { int i = blockDim.",
                content: "任务背景 link焦散是光线经过透明物体后在某些位置汇聚形成的图案，因为其空间频率远高于单纯漫反射下的明暗，在渲染时需要较大的计算量。考虑一个简单的场景，一束方形截面的平行单色光经过若干方向玻璃板照在方形屏幕上。在这个场景中，只需要采样平行光最终到达屏幕的位置，即可得到焦散图案。\n物理模型 link这里我们假设玻璃板会让经过的光线发生不均匀的相位落后，从而向不同方向折射，为了简化计算，忽略玻璃板的厚度。相位落后由多个定义在半径为r的圆形区域内的，最大值为d的旋转对称模板函数相加。 模板函数具有如下形式\n$$ f(t=\\frac{\\sqrt{x^2 + y ^2}}{r})=d * exp(-\\frac{4t^2}{1-t^2}) $$\n样例程序中包含计算模板函数梯度的部分，可以根据自己的需要修改。\n输入与输出 link题目数据量较大，因此将使用读写二进制文件的输入输出方式。处理输入输出的代码已经包含在样例程序中，可以根据自己的需要修改。\n任务目标 link你需要适当修改提供的在cpu上进行计算的样例程序，使其运行在gpu上。如果你直接提交样例程序虽然能够获得正确的结果但会运行相当长的时间。样例程序中会包含一个没用的kernel，用于证明这个程序确实在gpu上运行了。\n务必确保全程使用单精度浮点计算，允许的误差仅考虑到GPU与CPU浮点运算差异，单双精度浮点差别远大于此。\n有用的信息 linkr在0.05到0.10的范围内随机分布\n模板函数中心位置在方形区域内随机分布\n可以使用int atomicAdd(int* address, int val);进行计数。\n编译命令nvcc -O3\n运行在单核，八分之一个A100上\n共两个测试点：\n测试点 ID 玻璃板数量 每个玻璃板上的模板函数数量 采样数量 输出像素 分值 0 2 256 4096*4096 256*256 10 1 32 256 16384*16384 1024*1024 190 附件中提供一份输入文件，可以用于本地调试。\n评分标准 link如果能在目标时间内得到正确的焦散图案可以得到基本分。\n运行时间越短得到的附加分越高。\n样例程序 link #include #include #include #include struct lens_t { float x, y, r, d; }; struct pane_t { int panecount; float* panepos; int* lensindex; lens_t* lensdata; }; struct result_t { int raydensity; int sensordensity; int* sensordata; }; __global__ void ker_test(float* x, int n) { int i = blockDim.x * blockIdx.x + threadIdx.x; if (i \u003c n) { x[i] = i * i; printf(\"%f\\n\", x[i]); } } int cuinit() { float* temp; cudaMalloc(\u0026temp, 128); ker_test \u003c\u003c \u003c1, 32 \u003e\u003e \u003e (temp, 32); cudaFree(temp); return 0; } int causcal(pane_t pane, result_t result) { memset(result.sensordata, 0, result.sensordensity * result.sensordensity * sizeof(int)); float rs = 1.0f / result.raydensity; for (int i = 0; i \u003c result.raydensity; i++) { for (int j = 0; j \u003c result.raydensity; j++) { float x, y, z, kx, ky, invkz; y = (i + 0.5f) * rs; x = (j + 0.5f) * rs; z = 0.0f; kx = 0.0f; ky = 0.0f; invkz = 1.0f; for (int k = 0; k \u003c pane.panecount; k++) { x += (pane.panepos[k] - z) * kx * invkz; y += (pane.panepos[k] - z) * ky * invkz; if (x \u003c= 0.0f || x \u003e= 1.0f || y \u003c= 0.0f || y \u003e= 1.0f) { goto next; } z = pane.panepos[k]; float gx = 0.0f, gy = 0.0f; float rx, ry; int is = pane.lensindex[k]; int ie = pane.lensindex[k + 1]; for (int l = is; l \u003c ie; l++) { rx = x - pane.lensdata[l].x; ry = y - pane.lensdata[l].y; float r = rx * rx + ry * ry; float invr02 = pane.lensdata[l].r * pane.lensdata[l].r; if (r \u003c invr02 * 0.99999f) { invr02 = 1.0f / invr02; r = r * invr02; r = 4.0f / (1.0f - r); r = -0.5f * exp(4.0f - r) * r * r * invr02 * pane.lensdata[l].d; gx += r * rx; gy += r * ry; } } kx += gx; ky += gy; float kp = kx * kx + ky * ky; if (kp \u003e= 1.0f) { goto next; } invkz = 1.0f / sqrt(1.0f - kp); } x += (1.0f - z) * kx * invkz; y += (1.0f - z) * ky * invkz; if (x \u003e 0.0f \u0026\u0026 x \u003c 1.0f \u0026\u0026 y \u003e 0.0f \u0026\u0026 y \u003c 1.0f) { int pixelindex = int(x * result.sensordensity) + result.sensordensity * int(y * result.sensordensity); result.sensordata[pixelindex]++; } next: ; } } return 0; } int loadconf(const char* fn, pane_t\u0026 pane, result_t\u0026 result) { size_t n; FILE* fi; if (fi = fopen(fn, \"rb\")) { n = fread(\u0026result.raydensity, 4, 1, fi); n = fread(\u0026result.sensordensity, 4, 1, fi); result.sensordata = (int*)malloc(result.sensordensity * result.sensordensity * sizeof(int)); n = fread(\u0026pane.panecount, 4, 1, fi); pane.panepos = (float*)malloc(pane.panecount * sizeof(float)); n = fread(pane.panepos, 4, pane.panecount, fi); pane.lensindex = (int*)malloc((pane.panecount + 1) * sizeof(int)); n = fread(pane.lensindex, 4, pane.panecount + 1, fi); pane.lensdata = (lens_t*)malloc(pane.lensindex[pane.panecount] * sizeof(lens_t)); n = fread(pane.lensdata, 16, pane.lensindex[pane.panecount], fi); fclose(fi); } printf(\"%lu\\n\", n); return 0; } int main() { result_t result; pane_t pane; loadconf(\"./conf.data\", pane, result); causcal(pane, result); FILE* fi; if (fi=fopen(\"./out.data\", \"wb\")) { fwrite(result.sensordata, 1, result.sensordensity * result.sensordensity * sizeof(int), fi); fclose(fi); } return 0; } 附件 link初始工作区\n下载caustics_conf0.data\n"
            }
        );
    index.add(
            {
                id:  76 ,
                href: "\/TechDocs\/docs\/hpcgame\/gpu%E4%B8%8A%E7%9A%84%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97\/3c\/",
                title: "C. cuFFT并非不可战胜！",
                description: "背景介绍 link密度泛函理论（Density Functional Theory，简称DFT）在材料计算，医药和分子化学等领域扮演着重要的角色，是微观世界建模的重要工具。在高性能计算技术与机器学习方法飞速发展的今天，理论计算有望更快速地突破科学边界，解决更多的实际问题。密度泛函理论兼具效率与精度，正在释放出巨大的潜力。\nABACUS作为积淀深厚的国产开源密度泛函计算软件，致力于结合高性能计算和机器学习方法，推动电子结构新算法的发展和普及，为更多科研人员、老师和学生们提供更方便易用的免费开源软件，为更多开发者提供一个框架清晰、方便上手的开发平台，努力将第一性原理方法打造成面向实际应用场景的解决方案。\n在ABACUS等DFT软件计算中有一个很重要的倒易空间到实空间的转换，涉及到快速傅里叶算法也就是FFT。不过这个转化和通常的FFT不同，它带有一定的稀疏性。我们可以将在倒易空间需要变换的数据视为是一个球体，这个球体位于一个三维的正立方体中，球体直径小于等于立方体边长的一半，立方体其他部分置零，然后将整个立方体输入到FFT中进行变换得到实空间数据。但受限于接口问题目前只能应用cuFFT或者FFTW等成熟的库，没法有效利用数据的稀疏性。在实际计算中，FFT的计算占比达30%以上，是一个相当大的计算瓶颈。我们以ABACUS为基础，将相关问题抽象出来，提供了一个物理意义无关的优化问题模型。\n赛题描述 link考虑立方体$D$，定义其边长为$c$，球$R$为$D$中的一个球体，球的半径为$r$，$r\\leq c/4$。\n为简化起见，考虑$D$和$R$的中心重合位于原点处。注意：这里边长都是整数，格点位于每个整点处，若长度为$m$，则格点数为$m+1$。若边长为奇数，则原点分布于正中间，若边长为偶数，则自动扩充边长为变长+1。\nFFT输入数据示意图，仅有彩色球体为有效数据，其余部分置为零。\n输入 link 立方体边长$c$ 球体半径$r$ 三维复数数据$A$，$A$的大小为$c^3$，以一维数组形式连续存储。$A$的初始化说明如下： 遍历A中的数据元素P(x,y,z); 如果P到球心距离小于半径r，则P=random_complex; 否则P置零。 输出 link A经过逆傅里叶变化后的输出数组B。 其中，A是频域空间，B是时域空间。\n评测说明 link 初始代码中提供了一份使用cuFFT作为实现的代码，以下简称为Baseline版本。要求选手实现的版本以下简称为Acclerate版本。 Baseline提供了编译说明，可以在Github下载，Baseline相关问题可直接在仓库提交ISSUE讨论。 Acclerate的输出应该和Baseline一致（允许误差：1∗10−5）。 你可以在/data/software/tools/cufft找到评测用的输入数据\n评分标准 link 将在规定的硬件平台上运行选手的程序，分别对于如下大小的c和r进行10次运行，取平均耗时为最终耗时结果： c r 权重 次数 1 33 8 0.15 10 2 33 6 0.15 10 3 65 16 0.15 10 4 65 12 0.15 10 5 129 32 0.1 10 6 129 24 0.1 10 9 257 64 0.05 10 10 257 48 0.",
                content: "背景介绍 link密度泛函理论（Density Functional Theory，简称DFT）在材料计算，医药和分子化学等领域扮演着重要的角色，是微观世界建模的重要工具。在高性能计算技术与机器学习方法飞速发展的今天，理论计算有望更快速地突破科学边界，解决更多的实际问题。密度泛函理论兼具效率与精度，正在释放出巨大的潜力。\nABACUS作为积淀深厚的国产开源密度泛函计算软件，致力于结合高性能计算和机器学习方法，推动电子结构新算法的发展和普及，为更多科研人员、老师和学生们提供更方便易用的免费开源软件，为更多开发者提供一个框架清晰、方便上手的开发平台，努力将第一性原理方法打造成面向实际应用场景的解决方案。\n在ABACUS等DFT软件计算中有一个很重要的倒易空间到实空间的转换，涉及到快速傅里叶算法也就是FFT。不过这个转化和通常的FFT不同，它带有一定的稀疏性。我们可以将在倒易空间需要变换的数据视为是一个球体，这个球体位于一个三维的正立方体中，球体直径小于等于立方体边长的一半，立方体其他部分置零，然后将整个立方体输入到FFT中进行变换得到实空间数据。但受限于接口问题目前只能应用cuFFT或者FFTW等成熟的库，没法有效利用数据的稀疏性。在实际计算中，FFT的计算占比达30%以上，是一个相当大的计算瓶颈。我们以ABACUS为基础，将相关问题抽象出来，提供了一个物理意义无关的优化问题模型。\n赛题描述 link考虑立方体$D$，定义其边长为$c$，球$R$为$D$中的一个球体，球的半径为$r$，$r\\leq c/4$。\n为简化起见，考虑$D$和$R$的中心重合位于原点处。注意：这里边长都是整数，格点位于每个整点处，若长度为$m$，则格点数为$m+1$。若边长为奇数，则原点分布于正中间，若边长为偶数，则自动扩充边长为变长+1。\nFFT输入数据示意图，仅有彩色球体为有效数据，其余部分置为零。\n输入 link 立方体边长$c$ 球体半径$r$ 三维复数数据$A$，$A$的大小为$c^3$，以一维数组形式连续存储。$A$的初始化说明如下： 遍历A中的数据元素P(x,y,z); 如果P到球心距离小于半径r，则P=random_complex; 否则P置零。 输出 link A经过逆傅里叶变化后的输出数组B。 其中，A是频域空间，B是时域空间。\n评测说明 link 初始代码中提供了一份使用cuFFT作为实现的代码，以下简称为Baseline版本。要求选手实现的版本以下简称为Acclerate版本。 Baseline提供了编译说明，可以在Github下载，Baseline相关问题可直接在仓库提交ISSUE讨论。 Acclerate的输出应该和Baseline一致（允许误差：1∗10−5）。 你可以在/data/software/tools/cufft找到评测用的输入数据\n评分标准 link 将在规定的硬件平台上运行选手的程序，分别对于如下大小的c和r进行10次运行，取平均耗时为最终耗时结果： c r 权重 次数 1 33 8 0.15 10 2 33 6 0.15 10 3 65 16 0.15 10 4 65 12 0.15 10 5 129 32 0.1 10 6 129 24 0.1 10 9 257 64 0.05 10 10 257 48 0.05 10 11 513 96 0.05 10 12 513 128 0.05 10 一个complex为16 byte，最大的输入数据集512^3次方为2GB数据大小。 每个样例分别取Accelerate和Baseline的耗时之比，计算所有样例比值的加权平均为最终评分标准。 IO时间不算在你的评分时间中 注：本题采用并行评测的方式，评测过程中返回已完成的点数可能并非按照顺序，请知悉。 handout使用方式 link compile.sh：编译你的程序 run.sh c r num：在c, r的条件下，用你的程序中处理data中的num个数据。 提交方式 link提交你的answer.cpp，我们会编译并运行。\n参考文档 link ABACUS Documentation ‒ ABACUS documentation https://docs.nvidia.com/cuda/pdf/CUFFT_Library.pdf FFT and sparse FFT techniques and applications 附件 link初始工作区\n下载cufft_handout_update.zip\n"
            }
        );
    index.add(
            {
                id:  77 ,
                href: "\/TechDocs\/docs\/hpcgame\/%E7%BB%BC%E5%90%88%E5%BA%94%E7%94%A8%E6%8F%90%E5%8D%87\/",
                title: "4. 综合应用提升",
                description: "",
                content: ""
            }
        );
    index.add(
            {
                id:  78 ,
                href: "\/TechDocs\/docs\/hpcgame\/%E7%BB%BC%E5%90%88%E5%BA%94%E7%94%A8%E6%8F%90%E5%8D%87\/4a\/",
                title: "A. 走，我们扫雷去",
                description: "题目背景 link你很喜欢玩扫雷。\n在游戏“扫雷”中，你面对的是一个由若干方格组成的矩阵，每个方格中可能有一颗地雷，也可能没有地雷。\n你的基本操作名叫“点开”。每一次，你可以选择一个格子并“点开”它，如果它是地雷，那么你的分数会被扣掉一些，如果它不是地雷，那么你会获得一分，并且会有一个数字显现在方格上，这个数字代表着周围的的八个方格（上、下、左、右、左上、左下、右上、右下）中一共有多少颗地雷（数字为 0 到 8）。如果点开的方格中的数字为 0（这代表这个方格周围的八个方格都不是地雷），那么它周围的方格也会被自动“点开”（这个过程可以递归，也即，如果新的方格中的数字也是 0，那么它周围的八个方格也会被自动“点开”。我们称其为“间接点开”，相对应的，被玩家直接点开的格子称为“直接点开”）。当玩家主动退出，或者时间耗尽后，游戏结束。\n请注意，本题的扫雷与标准的扫雷有一些区别：\n在标准的扫雷中，点开一个包含地雷的方格后，游戏会立刻失败 当玩家程序点开所有非地雷方格后，游戏不会自动结束，需要玩家程序主动退出。 每次“点开”一个包含数字 0 的格子时，你的程序会收到点开的格子所在的连通块中的所有数字为 0 的格子以及边缘那些数字不为 0 的格子，哪怕这些格子已经被点开过。这个在后文有具体的描述。 下面是 KDE 桌面系统中的“扫雷”游戏的例子（红色的小旗子代表这个方格中有地雷，空白的格子表示格子中的数字为 0）：\n经过夜以继日的练习后，高级版扫雷的 30×16 的地图规模对你来说已经是小菜一碟。于是，你决定玩点刺激的。比如，65536×65535 的扫雷？\n当然，如此大规模的扫雷肯定不能手工完成。于是，你打算把毕生所学融入到一个程序中，让这个程序来自动化地扫雷。\n题目描述 link你需要写一个（可能是并行的）程序，与我们提供的扫雷 game server 交互。\n你可以使用下列库函数来与 game server 交互：\nvoid minesweeper_init(int \u0026N, int \u0026K, int \u0026constant_A); 在程序开始前，请调用此函数来初始化程序。这个函数会把地图的边长 N 存放在变量 N 中，把地图中的雷的数量 K 存放在变量 K 中，将评分参数 A（详见下文）存放在变量 constant_A 中。\nChannel create_channel(void); 请使用此函数创建一个用于和 game server 通信的 Channel 对象。保证不同的 Channel 之间互不干扰，但若有两个进程 / 线程同时操作同一个 Channel，那么大概率会出错。所以建议为每个进程 / 线程单独开一个 Channel。",
                content: "题目背景 link你很喜欢玩扫雷。\n在游戏“扫雷”中，你面对的是一个由若干方格组成的矩阵，每个方格中可能有一颗地雷，也可能没有地雷。\n你的基本操作名叫“点开”。每一次，你可以选择一个格子并“点开”它，如果它是地雷，那么你的分数会被扣掉一些，如果它不是地雷，那么你会获得一分，并且会有一个数字显现在方格上，这个数字代表着周围的的八个方格（上、下、左、右、左上、左下、右上、右下）中一共有多少颗地雷（数字为 0 到 8）。如果点开的方格中的数字为 0（这代表这个方格周围的八个方格都不是地雷），那么它周围的方格也会被自动“点开”（这个过程可以递归，也即，如果新的方格中的数字也是 0，那么它周围的八个方格也会被自动“点开”。我们称其为“间接点开”，相对应的，被玩家直接点开的格子称为“直接点开”）。当玩家主动退出，或者时间耗尽后，游戏结束。\n请注意，本题的扫雷与标准的扫雷有一些区别：\n在标准的扫雷中，点开一个包含地雷的方格后，游戏会立刻失败 当玩家程序点开所有非地雷方格后，游戏不会自动结束，需要玩家程序主动退出。 每次“点开”一个包含数字 0 的格子时，你的程序会收到点开的格子所在的连通块中的所有数字为 0 的格子以及边缘那些数字不为 0 的格子，哪怕这些格子已经被点开过。这个在后文有具体的描述。 下面是 KDE 桌面系统中的“扫雷”游戏的例子（红色的小旗子代表这个方格中有地雷，空白的格子表示格子中的数字为 0）：\n经过夜以继日的练习后，高级版扫雷的 30×16 的地图规模对你来说已经是小菜一碟。于是，你决定玩点刺激的。比如，65536×65535 的扫雷？\n当然，如此大规模的扫雷肯定不能手工完成。于是，你打算把毕生所学融入到一个程序中，让这个程序来自动化地扫雷。\n题目描述 link你需要写一个（可能是并行的）程序，与我们提供的扫雷 game server 交互。\n你可以使用下列库函数来与 game server 交互：\nvoid minesweeper_init(int \u0026N, int \u0026K, int \u0026constant_A); 在程序开始前，请调用此函数来初始化程序。这个函数会把地图的边长 N 存放在变量 N 中，把地图中的雷的数量 K 存放在变量 K 中，将评分参数 A（详见下文）存放在变量 constant_A 中。\nChannel create_channel(void); 请使用此函数创建一个用于和 game server 通信的 Channel 对象。保证不同的 Channel 之间互不干扰，但若有两个进程 / 线程同时操作同一个 Channel，那么大概率会出错。所以建议为每个进程 / 线程单独开一个 Channel。\n您可以使用此函数创建至多 1024 个 Channel，不过我建议您尽量保证活跃（反复调用 click()）的 Channel 不超过 8 个。毕竟对于每个您创建的 Channel，game server 中都有一个独立的线程负责处理该 Channel 中的请求。我们在评测的时候仅提供 16 个核心（注：没有超线程），故如果活跃的 Channel 超过 8 个，那么将发生频繁的 context switch，进而在很大程度上影响性能。\nClickResult Channel::click(int r, int c, bool skip_when_reopen); 这是 Channel 的成员函数，代表“点开 (r,c) 位置所对应的格子”这一操作，0≤r,c"
            }
        );
    index.add(
            {
                id:  79 ,
                href: "\/TechDocs\/docs\/hpcgame\/%E7%BB%BC%E5%90%88%E5%BA%94%E7%94%A8%E6%8F%90%E5%8D%87\/4b\/",
                title: "AI算子优化",
                description: "Problem linkYou’ve entered an AI laboratory in a university.\nThere are many commonly used operators in the field of deep learning, and what you need to do today is to optimize three of them.\nThe code of your project is included in problem attachments.\nmatmul linkCalculate the result of multiplying two 2D matrices.\nYou can modify the macro MM_KERNEL_SIMPLE in /src/math/matmul_simple.c to optimize the operator.\nIf you want to test the operator yourself, you can run this",
                content: "Problem linkYou’ve entered an AI laboratory in a university.\nThere are many commonly used operators in the field of deep learning, and what you need to do today is to optimize three of them.\nThe code of your project is included in problem attachments.\nmatmul linkCalculate the result of multiplying two 2D matrices.\nYou can modify the macro MM_KERNEL_SIMPLE in /src/math/matmul_simple.c to optimize the operator.\nIf you want to test the operator yourself, you can run this\ncd build cmake .. make cd bin ./matmul_simple_test ../../test/test_data/matmul/2_case_32_1024_32_float/input1.dat \\ ../../test/test_data/matmul/2_case_32_1024_32_float/input2.dat \\ ../../test/test_data/matmul/2_case_32_1024_32_float/output.dat conv2d linkCalculate two-dimensional convolution based on 4D input tensor(N, C_in, H, W) and 4D filter(C_in, C_out, K, K).\nYou can modify the macro CONV2D_KERNEL_SIMPLE in /src/nn/conv2d_simple.c to optimize the operator.\nIf you want to test the operator yourself, you can run this\ncd build cmake .. make cd bin ./conv2d_simple_test ../../test/test_data/conv2d/1_case_2_2_16_16_float/input.dat \\ ../../test/test_data/conv2d/1_case_2_2_16_16_float/filter.dat \\ ../../test/test_data/conv2d/1_case_2_2_16_16_float/output.dat resize2d_bilinear linkResize 2D images with bilinear interpolation.\nYou can modify the macro resize2d_bilinear_kernel in /src/nn/resize2d_bilinear.c to optimize the operator.\nIf you want to test the operator yourself, you can run this\ncd build cmake .. make cd bin ./resize2d_bilinear_test \\ ../../test/test_data/resize2d_bilinear/1_case_1024_1024_512_512_float/input.dat \\ ../../test/test_data/resize2d_bilinear/1_case_1024_1024_512_512_float/output.dat \\ ../../test/test_data/resize2d_bilinear/1_case_1024_1024_512_512_float/shape.dat How to submit linkPut the three macros in one header file and submit it.\nA sample submission: (submit this directly and you will get ~20pts)\n#ifndef _ANSWER_H_ #define _ANSWER_H_ #pragma GCC optimize(\"O3\") // kernel of resize2d_bilinear #define resize2d_bilinear_kernel(typename) \\ typename *in_data = aitisa_tensor_data(input); \\ typename *out_data = aitisa_tensor_data(*output); \\ for (int64_t i = 0; i \u003c target_h; i++) \\ { \\ for (int64_t j = 0; j \u003c target_w; j++) \\ { \\ double raw_u = i * (double)h / (double)target_h; \\ double raw_v = j * (double)w / (double)target_w; \\ int64_t u = (int64_t)raw_u; \\ int64_t v = (int64_t)raw_v; \\ if (u + 1 == h || v + 1 == w) \\ { \\ out_data[i * target_w + j] = in_data[u * w + v]; \\ continue; \\ } \\ typename f00 = in_data[u * w + v]; \\ typename f01 = in_data[u * w + v + 1]; \\ typename f10 = in_data[(u + 1) * w + v]; \\ typename f11 = in_data[(u + 1) * w + v + 1]; \\ double x = raw_u - u; \\ double y = raw_v - v; \\ out_data[i * target_w + j] = f00 * (1 - x) * (1 - y) + \\ f01 * (1 - x) * y + f10 * x * (1 - y) + \\ f11 * x * y; \\ } \\ } // kernel of conv2d_simple #define CONV2D_KERNEL_SIMPLE(typename, A, B, C, N, C_in, H, W, C_out, K) \\ int H_out = H - K + 1; \\ int W_out = W - K + 1; \\ for (int n = 0; n \u003c N; n++) \\ { \\ for (int c = 0; c \u003c C_out; c++) \\ { \\ for (int i = 0; i \u003c H_out; i++) \\ { \\ for (int j = 0; j \u003c W_out; j++) \\ { \\ int offset_output = n * C_out * H_out * W_out + c * H_out * W_out + i * W_out + j; \\ for (int kc = 0; kc \u003c C_in; kc++) \\ { \\ for (int ki = 0; ki \u003c K; ki++) \\ { \\ for (int kj = 0; kj \u003c K; kj++) \\ { \\ int offset_input = n * C_in * H * W + kc * H * W + (i + ki) * W + (j + kj); \\ int offset_filter = c * C_in * K * K + kc * K * K + ki * K + kj; \\ ((typename *)C)[offset_output] += ((typename *)A)[offset_input] * ((typename *)B)[offset_filter]; \\ } \\ } \\ } \\ } \\ } \\ } \\ } // which means: // C[n, c, i, j] += A[n, kc, i + ki, j + kj] * B[c, kc, ki, kj] // kernel of matrix-matrix multiply #define MM_KERNEL_SIMPLE(typename, A, B, C, M, K, N) \\ for (int i = 0; i \u003c M; ++i) \\ { \\ for (int j = 0; j \u003c N; ++j) \\ { \\ for (int q = 0; q \u003c K; ++q) \\ { \\ ((typename *)C)[i * N + j] += \\ ((typename *)A)[i * K + q] * ((typename *)B)[q * N + j]; \\ } \\ } \\ } #endif How do we judge linkFor each operator, we have 5 test cases.\nconv2d link Zero Score Time (secs) Full Score Time (secs) Full Score 0.06 0.02 3 0.81 0.24 10 0.06 0.02 3 0.78 0.25 10 0.75 0.24 10 matmul link Zero Score Time (secs) Full Score Time (secs) Full Score 0.75 0.24 10 0.06 0.02 3 0.24 0.08 10 3.85 1.24 14 1.93 0.62 12 resize2d_bilinear linkWe will exclude io time.\nZero Score Time (secs) Full Score Time (secs) Full Score 0.0095 0.0035 10 0.0165 0.0057 10 0.004 0.0015 10 0.065 0.025 15 0.024 0.0085 10 We use the function\n$$ S_{score}(t)=\\frac{\\ln \\frac{t_{zero_score}}{t}}{\\ln \\frac{t_{zero_score}}{t_{full_score}}}S_{full_score} $$\nto calculate your score.\n附件 linkThe project code\n下载project_code.zip\n"
            }
        );
    index.add(
            {
                id:  80 ,
                href: "\/TechDocs\/docs\/hpcgame\/%E7%BB%BC%E5%90%88%E5%BA%94%E7%94%A8%E6%8F%90%E5%8D%87\/4c\/",
                title: "RDMA就是快",
                description: "问题描述 linkTCP/IP 协议基于软件协议栈传输的这种方式已经无法适应高速数据传输的需求，成为网络性能进一步增长的瓶颈，特别是应用数据在用户态和内核态之间的拷贝带来ms级的延时，协议栈对数据包的解析、寻址、校验等操作需要消耗大量CPU资源。为此，RDMA技术替代了传统的TCP/IP软件协议栈的设计。RDMA的全称是远程直接内存访问（remote direct memory access），它在硬件上实现了kernel bypass技术，数据不需要经过软件协议栈，并且不需要CPU参与寻址、解析等操作，从而提供低延时、高带宽、低CPU使用的性能优势。\n然而，想要充分挖掘RDMA的性能优势并不是一个容易的任务。我们这里假设一个最简单的场景：有一个数据生产者producer与一个数据消费者consumer，生产者不断给consumer发送数据。我们在附件提供了一个样例程序。该样例程序包含了producer与consumer的实现。作为参赛者，你需要进一步优化该样例程序，以达到更大的传输性能。注意，参赛者的最终提交不能修改其中的farm_cons.cpp与farm_prod.cpp（改了也没用），其余文件都可以自由改动.。\n你可以做的事情包括但不限于: 对原有的ringbuffer进行常数优化；调整原有ringbuffer的参数；调整RDMA的传输参数与设置以适应应用场景；利用RDMA原语自由设计新的数据结构。\n（你也可以到 https://github.com/N2-Sys/rdma-ringbuffer-demo 去看未经比赛工作组修改的程序）\n你主要需要关注的文件是farm.h与farm.cpp。common.cpp包含一些rdma与ringbuffer的通用接口，你也可以复用或改动其中的代码。注意，如果需要深入改动代码，你最好对RDMA编程有一些基本的了解，我们提供了一些参考资料。\n提示： link大包已经快接近物理极限了，主要是小包优化。\n评测环境ib卡的max_mtu是4096KB\n测试方法 link测试分为若干轮。每一轮都会传输多个message，message大小随着轮数逐渐增大，是以64B为首项，8为公比直至1MB的等比数列。每一轮传输的数据总量为25GB，每个点时间越少，分数越高。\n具体来说：你的得分由你程序的加速比确定，可以参考下表：\nSize ZeroScoreSpeed(MiB/s) FullScoreSpeed(MiB/s) Score 64 104 1044 40 512 860 4304 40 4096 5746 8650 40 32768 10222 11500 10 262144 9730 11000 10 1048576 7015 10500 10 另有10分的满分奖励\n提交方法 link你需要保留初始工作区的架构，修改其中文件。\n将你的答案打包成zip后提交，请注意：所有文件必须放在压缩文件的根下。我们将编译你的程序，进行测试。\n具体解释：什么叫所有文件必须放在压缩文件的根下：\n压缩文件不包括子目录，直接解压就得到文件，目录结构举例：\n- include/ - farm_prod.cpp - farm_cons.cpp - farm.cpp - common.cpp - cmake/ - CMakeLists.txt 而不是：\n- rdma - include/ - farm_prod.",
                content: "问题描述 linkTCP/IP 协议基于软件协议栈传输的这种方式已经无法适应高速数据传输的需求，成为网络性能进一步增长的瓶颈，特别是应用数据在用户态和内核态之间的拷贝带来ms级的延时，协议栈对数据包的解析、寻址、校验等操作需要消耗大量CPU资源。为此，RDMA技术替代了传统的TCP/IP软件协议栈的设计。RDMA的全称是远程直接内存访问（remote direct memory access），它在硬件上实现了kernel bypass技术，数据不需要经过软件协议栈，并且不需要CPU参与寻址、解析等操作，从而提供低延时、高带宽、低CPU使用的性能优势。\n然而，想要充分挖掘RDMA的性能优势并不是一个容易的任务。我们这里假设一个最简单的场景：有一个数据生产者producer与一个数据消费者consumer，生产者不断给consumer发送数据。我们在附件提供了一个样例程序。该样例程序包含了producer与consumer的实现。作为参赛者，你需要进一步优化该样例程序，以达到更大的传输性能。注意，参赛者的最终提交不能修改其中的farm_cons.cpp与farm_prod.cpp（改了也没用），其余文件都可以自由改动.。\n你可以做的事情包括但不限于: 对原有的ringbuffer进行常数优化；调整原有ringbuffer的参数；调整RDMA的传输参数与设置以适应应用场景；利用RDMA原语自由设计新的数据结构。\n（你也可以到 https://github.com/N2-Sys/rdma-ringbuffer-demo 去看未经比赛工作组修改的程序）\n你主要需要关注的文件是farm.h与farm.cpp。common.cpp包含一些rdma与ringbuffer的通用接口，你也可以复用或改动其中的代码。注意，如果需要深入改动代码，你最好对RDMA编程有一些基本的了解，我们提供了一些参考资料。\n提示： link大包已经快接近物理极限了，主要是小包优化。\n评测环境ib卡的max_mtu是4096KB\n测试方法 link测试分为若干轮。每一轮都会传输多个message，message大小随着轮数逐渐增大，是以64B为首项，8为公比直至1MB的等比数列。每一轮传输的数据总量为25GB，每个点时间越少，分数越高。\n具体来说：你的得分由你程序的加速比确定，可以参考下表：\nSize ZeroScoreSpeed(MiB/s) FullScoreSpeed(MiB/s) Score 64 104 1044 40 512 860 4304 40 4096 5746 8650 40 32768 10222 11500 10 262144 9730 11000 10 1048576 7015 10500 10 另有10分的满分奖励\n提交方法 link你需要保留初始工作区的架构，修改其中文件。\n将你的答案打包成zip后提交，请注意：所有文件必须放在压缩文件的根下。我们将编译你的程序，进行测试。\n具体解释：什么叫所有文件必须放在压缩文件的根下：\n压缩文件不包括子目录，直接解压就得到文件，目录结构举例：\n- include/ - farm_prod.cpp - farm_cons.cpp - farm.cpp - common.cpp - cmake/ - CMakeLists.txt 而不是：\n- rdma - include/ - farm_prod.cpp - farm_cons.cpp - farm.cpp - common.cpp - cmake/ - CMakeLists.txt 附件 link初始工作区\n下载rdma.zip\n"
            }
        );
    index.add(
            {
                id:  81 ,
                href: "\/TechDocs\/docs\/hpcgame\/%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E9%A2%98%E7%9B%AE\/",
                title: "5. 第二阶段题目",
                description: "",
                content: ""
            }
        );
    index.add(
            {
                id:  82 ,
                href: "\/TechDocs\/docs\/hpcgame\/%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E9%A2%98%E7%9B%AE\/finala\/",
                title: "A. 共轭梯度法",
                description: "背景介绍 link在各类数值模拟计算问题中，求解线性方程是一个非常常见且重要的步骤。比如在流体数值计算（CFD）中，我们常常需要求解一个关于流体压力的泊松类型问题：\n$$ \\frac{\\delta t}{\\rho}\\nabla p = \\nabla \\cdot \\vec {u} $$\n其中方程的左边是一个压力场$p$ 的二阶导数，而右边是速度场（矢量）的散度。通常我们想要在已知速度场的情况下，求解其对应的压力场 $p$，在特定的网格设定下，我们可以使用有限差分的方法我们可以将上面的微分方程转化为线性方程组。比如，下图演示了一个流体数值模拟中常用的，将压力存储在网格中心，将速度存储在网格界面上的离散形式：\n其对应的离散化方程式是：\n$$ \\frac{\\delta t}{\\rho}\\left[\\frac{1}{dx}\\cdot \\left(\\frac{p_{i+1,j}-p {i,j}}{dx} - \\frac{p{i,j}-p_{i-1,j}}{dx} \\right) + \\frac{1}{dy} \\cdot \\left( \\frac{p_{i,j+1}-p_{i,j}}{dy} - \\frac{p_{i,j}-p_{i, j-1} }{dy} \\right) \\right] = \\frac{u_{i,j}-u_{i-1,j}}{dx} + \\frac{v_{i,j}- v_{i,j-1}}{dy} $$\n其中$i$和$j$都是 [1, n] 的整数，我们可以对整个计算区域的所有格子列出类似的方程共 $n×n$个。\n对上式稍作整理可以发现当格子大小$dx=dy $时，方程左边可以简化成\n$$ \\frac{\\delta t}{\\rho dx^2}(4p_{i,j}-p_{i+1,j}-p_{i-1,j}-p_{i,j-1}- p_{i,j+1}) $$\n其中 $\\frac{\\delta t}{\\rho dx^2}$是一个常数系数，为了简化问题我们可以直接将其省略。于是，我们可以将$p$ 的系数存入一个矩阵 $A$，而将$p$ 保存在一个向量中，上面的表达式就变成了如下的一个矩阵和向量的乘：\n于是这个问题就被转化为了求解线性方程组的问题。在各类数值仿真中，这样的例子还有很多很多。\n共轭梯度法（Conjugate-gradient，以下简称为 CG 方法）是一种求解系数矩阵为对称正定矩阵的线性方程组的迭代解法。假设我们要求解如下的线性系统：\n$Ax=b$\n其中$A$ 是一个对称且正定，大小为 $n×n$的实数矩阵，$x$ 为待求解的大小为 $n×1$的未知数向量。",
                content: "背景介绍 link在各类数值模拟计算问题中，求解线性方程是一个非常常见且重要的步骤。比如在流体数值计算（CFD）中，我们常常需要求解一个关于流体压力的泊松类型问题：\n$$ \\frac{\\delta t}{\\rho}\\nabla p = \\nabla \\cdot \\vec {u} $$\n其中方程的左边是一个压力场$p$ 的二阶导数，而右边是速度场（矢量）的散度。通常我们想要在已知速度场的情况下，求解其对应的压力场 $p$，在特定的网格设定下，我们可以使用有限差分的方法我们可以将上面的微分方程转化为线性方程组。比如，下图演示了一个流体数值模拟中常用的，将压力存储在网格中心，将速度存储在网格界面上的离散形式：\n其对应的离散化方程式是：\n$$ \\frac{\\delta t}{\\rho}\\left[\\frac{1}{dx}\\cdot \\left(\\frac{p_{i+1,j}-p {i,j}}{dx} - \\frac{p{i,j}-p_{i-1,j}}{dx} \\right) + \\frac{1}{dy} \\cdot \\left( \\frac{p_{i,j+1}-p_{i,j}}{dy} - \\frac{p_{i,j}-p_{i, j-1} }{dy} \\right) \\right] = \\frac{u_{i,j}-u_{i-1,j}}{dx} + \\frac{v_{i,j}- v_{i,j-1}}{dy} $$\n其中$i$和$j$都是 [1, n] 的整数，我们可以对整个计算区域的所有格子列出类似的方程共 $n×n$个。\n对上式稍作整理可以发现当格子大小$dx=dy $时，方程左边可以简化成\n$$ \\frac{\\delta t}{\\rho dx^2}(4p_{i,j}-p_{i+1,j}-p_{i-1,j}-p_{i,j-1}- p_{i,j+1}) $$\n其中 $\\frac{\\delta t}{\\rho dx^2}$是一个常数系数，为了简化问题我们可以直接将其省略。于是，我们可以将$p$ 的系数存入一个矩阵 $A$，而将$p$ 保存在一个向量中，上面的表达式就变成了如下的一个矩阵和向量的乘：\n于是这个问题就被转化为了求解线性方程组的问题。在各类数值仿真中，这样的例子还有很多很多。\n共轭梯度法（Conjugate-gradient，以下简称为 CG 方法）是一种求解系数矩阵为对称正定矩阵的线性方程组的迭代解法。假设我们要求解如下的线性系统：\n$Ax=b$\n其中$A$ 是一个对称且正定，大小为 $n×n$的实数矩阵，$x$ 为待求解的大小为 $n×1$的未知数向量。\n整个共轭梯度法的过程可以用伪代码简单描述如下：\n其中 $x_k$​ 是迭代求解过程中第 $k$ 个循环时的解，$r_k​$是求解过程中在第$k$ 个迭代中的残差：\n$r_k​=b−Ax_k​$\n在循环迭代到 $r_k​$的模小于规定值时即认为求解完成。\n输入输出 link输入格式 link本题中，约定系数矩阵 $A$ 是一个对角线元素为 4.0，其余邻居对应元素为 -1.0 的五对角矩阵（five-diagonal matrices，除对角线和相邻元素外其他元素为0)。\nb对应的是一个 n^2×1 的向量，共20组测试点，是二进制文件，小端法，储存着n×n个 float32（4Byte）。命名规则为b_case_n_k.bin，如b_1_256_1.bin，输入文件放置在程序运行的相同文件夹下。\n其中，case是后文评分标准中的测试点编号，k表示当前测试点的第k个数据点。程序运行时，需读入所有数据点，进行处理后输出。\n输出格式 link输出结果到20个二进制文件，小端法。命名规则为ans_case_n_k.bin，数据类型为4byte浮点数。\n提交说明 link支持python, C, C++, CUDA实现。提交一个tar包，其中有start.sh，负责编译或者环境配置。\n对于python，评测环境为module load pyenv。评测节点有网络连接，如需要更多的环境包，请在start.sh中自行安装。\n对于C和C++的依赖，评测机与算力平台环境一致，可以使用sudo apt install进行安装（脚本并非跑在root下）\n对于CUDA，评测机环境为cuda 11.8，在SCOW平台module load nvtools即可使用，或使用我们的GPU类型算力。\n对于其他任何语言，只要能编译、运行即可提交，可以详细咨询组委会\n评测环境 link8 Core 32G, A100 * 1（与选手可申请的环境相同，算力平台中的GPU类型）\n评测说明 link本题暂时不支持实时评测，由组委会进行评测并审核。视提交时间，可能会有10分钟到4小时不等的延迟。\n评分标准 link将在规定的硬件平台上测算选手的程序，分别对于如下大小规模的问题进行 5 次运行，取平均耗时作为最终结果：\n我们将把选手时间减去IO时间和CUDA初始化时间，作为耗时。\n测试点 未知数数量 重复次数 1 256^2 5 2 512^2 5 3 1024^2 5 4 2048^2 5 我们提供了一个Taichi实现作为例子，选手可以参考。\n$ python3 main.py 附件 linkpython样例\n下载cg.zip\n"
            }
        );
    index.add(
            {
                id:  83 ,
                href: "\/TechDocs\/docs\/hpcgame\/%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E9%A2%98%E7%9B%AE\/finalb\/",
                title: "B. 高性能存储阵列的软件开销优化",
                description: "一、背景介绍 link近些年来，SSD因其高带宽、低延迟、低能耗的特点，已经成为了高性能计算、数据中心、云服务等场景下的主要存储设备。但不幸的是，由于其自身的物理性质，相较于HDD，SSD通常更容易损坏，导致数据丢失。\n存储阵列（RAID）是解决这个问题的手段之一。通过条带化技术，RAID可以聚合多个SSD的性能，同时对外提供服务，以驱动高性能计算中大量I/O的场景；通过校验和技术，RAID可以保证存储阵列具有一定的容错性，即使其中的一个磁盘损坏，也能从剩余的磁盘中恢复数据。\nLinux software RAID（mdraid）是Linux内核中自带的RAID引擎，设计于二十多年前，因其高昂的软件开销，已不再适合用来创建和管理现有的高性能存储设备（如NVMe SSD）。如何优化mdraid，使得高性能SSD组成的存储阵列能够发挥出优异的性能，是现在学术界和工业界关注和研究的重点。\n二、赛题描述 link本次比赛允许优化mdraid中的任何软件开销，考虑到比赛时间限制，参赛者可以通过阅读论文[1][2]了解到mdraid中已知的可优化的开销。同时，我们鼓励参赛者自己通过perf，fio等工具剖析RAID软件栈，找出其他可优化的部分。\n下面简单介绍一下mdraid中的一个和锁相关开销，该开销的详细分析和说明可见论文[1]。如下图所示，在mdraid中，当I/O线程在处理写请求时，它首先会将数据分割为多个stripe unit。拥有相同offset的stripe unit属于同一个条带，它们会被一起处理 ①。但在处理之前，I/O线程需要向守护进程获取一个名为stripe_head的数据结构 ②。但是，为了防止多线程之间的冲突，mdraid使用全局的锁去管理stripe_head的分配。因此，如果我们使用多个线程来处理I/O请求，它们就会被这个锁阻塞，无法并行处理，造成大量的软件开销。解决这个问题的办法很简单，我们可以给每个stripe_head都分配一个锁，单独进行管理，再使用hash算法让不同的线程去找到不同的stripe_head，从而最大化线程的并行度。\n类似的软件开销还有很多，请参赛者务必阅读论文[1][2]，以对mdraid相关的设计和开销形成初步的了解。除此之外，这里推荐查看资料[3]，辅助阅读mdraid相关的代码。\n三、评测说明 link 我们允许修改附件中md文件夹下的任何代码，但其中很多代码只是因为编译需要而存在，和本次比赛相关度较低，因此我们建议参赛者关注文件raid5.，md.*；\n修改代码后，参赛者可以根据附件README安装测试环境，测试自己代码的正确性。评测过程中也会使用相同的内核（linux-5.11-46）；\n在评测过程中，我们会使用mdadm创建RAID5，参赛者可以参考[4]学习mdadm的使用方法；\n在评测过程中，我们会使用高性能的NVMe SSD组建RAID,如果参赛者自己的Coding环境没有足够的磁盘，可以参考附录A，使用RAM模拟磁盘;\n[1]的代码是开源的，我们允许参赛者整合该开源代码作为基础继续修改，但必须有其他的设计以作为此次参赛的内容；\n在评测过程中，我们会使用fio产生IO请求，参赛者可以参考[5]学习fio的使用。\n四、评分标准 link我们会用高性能的NVMe SSD组成2+1，4+1两种RAID5，并使用fio评估I/O的带宽和完成时延。带宽越高分数越高，延迟越低分数越高，按排名正态分布给分。我们使用到的测试参数如下表所示，其中worker thread的定义可以参考论文[1][2],并通过修改文件/sys/block/mdx/md/group_thread_cnt修改，这里mdx是你通过mdadm创建的RAID：\nRAID类型 I/O Size No. of I/O threads No. of Worker threads IO depth 类别 指标 分数占比 2+1 64 KB 8 8 32 随机写 带宽 6.25 % 2+1 128 KB 8 8 32 随机写 带宽 6.25 % 4+1 64 KB 8 8 32 随机写 带宽 6.",
                content: "一、背景介绍 link近些年来，SSD因其高带宽、低延迟、低能耗的特点，已经成为了高性能计算、数据中心、云服务等场景下的主要存储设备。但不幸的是，由于其自身的物理性质，相较于HDD，SSD通常更容易损坏，导致数据丢失。\n存储阵列（RAID）是解决这个问题的手段之一。通过条带化技术，RAID可以聚合多个SSD的性能，同时对外提供服务，以驱动高性能计算中大量I/O的场景；通过校验和技术，RAID可以保证存储阵列具有一定的容错性，即使其中的一个磁盘损坏，也能从剩余的磁盘中恢复数据。\nLinux software RAID（mdraid）是Linux内核中自带的RAID引擎，设计于二十多年前，因其高昂的软件开销，已不再适合用来创建和管理现有的高性能存储设备（如NVMe SSD）。如何优化mdraid，使得高性能SSD组成的存储阵列能够发挥出优异的性能，是现在学术界和工业界关注和研究的重点。\n二、赛题描述 link本次比赛允许优化mdraid中的任何软件开销，考虑到比赛时间限制，参赛者可以通过阅读论文[1][2]了解到mdraid中已知的可优化的开销。同时，我们鼓励参赛者自己通过perf，fio等工具剖析RAID软件栈，找出其他可优化的部分。\n下面简单介绍一下mdraid中的一个和锁相关开销，该开销的详细分析和说明可见论文[1]。如下图所示，在mdraid中，当I/O线程在处理写请求时，它首先会将数据分割为多个stripe unit。拥有相同offset的stripe unit属于同一个条带，它们会被一起处理 ①。但在处理之前，I/O线程需要向守护进程获取一个名为stripe_head的数据结构 ②。但是，为了防止多线程之间的冲突，mdraid使用全局的锁去管理stripe_head的分配。因此，如果我们使用多个线程来处理I/O请求，它们就会被这个锁阻塞，无法并行处理，造成大量的软件开销。解决这个问题的办法很简单，我们可以给每个stripe_head都分配一个锁，单独进行管理，再使用hash算法让不同的线程去找到不同的stripe_head，从而最大化线程的并行度。\n类似的软件开销还有很多，请参赛者务必阅读论文[1][2]，以对mdraid相关的设计和开销形成初步的了解。除此之外，这里推荐查看资料[3]，辅助阅读mdraid相关的代码。\n三、评测说明 link 我们允许修改附件中md文件夹下的任何代码，但其中很多代码只是因为编译需要而存在，和本次比赛相关度较低，因此我们建议参赛者关注文件raid5.，md.*；\n修改代码后，参赛者可以根据附件README安装测试环境，测试自己代码的正确性。评测过程中也会使用相同的内核（linux-5.11-46）；\n在评测过程中，我们会使用mdadm创建RAID5，参赛者可以参考[4]学习mdadm的使用方法；\n在评测过程中，我们会使用高性能的NVMe SSD组建RAID,如果参赛者自己的Coding环境没有足够的磁盘，可以参考附录A，使用RAM模拟磁盘;\n[1]的代码是开源的，我们允许参赛者整合该开源代码作为基础继续修改，但必须有其他的设计以作为此次参赛的内容；\n在评测过程中，我们会使用fio产生IO请求，参赛者可以参考[5]学习fio的使用。\n四、评分标准 link我们会用高性能的NVMe SSD组成2+1，4+1两种RAID5，并使用fio评估I/O的带宽和完成时延。带宽越高分数越高，延迟越低分数越高，按排名正态分布给分。我们使用到的测试参数如下表所示，其中worker thread的定义可以参考论文[1][2],并通过修改文件/sys/block/mdx/md/group_thread_cnt修改，这里mdx是你通过mdadm创建的RAID：\nRAID类型 I/O Size No. of I/O threads No. of Worker threads IO depth 类别 指标 分数占比 2+1 64 KB 8 8 32 随机写 带宽 6.25 % 2+1 128 KB 8 8 32 随机写 带宽 6.25 % 4+1 64 KB 8 8 32 随机写 带宽 6.25 % 4+1 256 KB 8 8 32 随机写 带宽 6.25 % 2+1 64 KB 8 8 32 顺序写 带宽 6.25 % 2+1 128 KB 8 8 32 顺序写 带宽 6.25 % 4+1 64 KB 8 8 32 顺序写 带宽 6.25 % 4+1 256 KB 8 8 32 顺序写 带宽 6.25 % 2+1 4 KB 1 1 1 随机写 延迟 12.5 % 4+1 4 KB 1 1 1 随机写 延迟 12.5 % 2+1 4 KB 1 1 1 顺序写 延迟 12.5 % 4+1 4 KB 1 1 1 顺序写 延迟 12.5 % 附件fio.conf，给出了第一组测试的fio配置文件。\n五、参考文献 link[1] Yi, Shushu, et al. “ScalaRAID: optimizing linux software RAID system for next-generation storage.” Proceedings of the 14th ACM Workshop on Hot Topics in Storage and File Systems. 2022.（编者注：https://dl.acm.org/doi/10.1145/3538643.3539740 ，已在附件中包含，仅供学习研究之用）\n[2] Wang, Shucheng, et al. “{StRAID}: Stripe-threaded Architecture for Parity-based {RAIDs} with Ultra-fast {SSDs}.” 2022 USENIX Annual Technical Conference (USENIX ATC 22). 2022.（编者注：https://www.usenix.org/conference/atc22/presentation/wang-shucheng ，文档开放获取）\n[3] 小表弟皮卡丘的博客_CSDN博客-linux kernel,raid,存储领域博主\n[4] A guide to mdadm - Linux Raid Wiki\n[5] https://fio.readthedocs.io/en/latest/index.html\n附录A: 如何搭建测试环境（buildenv.md） link一、安装内核 link评测中将使用的内核版本为linux-5.11-46，请在测试中尽量使用相同的内核版本。mdraid模块默认是不可修改的，如果想要修改，需要在编译内核文件时将相关配置设置为[M]。我们提供的ubuntu环境已经配置完成，如果你想使用自己的设备，请自行编译内核。\n我们在附件中提供了linux-image的deb包，可用于ubuntu 20.04版本安装，具体步骤如下。\ndpkg -i linux-image-unsigned-5.11.0-46-generic_5.11.0-46.51~20.04.1_amd64.deb \\ linux-modules-5.11.0-46-generic_5.11.0-46.51~20.04.1_amd64.deb apt install linux-headers-5.11.0-46-generic \\ linux-modules-extra-5.11.0-46-generic \\ linux-buildinfo-5.11.0-46-generic \\ linux-tools-5.11.0-46-generic 二、优化 \u0026 编译 link我们允许参赛者优化md文件夹下的任何代码，我们已经写好了Makefile文件，优化完成后，参赛者可以直接通过make指令进行编译。编译完成后会生成一系列.ko文件，这就是内核模块文件。请参赛者仔细阅读Makefile文件，确定自己的修改涉及到哪几个.ko文件，并安装这些修改后的模块。\n三、安装模块 link 首先进入存放mdraid相关模块的文件夹：cd /lib/modules/5.11.0-46-generic/kernel/drivers/md/ ；\n假设我们修改的模块是md-mod.ko。我们先备份这个文件：cp md-mod.ko md-mod.ko.bak；\n然后我们删除原有的未经修改的md-mod模块。由于许多模块依赖于md-mod模块，因此我们需要先删除这些依赖的模块，并最后删除md-mod。参赛者可以通过lsmod | grep md来查看模块的依赖关系。假设md-mod被模块linear，raid0，raid456，…依赖：\n# 删除依赖md-mod的模块 rmmod raid1 rmmod raid10 rmmod raid0 rmmod linear rmmod raid456 rmmod multipath # 请检查自己系统，查看是否有其他依赖 # 删除md-mod模块 rmmod md-mod 然后我们将之前编译产生的md-mod.ko复制的这里：sudo cp path/md-mod.ko ./；\n最后我们安装md-mod模块以及之前删除的模块：\n// 安装md-mod模块 insmod md-mod.ko // 安装之前删除的模块 insmod raid1.ko. insmod raid10.ko insmod raid0.ko insmod linear.ko insmod raid456.ko insmod multipath.ko 至此，你的修改已经嵌入到内核中，可以通过mdadm创建RAID5并使用fio进行测试。\n附录B：使用内核模块brd创建内存盘 linkblock ram disk，缩写为brd，是Linux kernel中提供的创建内存盘的模块，代码可以在kernel中drivers/block/brd.c找到。\n由brd创建的内存盘和brd模块的生命周期相同重启时会消失，具体来说：\n加载模块、创建内存盘：modprobe brd\n这个命令有三个可选参数：\nrd_nr : 创建内存盘的数量 rd_size : 内存盘的最大大小，单位为kb max_part : 每个内存盘的最多分区数\n下面例子在创建了5个大小为2G的单分区内存盘，位于/dev/ram0到/dev/ram4\nmodprobe brd rd_size=2048000 max_part=1 rd_nr=5 卸载模块、删除所有内存盘：rmmod brd\n分区与fdisk的使用：https://wiki.archlinux.org/title/fdisk，本题中，可以使用如下命令进行分区\nTGTDEV=/dev/ram0 sed -e 's/\\s*\\([\\+0-9a-zA-Z]*\\).*/\\1/' \u003c\u003c EOF | fdisk ${TGTDEV} n # new partition p # primary partition 1 # partition number 1 # default - start at beginning of disk # default - default size t # change partition type fd# to Linux raid autodetect w # write the partition table q # and we're done EOF 附件 link参考资料1\n下载ScalaRAID.pdf\n说明与工作区\n下载raid.zip\n"
            }
        );
    index.add(
            {
                id:  84 ,
                href: "\/TechDocs\/docs\/hpcgame\/%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E9%A2%98%E7%9B%AE\/finalc\/",
                title: "C. 工程精度离散单元法计算程序优化",
                description: "一、题目背景 link离散单元法 (discrete element method, DEM) 由岩土工程学者 Cundall 和 Strack 于 1979 年提出，是一种数值仿真方法。它将世界抽象为若干细小颗粒 (particle) 的集合，将时间抽象为若干个细小的时间步 (time step)，在每个时间步内，分析颗粒之间的接触 (contact)，通过适当的接触模型 (contact model) 计算接触力 (矩)，利用牛顿第三定律 (Newton’s third law) 赋予颗粒上。归集每个颗粒所受的合力 (矩)，然后利用牛顿第二定律 (Newton’s second law) 求得颗粒 (角) 加速度，再对 (角) 加速度两次时间积分，得到颗粒位置 (方位) 的变动。重复以上过程，即可模拟时间的流逝和世界的演变。\nDEM 因为基本假设简单，适用范围广，限制少。相比有限单元法 (finite element method, FEM)，DEM 可以自然模拟开裂、破碎等大变形问题，显式 DEM 也没有迭代收敛问题。DEM 被广泛用于土木工程、化学工程、工业工程等领域，通过数值仿真预测产品性能或工艺效果，从而指导工程实践。DEM 具有数值仿真共同的低成本优势，能以相比实验更低的成本，创造显著的经济效益。\n然而，DEM 有一个显著的劣势——计算量大，计算速度慢。因此，高性能计算 (high performance computing, HPC) 对 DEM 仿真的加速必不可少，以保证 DEM 的计算时间处于可接受的范围内，确保生产效率。\n2022 年 09 月，Taichi 社区举办了活动“Taichi DEM 代码优化挑战赛”。参赛作品使用 Taichi 高性能计算语言，编写 DEM 程序，丰富和完善其 DEM 各项功能。",
                content: "一、题目背景 link离散单元法 (discrete element method, DEM) 由岩土工程学者 Cundall 和 Strack 于 1979 年提出，是一种数值仿真方法。它将世界抽象为若干细小颗粒 (particle) 的集合，将时间抽象为若干个细小的时间步 (time step)，在每个时间步内，分析颗粒之间的接触 (contact)，通过适当的接触模型 (contact model) 计算接触力 (矩)，利用牛顿第三定律 (Newton’s third law) 赋予颗粒上。归集每个颗粒所受的合力 (矩)，然后利用牛顿第二定律 (Newton’s second law) 求得颗粒 (角) 加速度，再对 (角) 加速度两次时间积分，得到颗粒位置 (方位) 的变动。重复以上过程，即可模拟时间的流逝和世界的演变。\nDEM 因为基本假设简单，适用范围广，限制少。相比有限单元法 (finite element method, FEM)，DEM 可以自然模拟开裂、破碎等大变形问题，显式 DEM 也没有迭代收敛问题。DEM 被广泛用于土木工程、化学工程、工业工程等领域，通过数值仿真预测产品性能或工艺效果，从而指导工程实践。DEM 具有数值仿真共同的低成本优势，能以相比实验更低的成本，创造显著的经济效益。\n然而，DEM 有一个显著的劣势——计算量大，计算速度慢。因此，高性能计算 (high performance computing, HPC) 对 DEM 仿真的加速必不可少，以保证 DEM 的计算时间处于可接受的范围内，确保生产效率。\n2022 年 09 月，Taichi 社区举办了活动“Taichi DEM 代码优化挑战赛”。参赛作品使用 Taichi 高性能计算语言，编写 DEM 程序，丰富和完善其 DEM 各项功能。\n您将获得上述比赛优胜作品代码，作为本赛题的内容之一。该作品实现了一个复杂的 DEM 接触模型——胶结模型 (bond model)，胶结模型的特点是，在仿真一开始，通过外部命令控制颗粒之间按照一定判断准则形成胶结接触 (bond contact)。在此之后的仿真过程中，胶结可以进行受压、受拉、受剪等一系列力学响应，但当其正应力或剪应力满足破坏条件时，胶结将破坏消失，不再恢复。除此之外，颗粒之间的天然碰撞，采用不同于胶结接触的 Hertz-Mindlin 接触模型。\n作品的一个代表 Demo 如下，图中，一个斯坦福兔子形状的胶结团块自由下落撞击地面并摔碎。团块摔碎，伴随着其中颗粒间的胶结的破坏 （图片较大，请耐心等待。下载附件D以获得较好播放体验。\n二、赛题描述 link您将通过以下链接获取上述作品代码和 Demo：\nhttps://github.com/Denver-Pilphis/taichi_dem/tree/question/PKU_HPC_Competition\n其中，dem.py 文件包含了所有的程序代码，包含了详细的注释。运行 dem.py，将会在同目录下写出 output.p4p 和 output.p4c 两个文件，作为输出数据文件，分别存储每个存档时间点的颗粒信息和颗粒接触信息。\n对于使用Taichi实验的团队，具体任务是：\n请设计测试方法，测试程序性能瓶颈位置，并将其找出。 设法对至少一处性能瓶颈进行优化。 注意：\n只优化上述链接内提供的程序的代码，不优化 Taichi Runtime。 本次比赛测试环境限定为 Nvidia CUDA。 选手可以使用CUDA重新实现本程序，或作为组件调用，但需提交完整的依赖、编译脚本和运行说明。DEM的实现需为选手原创。\n三、提示 link 第二部分给出的 GitHub 仓库中，程序代码对应的文档请见附件A: DEM 理论部分文档 和 附件B: DEM HPC 实现文档\n可以使用 Taichi kernel profiling 测试，输出各个 kernel的耗时。\n四、测试方法 link第二部分给出的 GitHub 代码仓库中的 README.md 提供了 6 个 Example。6 个 Example 的输入数据文件在 Resource 目录下。dem.py 开头的注释详细说明了每个 Example 对应的输入数据文件和对应的物理参数 (注释中标注的物理参数，为代码中给定的默认参数列表中需要改变的部分; 未标注的参数，应保持原始值)。除 Example 1 外，所有的 Example 都可以用于赛中测试使用，但需要注意的是，DEM 的物理参数对计算结果有显著影响 (评分要求计算结果与原有代码结果一致，详见第五部分)，因此，在变更输入数据文件时，需要同步准确变更对应的物理参数，以确保计算结果正确。Example 2 为包含胶结的最小规模算例。\n最终的测试采用第6个 Example: 斯坦福兔子自由落体撞击水平表面 (快速计算版)。程序运行结束后，抽取 output.p4p 和 output.p4c 中任意若干个存档时间点，校验颗粒与接触信息 (均为双精度浮点数) 与原始代码运行结果是否一致。双精度浮点数一致的判据如下：\nabs(x′−x)"
            }
        );
    index.add(
            {
                id:  85 ,
                href: "\/TechDocs\/docs\/hpcgame\/%E7%AC%AC%E4%BA%8C%E9%98%B6%E6%AE%B5%E9%A2%98%E7%9B%AE\/finald\/",
                title: "D. Linkpack节点的选择程序优化",
                description: "赛题描述 link给定2个SPINE交换机下48个候选节点，要求在不超过3次Linpack计算的情况下，通过程序或脚本以全自动的方式选择16个节点，得到16节点的Linpack最优值。\nlinpack的评测指标是gflops。\n输入 link无，选手可自行获取相关信息\n输出 link结果输出到output.txt，其中包含16个节点名(可通过hostname -s获取)。与最优值误差在0.1%之内的结果都算正确。\n提交方式 link选手提交一个压缩包，我们运行其中run.sh，选手程序输出结果，我们进行核验。选手程序中NB值等可在run.sh指定，最后输出gflops值。\n测试环境 link我们提供了一个样例集群共选手实验提交之用，请注意，该集群及网络拓扑与最终测试的集群并不一致，选手程序需要有通用性，请勿针对该集群进行设计。\n选手可以向linpack分区提交任务以测试。请注意，单次申请节点数不得超过4个，单次申请时间不得超过30分钟，否则将失去该节点申请资格。建议选手在compute节点进行编码，向linpack提交任务进行测试。\n申请节点时请加上--exclusive选项，以免受其他评测影响。\n提示 link1． 使用Intel OneAPI MKL函数库下的mp_linpack软件测试包用于Linpack测试（安装在/data/software/intel/mkl/）。我们的集群中，只有SCOW集群安装了该脚本，请 2． 建议编写dgemm测试程序用于筛选Linpack测试的NB值，以及筛选候选节点的双精度性能 3． 建议采用MPI pingpong测试的方式分析出候选节点的网络拓扑",
                content: "赛题描述 link给定2个SPINE交换机下48个候选节点，要求在不超过3次Linpack计算的情况下，通过程序或脚本以全自动的方式选择16个节点，得到16节点的Linpack最优值。\nlinpack的评测指标是gflops。\n输入 link无，选手可自行获取相关信息\n输出 link结果输出到output.txt，其中包含16个节点名(可通过hostname -s获取)。与最优值误差在0.1%之内的结果都算正确。\n提交方式 link选手提交一个压缩包，我们运行其中run.sh，选手程序输出结果，我们进行核验。选手程序中NB值等可在run.sh指定，最后输出gflops值。\n测试环境 link我们提供了一个样例集群共选手实验提交之用，请注意，该集群及网络拓扑与最终测试的集群并不一致，选手程序需要有通用性，请勿针对该集群进行设计。\n选手可以向linpack分区提交任务以测试。请注意，单次申请节点数不得超过4个，单次申请时间不得超过30分钟，否则将失去该节点申请资格。建议选手在compute节点进行编码，向linpack提交任务进行测试。\n申请节点时请加上--exclusive选项，以免受其他评测影响。\n提示 link1． 使用Intel OneAPI MKL函数库下的mp_linpack软件测试包用于Linpack测试（安装在/data/software/intel/mkl/）。我们的集群中，只有SCOW集群安装了该脚本，请 2． 建议编写dgemm测试程序用于筛选Linpack测试的NB值，以及筛选候选节点的双精度性能 3． 建议采用MPI pingpong测试的方式分析出候选节点的网络拓扑\n"
            }
        );
    search.addEventListener('input', show_results, true);

    function show_results(){
        const maxResult =  5 ;
        const minlength =  1 ;
        var searchQuery = this.value;
        var results = index.search(searchQuery, {limit: maxResult, enrich: true});

        
        const flatResults = new Map(); 
        for (const result of results.flatMap(r => r.result)) {
        if (flatResults.has(result.doc.href)) continue;
        flatResults.set(result.doc.href, result.doc);
        }

        suggestions.innerHTML = "";
        suggestions.classList.remove('d-none');

        
        if (searchQuery.length < minlength) {
            const minCharMessage = document.createElement('div')
            minCharMessage.innerHTML = `Please type at least <strong>${minlength}</strong> characters`
            minCharMessage.classList.add("suggestion__no-results");
            suggestions.appendChild(minCharMessage);
            return;
        } else {
            
            if (flatResults.size === 0 && searchQuery) {
                const noResultsMessage = document.createElement('div')
                noResultsMessage.innerHTML = "No results for" + ` "<strong>${searchQuery}</strong>"`
                noResultsMessage.classList.add("suggestion__no-results");
                suggestions.appendChild(noResultsMessage);
                return;
            }
        }

        
        for(const [href, doc] of flatResults) {
            const entry = document.createElement('div');
            suggestions.appendChild(entry);

            const a = document.createElement('a');
            a.href = href;
            entry.appendChild(a);

            const title = document.createElement('span');
            title.textContent = doc.title;
            title.classList.add("suggestion__title");
            a.appendChild(title);

            const description = document.createElement('span');
            description.textContent = doc.description;
            description.classList.add("suggestion__description");
            a.appendChild(description);

            suggestions.appendChild(entry);

            if(suggestions.childElementCount == maxResult) break;
        }
    }
    }());
</script>
    
</body></html>